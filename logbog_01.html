<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="imagefiles/apple-touch-icon.png">
    <title>Logbog</title>
    <!-- Firebase App (the core Firebase SDK) - Using v8 for compatibility -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <!-- Firebase Authentication -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <!-- Firestore -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 0px;
            display: flex;
            justify-content: center;
        }

        .container {
            width: 100%;
            max-width: 1400px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 0px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            padding: 16px 24px;
            padding-top: calc(env(safe-area-inset-top) + 16px);
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            position: relative;
            transition: background 0.3s ease;
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 300;
            width: 100%;
            text-align: center;
        }

        .header .nav-controls {
            position: absolute;
            top: 16px;
            left: 24px;
            display: inline-flex;
            flex-direction: column;
            gap: 0;
            align-items: flex-start;
        }

        .nav-toggle-btn {
            width: 35px;
            height: 35px;
            padding: 5px 8px;
            border: none;
            border-radius: 12px;
            background: #e5e7eb;
            color: #374151;
            box-shadow: 0 12px 26px rgba(15, 23, 42, 0.16);
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            cursor: pointer;
            transition: all 0.25s ease;
        }

        .nav-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(107, 114, 128, 0.3);
        }

        .nav-toggle-btn span {
            width: 16px;
            height: 2px;
            border-radius: 999px;
            background: #374151;
        }

        .nav-box {
            position: absolute;
            top: calc(100% + 12px);
            left: 0;
            background: white;
            border-radius: 16px;
            padding: 16px 20px;
            z-index: 10;
            display: none;
            flex-direction: column;
            gap: 10px;
            min-width: 200px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
        }

        .nav-box.show {
            display: flex;
        }

        .nav-overlay {
            position: fixed;
            inset: 0;
            background: transparent;
            display: none;
            z-index: 5;
        }

        .nav-overlay.show {
            display: block;
        }

        .nav-button {
            padding: 8px 16px;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            text-align: center;
            display: block;
            min-width: 140px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
        }

        .nav-button:hover {
            transform: translateY(-2px);
        }

        .nav-button:nth-child(1) {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }

        .nav-button:nth-child(1):hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }

        .nav-button:nth-child(2) {
            background: linear-gradient(135deg, #E6B94F 0%, #d97706 100%);
        }

        .nav-button:nth-child(2):hover {
            background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
            box-shadow: 0 5px 15px rgba(245, 158, 11, 0.3);
        }

        .nav-button:nth-child(3) {
            background: linear-gradient(135deg, #3368AE 0%, #1e40af 100%);
        }

        .nav-button:nth-child(3):hover {
            background: linear-gradient(135deg, #1e40af 0%, #1e3a8a 100%);
            box-shadow: 0 5px 15px rgba(37, 99, 235, 0.3);
        }

        .nav-button:nth-child(4) {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
        }

        .nav-button:nth-child(4):hover {
            background: linear-gradient(135deg, #db2777 0%, #be185d 100%);
            box-shadow: 0 5px 15px rgba(236, 72, 153, 0.3);
        }

        .nav-button:nth-child(5) {
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
        }

        .nav-button:nth-child(5):hover {
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
            box-shadow: 0 5px 15px rgba(71, 85, 105, 0.3);
        }

        .nav-button.active {
            background: #9ca3af !important;
            cursor: default;
            pointer-events: none;
        }
        /* Check in button (purple) */
        .nav-button.nav-checkin {
            background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);
        }
        .nav-button.nav-checkin:hover {
            background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
            box-shadow: 0 5px 15px rgba(124, 58, 237, 0.3);
        }

        .content {
            padding: 10px;
            padding-right: 0px;
            padding-left: 5px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 100%;
        }

        .card {
            background: #f5f5f8;
            border-radius: 18px;
            padding: 7px 5px;
            box-shadow: 0 10px 25px rgba(15, 23, 42, 0.12);
        }

        .log-layout {
            position: relative;
            display: block;
        }

        .log-primary {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            padding-right: 10px;
        }

        .log-history-sidebar {
            position: fixed;
            top: 0;
            right: 0px;
            width: 200px;
            height: 100vh;
            background: #f8fafc;
            border: none;
            border-radius: 18px 0 0 18px;
            overflow-x: visible;
            overflow-y: hidden;
            display: flex;
            flex-direction: column;
            transition: transform 0.6s ease;
            box-shadow: 0 20px 40px rgba(15, 23, 42, 0.18);
            z-index: 100;
        }

        .log-history-top-bar {
            height: calc(env(safe-area-inset-top) + 69px);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            position: relative;
            flex-shrink: 0;
            overflow: visible;
        }

        .log-history-sidebar.collapsed {
            transform: translateX(200px);
            overflow: visible;
            border-radius: 18px 0 0 18px;
        }

        .log-history-sidebar.collapsed .log-collapse-toggle {
            left: -28px;
        }

        .log-history-sidebar.collapsed .log-collapse-toggle-bottom {
            left: -28px;
        }

        .log-collapse-toggle {
            position: absolute;
            left: 2px;
            bottom: 10px;
            background: #4f46e5;
            color: white;
            border: none;
            width: 20px;
            height: 50px;
            border-radius: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 100;
            padding: 0;
        }

        .log-collapse-toggle img {
            width: 12px;
            height: 30px;
            filter: brightness(0) invert(1);
            transition: transform 0.6s ease;
        }

        .log-history-sidebar.collapsed .log-collapse-toggle img {
            transform: rotate(180deg);
        }

        .log-collapse-toggle:hover {
            background: #4338ca;
            transform: scale(1.1);
        }

        .log-collapse-toggle-bottom {
            top: auto;
            bottom: 8px;
        }

        .log-history-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .log-history-sidebar.collapsed .log-history-content {
            display: none;
        }

        .log-history-list {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            padding-bottom: 60px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .log-history-item {
            padding: 10px;
            margin-bottom: 6px;
            border-radius: 10px;
            background: #e0e7ff;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 6px;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            border: 2px solid transparent;
            position: relative;
            touch-action: manipulation;
        }

        .log-history-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 18px rgba(15, 23, 42, 0.15);
        }

        .log-history-item.active {
            background: #c7d2fe;
            color: #1f2937;
            border-color: #6366f1;
            box-shadow: 0 12px 22px rgba(79, 70, 229, 0.25);
        }

        .log-history-item-date {
            font-weight: 600;
            font-size: 0.95rem;
            text-transform: capitalize;
        }

        .log-history-item-weekday {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .log-history-item-snippet {
            font-size: 0.82rem;
            opacity: 0.9;
            line-height: 1.4;
        }

        .log-history-item-meta {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .log-history-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            position: relative;
            padding: 2px 12px;
            border-radius: 999px;
            margin-bottom: 6px;
        }

        .log-history-item-date {
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .log-history-color-btn {
            flex-shrink: 0;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: none;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
            opacity: 0;
            pointer-events: none;
            z-index: 10;
        }

        .log-history-item:hover .log-history-color-btn,
        .log-history-item.active .log-history-color-btn {
            opacity: 1;
            pointer-events: auto;
        }

        .log-history-color-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .log-history-color-picker-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(15, 23, 42, 0.35);
            z-index: 5001;
        }

        .log-history-color-picker-modal.show {
            display: flex;
        }

        .log-history-color-picker {
            width: calc(32px * 6 + 8px * 5 + 16px * 2);
            background: #ffffff;
            border-radius: 14px;
            padding: 16px;
            box-shadow: 0 18px 45px rgba(15, 23, 42, 0.25);
            border: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .log-history-color-picker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .log-history-color-picker-header h3 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: #1f2937;
        }

        .log-history-color-grid {
            display: grid;
            grid-template-columns: repeat(6, 32px);
            gap: 8px;
            justify-content: center;
        }

        .log-history-color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 1px solid rgba(15, 23, 42, 0.08);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .log-history-color-swatch:hover {
            transform: scale(1.08);
            box-shadow: 0 6px 14px rgba(15, 23, 42, 0.2);
        }

        .log-history-remove-color-btn {
            padding: 8px 16px;
            background: #f3f4f6;
            color: #6b7280;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .log-history-remove-color-btn:hover {
            background: #e5e7eb;
            color: #374151;
        }

        .activities-card {
            background: #f5f5f8;
            grid-column: 1 / -1;
        }

        .card-title {
            font-size: 1.25rem;
            color: #1f2937;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            padding-left: 18px;
        }

        .card-title span {
            font-size: 1rem;
            color: #524f56;
            font-weight: 500;
        }

        .activities-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, 160px);
            gap: 10px;
            justify-content: flex-start;
        }

        .activity-link {
            text-decoration: none;
            display: block;
        }

        .activity-tile {
            border-radius: 16px;
            padding: 12px 14px;
            color: white;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 2px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            width: 160px;
            min-height: 65px;
            text-align: left;
        }

        .activity-tile::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0));
            mix-blend-mode: screen;
            pointer-events: none;
        }
        
        .activity-tile.empty::after {
            display: none;
        }

        .activity-label {
            flex: 0 0 auto;
            min-width: 0;
            font-size: 1.0rem;
            font-weight: 600;
            line-height: 1.2;
            text-transform: none;
            letter-spacing: 0.02em;
            opacity: 1;
        }

        .activity-tile:hover {
            transform: translateY(-6px);
            box-shadow: 0 18px 30px rgba(15, 23, 42, 0.25);
        }

        .activity-meta {
            flex: 0 0 auto;
            font-size: 0.75rem;
            font-weight: 500;
            opacity: 0.7;
        }

        .activity-tile.empty {
            background: #ffffff;
            box-shadow: none;
            border: 3px dashed currentColor;
            color: inherit;
            flex-direction: row;
            align-items: flex-start;
            justify-content: space-between;
        }

        .activity-tile.empty .activity-content {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex: 0 1 auto;
            max-width: 90px;
        }

        .activity-empty-text {
            font-size: 0.75rem;
            opacity: 0.7;
            font-weight: 500;
        }

        .activity-empty-circle {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid currentColor;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            position: relative;
            z-index: 2;
            background: white;
        }

        .activity-empty-icon {
            width: 15px;
            height: 15px;
            position: relative;
            flex-shrink: 0;
        }

        .activity-empty-icon::before,
        .activity-empty-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            background: currentColor;
            border-radius: 1px;
        }

        .activity-empty-icon::before {
            width: 15px;
            height: 2px;
            transform: translate(-50%, -50%);
        }

        .activity-empty-icon::after {
            width: 2px;
            height: 15px;
            transform: translate(-50%, -50%);
        }

        .journal-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        .journal-entry,
        .dreams-entry {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 0;
            border-radius: 18px;
        }

        .journal-entry {
            background: #f5f5f8;
        }

        .dreams-entry {
            padding: 7px;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(124, 58, 237, 0.12) 100%);
            border: 1px solid rgba(124, 58, 237, 0.2);
        }

        .journal-entry label,
        .dreams-entry label {
            font-size: 1.25rem;
            font-weight: 600;
            color: #475569;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            display: flex;
            align-items: center;
            gap: 10px;
            padding-left: 18px;
        }

        .journal-title {
            overflow: visible;
            justify-content: space-between;
        }

        .journal-title-content {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .journal-title img {
            width: 55px;
            height: auto;
            flex-shrink: 0;
        }

        .journal-copy-btn {
            padding: 8px 16px;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            display: block;
            text-transform: none;
            letter-spacing: normal;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
            background: linear-gradient(135deg, #E6B94F 0%, #d97706 100%);
        }

        .journal-copy-btn:hover {
            background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(245, 158, 11, 0.3);
        }

        .journal-copy-btn:active {
            transform: translateY(0);
        }

        .dreams-title {
            justify-content: space-between;
        }

        .dreams-title-content {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dreams-title img {
            width: 56px;
            height: auto;
        }

        .dreams-copy-btn {
            padding: 8px 16px;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            display: block;
            text-transform: none;
            letter-spacing: normal;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
        }

        .dreams-copy-btn:hover {
            background: linear-gradient(135deg, #db2777 0%, #be185d 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(236, 72, 153, 0.3);
        }

        .dreams-copy-btn:active {
            transform: translateY(0);
        }


        .journal-entry textarea,
        .dreams-entry textarea {
            width: 100%;
            min-height: 200px;
            padding: 9px;
            border-radius: 12px;
            border: none;
            background: rgba(255, 255, 255, 0.92);
            color: #1f2937;
            font-family: 'Arial', sans-serif;
            font-size: 16px; /* avoid iOS zoom on focus */
            line-height: 1.6;
            resize: none;
            overflow-y: auto;
            max-height: 450px;
            -webkit-appearance: none;
            appearance: none;
        }

        .journal-entry textarea:focus {
            outline: none;
            box-shadow: none;
            background: #ececf4;
        }

        .dreams-entry textarea:focus {
            outline: none;
            border-color: #7c3aed;
            box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.2);
        }

        .journal-entry textarea {
            background: #ffffff;
            height: auto;
            min-height: 200px;
        }

        .tanker-card {
            background: #f5f5f8;
            grid-column: 1 / -1;
        }

        .tanker-entry {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 0;
            background: #f5f5f8;
        }

        .tanker-entry label {
            font-size: 1.25rem;
            font-weight: 600;
            color: #475569;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .tanker-entry textarea {
            width: 100%;
            min-height: 100px;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-family: 'Arial', sans-serif;
            font-size: 16px;
            line-height: 1.6;
            resize: vertical;
            background: #d1fae5;
            color: #1f2937;
            -webkit-appearance: none;
            appearance: none;
        }

        .tanker-entry textarea:focus {
            outline: none;
            box-shadow: none;
            background: #d1fae5;
        }

        .tanker-entry textarea::placeholder {
            color: #9ca3af;
            font-style: italic;
        }

        .dreams-entry textarea {
            min-height: 160px;
            padding: 9px;
            background: rgba(139, 92, 246, 0.08);
            border: 1px solid rgba(124, 58, 237, 0.25);
            color: #312e81;
            font-family: 'Arial', sans-serif;
            font-size: 16px; /* ensure >=16px for iOS */
            -webkit-appearance: none;
            appearance: none;
        }

        .dreams-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #475569;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .checkins-card {
            padding-bottom: 0;
        }

        .checkins-header {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 16px;
            padding-bottom: 9px;
        }


        .checkin-view-toggle {
            width: 40px;
            height: 40px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-right: 0;
            background: white;
            border-radius: 8px;
            padding: 0;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
            overflow: hidden;
            display: block;
            object-fit: cover;
        }

        .checkin-view-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .checkin-add-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: white;
            color: #7c3aed;
            font-size: 28px;
            font-weight: 300;
            line-height: 1;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            overflow: visible;
            position: relative;
        }
        
        .checkin-add-btn span {
            display: inline-block;
            transform: scale(2);
            transform-origin: center center;
        }

        .checkin-add-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(124, 58, 237, 0.3);
        }

        .checkin-days-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: white;
            color: #7c3aed;
            font-size: 14px;
            font-weight: 600;
            line-height: 1;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .checkin-days-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(124, 58, 237, 0.3);
        }

        .checkin-days-btn.active {
            background: #7c3aed;
            color: white;
        }

        .chart-tooltip {
            position: absolute;
            background: white;
            border: 2px solid #3b82f6;
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            pointer-events: none;
            z-index: 1000;
            font-size: 12px;
        }

        .chart-tooltip p {
            margin: 0;
            font-weight: bold;
        }

        .chart-tooltip p:not(:first-child) {
            margin-top: 4px;
            font-weight: normal;
        }

        .collapse-btn {
            background: #4f46e5;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 0;
            position: relative;
        }

        .collapse-btn:hover {
            background: #4338ca;
            transform: scale(1.1);
        }

        .collapse-btn .arrow {
            display: inline-block;
            transition: transform 0.3s ease;
            font-size: 14px;
            line-height: 1;
        }

        .checkins-body {
            max-height: none;
            overflow: visible;
        }

        .chart-wrapper {
            position: relative;
            padding: 0px 0 11px;
            margin-left: 44px;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
        }

        .chart-canvas {
            display: block;
            width: 100%;
            height: 240px;
            border-radius: 0px;
            border-radius: 16px;
            background: white;
            box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.25);
        }

        .checkins-side-icons {
            position: absolute;
            left: 1px;
            top: -5px;
            width: 42px;
            height: 240px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            z-index: 10;
        }

        .checkins-side-icons img {
            width: 42px;
            height: auto;
        }

        .chart-legend {
            display: flex;
            gap: 20px;
            align-items: center;
            padding: 12px 8px 20px;
            flex-wrap: wrap;
            color: #475569;
            font-size: 0.9rem;
        }

        .legend-item {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .legend-swatch {
            width: 16px;
            height: 16px;
            border-radius: 999px;
        }

        .checkin-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(15, 23, 42, 0.35);
            z-index: 5001;
        }

        .checkin-modal.show {
            display: flex;
        }

        .checkin-modal-content {
            background: white;
            border-radius: 18px;
            padding: 24px;
            box-shadow: 0 20px 45px rgba(15, 23, 42, 0.25);
            width: 90%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .checkin-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .checkin-modal-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0;
        }

        .checkin-modal-close {
            background: none;
            border: none;
            font-size: 64px;
            color: #6b7280;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            transition: color 0.2s ease;
            overflow: visible;
        }

        .checkin-modal-close:hover {
            color: #1f2937;
        }

        .checkin-slider-container {
            display: flex;
            align-items: center;
            gap: 16px;
            position: relative;
            padding: 10px 0;
        }

        .checkin-slider-icon {
            width: 32px;
            height: 32px;
            flex-shrink: 0;
        }

        .checkin-slider {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            background: #e5e7eb;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .checkin-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #7c3aed;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(124, 58, 237, 0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .checkin-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(124, 58, 237, 0.4);
        }

        .checkin-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #7c3aed;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(124, 58, 237, 0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .checkin-slider::-moz-range-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(124, 58, 237, 0.4);
        }

        .checkin-slider-value {
            text-align: center;
            font-size: 2rem;
            font-weight: 600;
            color: #7c3aed;
        }

        .checkin-save-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3);
        }

        .checkin-save-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(124, 58, 237, 0.4);
        }

        .checkin-save-btn:active {
            transform: translateY(0);
        }

        .empty-state {
            padding: 32px 0;
            text-align: center;
            color: #6b7280;
            font-size: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" id="pageHeader">
            <div class="nav-controls">
                <button class="nav-toggle-btn" onclick="toggleNavBox(event)" title="Navigation">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <div class="nav-box" id="navBox">
                    <a href="opstilling_01.html" class="nav-button">Opstilling</a>
                    <a href="dialog_01.html" class="nav-button">Dialog</a>
                    <a href="compare_01.html" class="nav-button">Ligheder</a>
                    <a href="bodymap_01.html" class="nav-button">BodyMap</a>
                    <a href="logbog_01.html" class="nav-button active">Logbog</a>
                    <a href="checkin.html" class="nav-button nav-checkin">Check in</a>
                </div>
            </div>
            <h1>Logbog</h1>
        </div>

        <div class="content">
            <div class="log-layout">
                <div class="log-primary">
                    <section class="card activities-card">
                        <div class="card-title">
                            <strong>AKTIVITETER</strong>
                            <span id="activityDateLabel">Dagens overblik</span>
                        </div>
                        <div class="activities-grid" id="activitiesGrid"></div>
                    </section>

                    <section class="card tanker-card">
                        <div class="card-title">
                            <strong>TANKER</strong>
                        </div>
                        <div class="tanker-entry">
                            <textarea id="tankerEntry" readonly placeholder="Ingen tanker for denne dag"></textarea>
                        </div>
                    </section>

                    <section class="card journal-card">
                        <div class="journal-grid">
                            <div class="journal-entry">
                                <label class="journal-title" for="logbookEntry">
                                    <span class="journal-title-content">
                                        Dagbog
                                        <img src="imagefiles/write_log.svg" alt="Dagbog ikon">
                                    </span>
                                    <button type="button" class="journal-copy-btn" id="journalCopyBtn">Kopier</button>
                                </label>
                                <textarea id="logbookEntry" placeholder="Skriv dit dagbogsnotat her..."></textarea>
                            </div>
                            <div class="dreams-entry">
                                <label class="dreams-title" for="dreamEntry">
                                    <span class="dreams-title-content">
                                        Drømme
                                        <img src="imagefiles/moon.svg" alt="Måne ikon">
                                    </span>
                                    <button type="button" class="dreams-copy-btn" id="dreamsCopyBtn">Kopier</button>
                                </label>
                                <textarea id="dreamEntry" placeholder="Nedskriv dine drømme, fantasier og indskydelser ..."></textarea>
                            </div>
                        </div>
                    </section>

                    <section class="card checkins-card">
                        <div class="checkins-header">
                            <div class="card-title">
                                <strong>CHECKINS</strong>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px;">
                            <img class="checkin-view-toggle" id="toggleCheckinView" src="imagefiles/simpleCurve.svg" alt="Skift visning" title="Skift visning">
                                <button class="checkin-add-btn" id="openCheckinModal" title="Tilføj check-in"><span>+</span></button>
                                <button class="checkin-days-btn" data-days="1" title="Vis 1 dag">1</button>
                                <button class="checkin-days-btn" data-days="5" title="Vis 5 dage">5</button>
                                <button class="checkin-days-btn" data-days="10" title="Vis 10 dage">10</button>
                            </div>
                        </div>
                        <div class="checkins-body" id="checkinsBody">
                            <div style="position: relative;">
                                <div class="checkins-side-icons">
                                    <img src="imagefiles/sun.svg" alt="Høj energi" style="margin-top: 10%;">
                                    <img src="imagefiles/cloud.svg" alt="Lav energi" style="margin-bottom: -10%;">
                                </div>
                                <div class="chart-wrapper">
                                    <canvas class="chart-canvas" id="checkinChart"></canvas>
                                    <div class="chart-tooltip" id="checkinTooltip" style="display: none;"></div>
                                </div>
                            </div>
                        </div>
                    </section>
                </div>
                <aside class="log-history-sidebar" id="logHistorySidebar">
                    <div class="log-history-top-bar">
                        <button class="log-collapse-toggle" onclick="toggleLogHistorySidebar()" title="Fold historik"><img src="imagefiles/arrow.svg" alt="Toggle"></button>
                    </div>
                    <div class="log-history-content">
                        <div class="log-history-list" id="logHistoryList"></div>
                    </div>
                    <button class="log-collapse-toggle log-collapse-toggle-bottom" onclick="toggleLogHistorySidebar()" title="Fold historik"><img src="imagefiles/arrow.svg" alt="Toggle"></button>
                </aside>
            </div>
        </div>
    </div>
    <div class="nav-overlay" id="navOverlay"></div>

    <!-- Log History Color Picker Modal -->
    <div class="log-history-color-picker-modal" id="logHistoryColorPickerModal">
        <div class="log-history-color-picker" onclick="event.stopPropagation()">
            <div class="log-history-color-picker-header">
                <h3>Vælg farve</h3>
            </div>
            <div class="log-history-color-grid" id="logHistoryColorGrid"></div>
            <button class="log-history-remove-color-btn" id="logHistoryRemoveColorBtn">Fjern farve</button>
        </div>
    </div>

    <div class="checkin-modal" id="checkinModal">
        <div class="checkin-modal-content">
            <div class="checkin-modal-header">
                <h2>Check-in</h2>
                <button class="checkin-modal-close" id="closeCheckinModal">&times;</button>
            </div>
            <div class="checkin-slider-container">
                <img src="imagefiles/cloud.svg" alt="Lav energi" class="checkin-slider-icon checkin-slider-icon-left">
                <input type="range" min="0" max="100" value="50" class="checkin-slider" id="checkinSlider">
                <img src="imagefiles/sun.svg" alt="Høj energi" class="checkin-slider-icon checkin-slider-icon-right">
            </div>
            <div class="checkin-slider-value" id="checkinSliderValue">50</div>
            <button class="checkin-save-btn" id="saveCheckinBtn">Check-in</button>
        </div>
    </div>

    <script>
        const activityStyles = {
            bodymap: {
                gradient: 'linear-gradient(135deg, #ec4899 0%, #db2777 100%)',
                url: 'bodymap_01.html',
                accent: '#ec4899'
            },
            opstilling: {
                gradient: 'linear-gradient(135deg, #10b981 0%, #059669 100%)',
                url: 'opstilling_01.html',
                accent: '#10b981'
            },
            dialog: {
                gradient: 'linear-gradient(135deg, #E6B94F 0%, #d97706 100%)',
                url: 'dialog_01.html',
                accent: '#d97706'
            },
            relationer: {
                gradient: 'linear-gradient(135deg, #3368AE 0%, #1e40af 100%)',
                url: 'compare_01.html',
                accent: '#1e40af'
            },
            default: {
                gradient: 'linear-gradient(135deg, #64748b 0%, #475569 100%)',
                url: '#',
                accent: '#475569'
            }
        };

        const mockActivities = [
            {
                id: 1,
                type: 'opstilling',
                label: 'Opstilling',
                text: 'Familie',
                time: '14:15',
            },
            {
                id: 2,
                type: 'dialog',
                label: 'Dialog',
                text: 'Far og mig',
                time: '11:00',
            },
            {
                id: 3,
                type: 'relationer',
                label: 'Ligheder',
                text: 'Forskel far',
                time: '18:45',
            },
            {
                id: 4,
                type: 'bodymap',
                label: 'BodyMap',
                text: 'Min krop',
                time: '09:30',
            }
        ];

        const LOGBOOK_STORAGE_KEY = 'logbogData';
        const LOG_HISTORY_COLLAPSED_KEY = 'logbog_historySidebarCollapsed';
        const BODYMAP_STORAGE_KEY = 'bodymapData';
        const DIALOG_STORAGE_KEY = 'dialogData';
        const OPSTILLING_STORAGE_KEY = 'opstillingData';
        const COMPARE_STORAGE_KEY = 'compareData';

        // Color presets for log history items (same as dialog collections)
        // Standard farve for alle history items
        const DEFAULT_HISTORY_COLOR = '#b8735e'; // Varm rødlig brun som standard
        
        const LOG_HISTORY_COLOR_PRESETS = [
            '#ef4444', '#f97316', '#fbbf24', '#10b981', '#14b8a6', '#0ea5e9',
            '#3b82f6', '#6366f1', '#a855f7', '#ec4899', '#f472b6', '#94a3b8'
        ];

        let logHistoryColorPickerTarget = null;

        // Affirmations
        let affirmations = [];
        
        async function loadAffirmations() {
            try {
                const response = await fetch('affirmations.json');
                if (response.ok) {
                    affirmations = await response.json();
                    return affirmations;
                } else {
                    console.error('Kunne ikke indlæse affirmations.json');
                    return [];
                }
            } catch (error) {
                console.error('Fejl ved indlæsning af affirmations:', error);
                return [];
            }
        }
        
        async function getAffirmationTextForDate(dateKey) {
            // Get affirm from logbogData (new structure)
            try {
                const affirm = await getAffirmForDate(dateKey);
                if (affirm && affirm.trim()) {
                    return affirm.trim();
                }
            } catch (error) {
                console.warn('[AFFIRM] Kunne ikke hente affirm fra logbogData:', error);
            }
            
            // Fallback to old method if affirm not found in logbogData
            if (affirmations.length === 0) {
                return null;
            }
            
            // Parse the dateKey (YYYY-MM-DD) to a Date object
            const targetDate = new Date(dateKey);
            if (Number.isNaN(targetDate.getTime())) {
                return null;
            }
            
            // Reference date (1. januar 2024) - same as checkin.html
            const referenceDate = new Date('2024-01-01');
            
            // Set both dates to midnight for accurate day calculation
            referenceDate.setHours(0, 0, 0, 0);
            targetDate.setHours(0, 0, 0, 0);
            
            // Calculate days difference
            const daysDiff = Math.floor((targetDate - referenceDate) / (1000 * 60 * 60 * 24));
            
            // Modulo based on number of affirmations and add 1 to get 1-based index
            const dayNumber = (daysDiff % affirmations.length) + 1;
            
            // Get the affirmation text (convert to 0-based index)
            const affirmationText = affirmations[dayNumber - 1];
            
            return affirmationText;
        }

        /**
         * Læser brugerens timezone fra userData (indexuserData i localStorage)
         * Fallback hierarki:
         * 1. userData.timezone
         * 2. Browser's timezone (Intl API)
         * 3. 'Europe/Copenhagen' (default)
         */
        function getUserTimezone() {
            try {
                // 1. Prøv at læse fra userData
                const userDataStr = localStorage.getItem('indexuserData');
                if (userDataStr) {
                    const userData = JSON.parse(userDataStr);
                    if (userData.timezone && isValidTimezone(userData.timezone)) {
                        return userData.timezone;
                    }
                }
            } catch (e) {
                console.warn('Kunne ikke læse timezone fra userData:', e);
            }
            
            // 2. Fallback til browser's timezone
            try {
                const browserTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                if (browserTimezone && isValidTimezone(browserTimezone)) {
                    return browserTimezone;
                }
            } catch (e) {
                console.warn('Kunne ikke læse browser timezone:', e);
            }
            
            // 3. Ultimate fallback
            return 'Europe/Copenhagen';
        }

        /**
         * Validerer om en timezone string er gyldig
         */
        function isValidTimezone(tz) {
            if (!tz || typeof tz !== 'string') return false;
            try {
                Intl.DateTimeFormat(undefined, { timeZone: tz });
                return true;
            } catch (e) {
                return false;
            }
        }

        /**
         * Konverterer Date eller ISO string til lokal dato (YYYY-MM-DD) i brugerens timezone
         * @param {Date|string|null} date - Dato at konvertere (default: nu)
         * @returns {string|null} - Dato i YYYY-MM-DD format eller null ved fejl
         */
        function getLocalDateKey(date = null) {
            const d = date ? new Date(date) : new Date();
            if (isNaN(d.getTime())) return null;
            
            const timezone = getUserTimezone();
            
            // Konverter til lokal tid ved at formatere med da-DK locale og brugerens timezone
            const localDateStr = d.toLocaleDateString('da-DK', {
                timeZone: timezone,
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });
            
            // Format er "DD.MM.YYYY" - konverter til "YYYY-MM-DD"
            const [day, month, year] = localDateStr.split('.');
            return `${year}-${month}-${day}`;
        }

        function getTodayDateKey() {
            return getLocalDateKey();
        }

        function normalizeDateKey(dateStr) {
            if (!dateStr) return null;
            const parsed = parseDanishDateTime(dateStr) || new Date(dateStr);
            if (!parsed || Number.isNaN(parsed.getTime())) return null;
            return getLocalDateKey(parsed);
        }

        async function loadAllUserData(forceRefresh = false) {
            if (!currentUser || !db) return null;
            
            if (!forceRefresh && window.allUserData) {
                return window.allUserData;
            }
            
            if (!forceRefresh && window.allDataLoadingPromise) {
                return window.allDataLoadingPromise;
            }
            
            window.allDataLoadingPromise = (async () => {
                try {
                    const userDocRef = db.collection('users').doc(currentUser.uid);
                    console.log('🔥 FIRESTORE READ - logbog_01.html - loadAllUserData');
                    const doc = await userDocRef.get();
                    const raw = doc.exists ? (doc.data() || {}) : {};
                    const data = {
                        bodymapData: raw.bodymapData || null,
                        dialogData: raw.dialogData || null,
                        opstillingData: raw.opstillingData || null,
                        compareData: raw.compareData || null,
                        logbogData: Array.isArray(raw.logbogData) ? raw.logbogData : null,
                        // forside_checkin_data is deprecated - kept for migration compatibility only
                        forside_checkin_data: Array.isArray(raw.forside_checkin_data) ? raw.forside_checkin_data : null
                    };
                    window.allUserData = data;
                    return data;
                } catch (error) {
                    console.error('[LOAD] Error loading all user data:', error);
                    window.allUserData = null;
                    return null;
                } finally {
                    window.allDataLoadingPromise = null;
                }
            })();
            
            return window.allDataLoadingPromise;
        }
        
        // Load logbook data from Firestore via cached user document
        async function loadLogbookDataFromFirestore() {
            const data = await loadAllUserData();
            if (!data) return null;
            return data.logbogData;
        }
        
        // Load logbook entries from cache (used by check-in functions)
        async function getLogbookEntries() {
            if (!currentUser || !db) {
                console.error('[LOAD] User not logged in - cannot load data');
                return [];
            }
            
            try {
                // Use cached data instead of reading from Firestore every time!
                const data = await loadAllUserData();
                if (data && Array.isArray(data.logbogData)) {
                    return data.logbogData;
                }
            } catch (error) {
                console.error('[LOAD] Error loading logbogData:', error);
            }
            
            return [];
        }
        
        // Helper: Get or create a logbog entry for a specific date
        async function getOrCreateLogbogEntry(dateKey) {
            const entries = await getLogbookEntries();
            let entry = entries.find(item => item.date === dateKey);
            
            if (!entry) {
                entry = {
                    date: dateKey,
                    dagbog: '',
                    dreams: '',
                    checkins: [],
                    timestamp: new Date().toISOString(),
                    color: '#b8735e'
                };
                entries.push(entry);
                await saveLogbookDataToFirestore(entries);
            }
            
            return entry;
        }
        
        // Helper: Add a check-in to a specific date
        async function addCheckinToDate(dateKey, time, status) {
            const entries = await getLogbookEntries();
            let entry = entries.find(item => item.date === dateKey);
            
            if (!entry) {
                entry = {
                    date: dateKey,
                    dagbog: '',
                    dreams: '',
                    checkins: [],
                    timestamp: new Date().toISOString(),
                    color: '#b8735e'
                };
                entries.push(entry);
            }
            
            // Initialize checkins array if needed
            if (!Array.isArray(entry.checkins)) {
                entry.checkins = [];
            }
            
            // Add check-in
            entry.checkins.push({ time, status });
            entry.timestamp = new Date().toISOString();
            
            await saveLogbookDataToFirestore(entries);
            return entry;
        }
        
        // Save logbook data to Firestore
        async function saveLogbookDataToFirestore(entries) {
            if (!currentUser || !db) return false;
            
            try {
                const userDocRef = db.collection('users').doc(currentUser.uid);
                await userDocRef.set({
                    logbogData: entries,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
                
                console.log('[SAVE] Success');
                return true;
            } catch (error) {
                console.error('[SAVE] Error:', error);
                return false;
            }
        }

        async function getLogbookData(forceRefresh = false) {
            if (currentUser && db) {
                // User is logged in - read from Firestore
                const firestoreData = await loadLogbookDataFromFirestore();
                
                if (firestoreData !== null) {
                    // Normalize data
                    let mutated = false;
                    const normalizedEntries = firestoreData.map(entry => {
                        if (!entry || typeof entry !== 'object') return entry;
                        // Normalize date to ISO YYYY-MM-DD
                        const normalizedKey = normalizeDateKey(entry.date);
                        let nextEntry = entry;
                        if (normalizedKey && normalizedKey !== entry.date) {
                            mutated = true;
                            nextEntry = { ...nextEntry, date: normalizedKey };
                        }
                        // Ensure timestamp (ISO 8601). For legacy entries without timestamp, derive from date at local midnight
                        if (!nextEntry.timestamp) {
                            const derived = new Date(`${normalizedKey || entry.date}T00:00:00`);
                            if (!Number.isNaN(derived.getTime())) {
                                nextEntry = { ...nextEntry, timestamp: derived.toISOString() };
                                mutated = true;
                            } else {
                                // Fallback to "now"
                                nextEntry = { ...nextEntry, timestamp: new Date().toISOString() };
                                mutated = true;
                            }
                        }
                        return nextEntry;
                    });
                    
                    // Don't save during normalization - cleaned data will be saved on next user action
                    return normalizedEntries;
                }
                
                // If Firestore fails, return empty array
                return [];
            } else {
                // User not logged in - read from localStorage as backup
                try {
                    const raw = localStorage.getItem(LOGBOOK_STORAGE_KEY);
                    if (!raw) return [];
                    const parsed = JSON.parse(raw);
                    if (!Array.isArray(parsed)) return [];

                    let mutated = false;
                    const normalizedEntries = parsed.map(entry => {
                        if (!entry || typeof entry !== 'object') return entry;
                        // Normalize date to ISO YYYY-MM-DD
                        const normalizedKey = normalizeDateKey(entry.date);
                        let nextEntry = entry;
                        if (normalizedKey && normalizedKey !== entry.date) {
                            mutated = true;
                            nextEntry = { ...nextEntry, date: normalizedKey };
                        }
                        // Ensure timestamp (ISO 8601). For legacy entries without timestamp, derive from date at local midnight
                        if (!nextEntry.timestamp) {
                            const derived = new Date(`${normalizedKey || entry.date}T00:00:00`);
                            if (!Number.isNaN(derived.getTime())) {
                                nextEntry = { ...nextEntry, timestamp: derived.toISOString() };
                                mutated = true;
                            } else {
                                // Fallback to "now"
                                nextEntry = { ...nextEntry, timestamp: new Date().toISOString() };
                                mutated = true;
                            }
                        }
                        return nextEntry;
                    });

                    if (mutated) {
                        localStorage.setItem(LOGBOOK_STORAGE_KEY, JSON.stringify(normalizedEntries));
                    }
                    
                    return normalizedEntries;
                } catch (error) {
                    console.warn('Kunne ikke læse logbogData:', error);
                    return [];
                }
            }
        }

        async function ensureSeedLogbookData() {
            return await getLogbookData();
        }

        async function saveLogbookData(entries) {
            if (!currentUser || !db) {
                console.error('[SAVE] User not logged in - cannot save data');
                // Still save to localStorage as backup
                try {
                    localStorage.setItem(LOGBOOK_STORAGE_KEY, JSON.stringify(entries));
                } catch (error) {
                    console.error('Kunne ikke gemme logbogData:', error);
                }
                return;
            }
            
            // 🛡️ CRITICAL SAFETY CHECK: Prevent data loss from empty saves
            if (!entries || !Array.isArray(entries) || entries.length === 0) {
                console.error('🚨 CRITICAL: Attempted to save empty or invalid logbookData!');
                console.error('This would DELETE ALL DATA. Save blocked!');
                console.trace(); // Show call stack
                alert('FEJL: Forsøgte at gemme tom data! Dette er blokeret for at beskytte dine data. Reload siden.');
                return;
            }
            
            try {
                await saveLogbookDataToFirestore(entries);
                // Update cache directly without reading from Firestore
                if (window.allUserData) {
                    window.allUserData.logbogData = entries;
                }
                // Also save to localStorage as backup
                try {
                    localStorage.setItem(LOGBOOK_STORAGE_KEY, JSON.stringify(entries));
                } catch (error) {
                    console.warn('Kunne ikke gemme logbogData til localStorage som backup:', error);
                }
            } catch (error) {
                console.error('[SAVE] Error saving to Firestore:', error);
            }
        }

        async function getBodymapData() {
            // Use cached Firestore data when logged in
            if (currentUser && db) {
                const data = await loadAllUserData();
                if (data && data.bodymapData) {
                    return data.bodymapData;
                }
            }
            
            // Fallback to localStorage (for backup or when user not logged in)
            try {
                const raw = localStorage.getItem(BODYMAP_STORAGE_KEY);
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                return parsed && typeof parsed === 'object' ? parsed : null;
            } catch (error) {
                console.warn('Kunne ikke læse bodymapData:', error);
                return null;
            }
        }
        
        async function getDialogData() {
            // Use cached Firestore data when logged in
            if (currentUser && db) {
                const data = await loadAllUserData();
                if (data && data.dialogData) {
                    return data.dialogData;
                }
            }
            
            // Fallback to localStorage (for backup or when user not logged in)
            try {
                const raw = localStorage.getItem(DIALOG_STORAGE_KEY);
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                if (!parsed || typeof parsed !== 'object') return null;
                
                // Check if it's the new structure (has collections)
                if (parsed.collections && Array.isArray(parsed.collections)) {
                    return parsed; // Return new structure
                }
                
                // Legacy structure - return old format for backwards compatibility
                const sessions = Array.isArray(parsed.sessions) ? parsed.sessions : [];
                return { sessions, activeDialogId: parsed.activeDialogId || null };
            } catch (error) {
                console.warn('Kunne ikke læse dialogData:', error);
                return null;
            }
        }
        
        async function getOpstillingData() {
            // Use cached Firestore data when logged in
            if (currentUser && db) {
                const data = await loadAllUserData();
                if (data && data.opstillingData) {
                    return data.opstillingData;
                }
            }
            
            // Fallback to localStorage (for backup or when user not logged in)
            try {
                const raw = localStorage.getItem(OPSTILLING_STORAGE_KEY);
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                return parsed && typeof parsed === 'object' ? parsed : null;
            } catch (error) {
                console.warn('Kunne ikke læse opstillingData:', error);
                return null;
            }
        }
        
        async function getCompareData() {
            // Use cached Firestore data when logged in
            if (currentUser && db) {
                const data = await loadAllUserData();
                if (data && data.compareData) {
                    return data.compareData;
                }
            }
            
            // Fallback to localStorage (for backup or when user not logged in)
            try {
                const raw = localStorage.getItem(COMPARE_STORAGE_KEY);
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                return parsed && typeof parsed === 'object' ? parsed : null;
            } catch (error) {
                console.warn('Kunne ikke læse compareData:', error);
                return null;
            }
        }

        const DANISH_MONTHS = {
            januar: 0,
            februar: 1,
            marts: 2,
            april: 3,
            maj: 4,
            juni: 5,
            juli: 6,
            august: 7,
            september: 8,
            oktober: 9,
            november: 10,
            december: 11
        };

        function parseDanishDateTime(dateStr, timeStr) {
            if (!dateStr) return null;

            const normalizeClock = (d) => {
                if (!timeStr) return d;
                const cleaned = timeStr.replace(/kl\.?/i, '').trim();
                const timeMatch = cleaned.match(/(\d{1,2})[:.](\d{1,2})/);
                if (timeMatch) {
                    d.setHours(parseInt(timeMatch[1], 10), parseInt(timeMatch[2], 10));
                }
                return d;
            };

            const trimmedDate = dateStr.trim();

            // Attempt native Date parsing (handles ISO or locale the engine recognizes)
            const nativeDate = new Date(trimmedDate);
            if (!Number.isNaN(nativeDate.getTime())) {
                return normalizeClock(nativeDate);
            }

            // Numeric formats: 09-11-2024, 09.11.2024, 09/11/2024
            const numericMatch = trimmedDate.match(/(\d{1,2})[.\-/](\d{1,2})[.\-/](\d{2,4})/);
            if (numericMatch) {
                const day = parseInt(numericMatch[1], 10);
                const month = parseInt(numericMatch[2], 10) - 1;
                let year = parseInt(numericMatch[3], 10);
                if (year < 100) {
                    year += year >= 70 ? 1900 : 2000;
                }
                const date = new Date(year, month, day);
                if (!Number.isNaN(date.getTime())) {
                    return normalizeClock(date);
                }
            }

            // Text formats: 9. november 2024, 9 november 2024, 9. nov 2024
            const textMatch = trimmedDate
                .toLowerCase()
                .match(/(\d{1,2})[.\s]*([a-zæøå]+)\s+(\d{4})/i);

            if (textMatch) {
                const day = parseInt(textMatch[1], 10);
                const monthName = textMatch[2].replace(/\.$/, '').toLowerCase();
                const year = parseInt(textMatch[3], 10);

                let monthIndex = DANISH_MONTHS[monthName];
                if (monthIndex === undefined) {
                    // Handle abbreviated month names (e.g., "nov")
                    const matchedKey = Object.keys(DANISH_MONTHS).find(key => key.startsWith(monthName));
                    if (matchedKey) {
                        monthIndex = DANISH_MONTHS[matchedKey];
                    }
                }

                if (monthIndex !== undefined) {
                    const date = new Date(year, monthIndex, day);
                    if (!Number.isNaN(date.getTime())) {
                        return normalizeClock(date);
                    }
                }
            }

            return null;
        }

        function getBodymapEntryDate(entry) {
            if (!entry) return null;
            if (entry.timestamp) {
                const ts = new Date(entry.timestamp);
                if (!Number.isNaN(ts.getTime())) {
                    return ts;
                }
            }
            return parseDanishDateTime(entry.date, entry.time);
        }

        function formatDateKey(date) {
            if (!(date instanceof Date) || Number.isNaN(date.getTime())) return null;
            return getLocalDateKey(date);
        }

        function lightenHex(hex, amount = 0.5) {
            if (!hex) return '#f2e7d2';
            const normalized = hex.replace('#', '');
            const expand = normalized.length === 3
                ? normalized.split('').map(ch => ch + ch).join('')
                : normalized.padEnd(6, '0');
            const r = parseInt(expand.substring(0, 2), 16);
            const g = parseInt(expand.substring(2, 4), 16);
            const b = parseInt(expand.substring(4, 6), 16);
            const clampAmount = Math.max(0, Math.min(1, amount));
            const newR = Math.round(r + (255 - r) * clampAmount);
            const newG = Math.round(g + (255 - g) * clampAmount);
            const newB = Math.round(b + (255 - b) * clampAmount);
            return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
        }

        function darkenHex(hex, amount = 0.1) {
            if (!hex) return '#d4c4a8';
            const normalized = hex.replace('#', '');
            const expand = normalized.length === 3
                ? normalized.split('').map(ch => ch + ch).join('')
                : normalized.padEnd(6, '0');
            const r = parseInt(expand.substring(0, 2), 16);
            const g = parseInt(expand.substring(2, 4), 16);
            const b = parseInt(expand.substring(4, 6), 16);
            const clampAmount = Math.max(0, Math.min(1, amount));
            const newR = Math.round(r * (1 - clampAmount));
            const newG = Math.round(g * (1 - clampAmount));
            const newB = Math.round(b * (1 - clampAmount));
            return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
        }

        function summarizeMapNames(mapNames, mapCount) {
            if (mapNames.length === 1) {
                return mapNames[0];
            }
            if (mapNames.length > 1) {
                return mapNames.join(', ');
            }
            if (mapCount === 1) return '1 map';
            if (mapCount > 1) return `${mapCount} maps`;
            return '';
        }

        async function getBodymapActivityInfo(dateKey, allData) {
            if (!dateKey) {
                return { hasEntries: false };
            }

            const bodymapData = allData && allData.bodymapData ? allData.bodymapData : await getBodymapData();
            if (!bodymapData || !Array.isArray(bodymapData.dataIndexes)) {
                return { hasEntries: false };
            }

            const entriesForDate = [];
            bodymapData.dataIndexes.forEach(index => {
                const entryDate = getBodymapEntryDate(index);
                if (!entryDate) return;
                const normalizedDateKey = formatDateKey(entryDate);
                if (normalizedDateKey === dateKey) {
                    entriesForDate.push({ entry: index, timestamp: entryDate });
                }
            });

            if (!entriesForDate.length) {
                return { hasEntries: false };
            }

            const mapNameById = new Map();
            if (Array.isArray(bodymapData.maps)) {
                bodymapData.maps.forEach(map => {
                    if (map && map.id !== undefined) {
                        mapNameById.set(map.id, map.name || `Map ${map.id}`);
                    }
                });
            }

            // Sort by timestamp and get the latest entry for display
            entriesForDate.sort((a, b) => b.timestamp - a.timestamp);
            const latest = entriesForDate[0];

            // Count unique maps (by mapId) for the day
            const uniqueMapIds = new Set();
            entriesForDate.forEach(wrapper => {
                uniqueMapIds.add(wrapper.entry.mapId);
            });
            const mapCount = uniqueMapIds.size;

            // Get the name of the latest map
            const latestMapId = latest.entry.mapId;
            const mapName = mapNameById.get(latestMapId) || 'BodyMap';
            const latestTime = latest.timestamp.toLocaleTimeString('da-DK', { hour: '2-digit', minute: '2-digit' });

            return {
                hasEntries: true,
                displayText: mapName,
                latestTime,
                mapCount // Show actual count of unique maps
            };
        }

        async function getDialogActivityInfo(dateKey, allData) {
            if (!dateKey) {
                return { hasEntries: false };
            }

            const dialogData = allData && allData.dialogData ? allData.dialogData : await getDialogData();
            if (!dialogData || !Array.isArray(dialogData.dialogs)) {
                return { hasEntries: false };
            }

            const matches = [];
            dialogData.dialogs.forEach(dialog => {
                const source = dialog.timestamp || dialog.updated;
                if (!source) return;
                const timestamp = new Date(source);
                if (Number.isNaN(timestamp.getTime())) return;
                const normalized = formatDateKey(timestamp);
                if (normalized !== dateKey) return;
                matches.push({ dialog, timestamp });
            });

            if (!matches.length) {
                return { hasEntries: false };
            }

            matches.sort((a, b) => b.timestamp - a.timestamp);
            const latest = matches[0];
            const leftParticipant = latest.dialog.participants?.left || {};
            const rightParticipant = latest.dialog.participants?.right || {};
            let leftName = leftParticipant.name || 'Venstre';
            let rightName = rightParticipant.name || 'Højre';
            
            // Truncate names to 10 characters with ".."
            const truncateName = (name) => {
                if (name.length > 10) {
                    return name.substring(0, 10) + '..';
                }
                return name;
            };
            leftName = truncateName(leftName);
            rightName = truncateName(rightName);
            
            const messageCount = Array.isArray(latest.dialog.messages) ? latest.dialog.messages.length : 0;
            const latestTime = latest.timestamp.toLocaleTimeString('da-DK', { hour: '2-digit', minute: '2-digit' });

            const count = matches.length;
            return {
                hasEntries: true,
                displayText: `${leftName} & ${rightName}`,
                latestTime,
                messageCount,
                count
            };
        }

        async function getOpstillingActivityInfo(dateKey, allData) {
            if (!dateKey) {
                return { hasEntries: false };
            }

            const opstillingData = allData && allData.opstillingData ? allData.opstillingData : await getOpstillingData();
            if (!opstillingData || !Array.isArray(opstillingData.setups)) {
                return { hasEntries: false };
            }

            const matches = [];
            opstillingData.setups.forEach(setup => {
                const source = setup.timestamp || setup.updated;
                if (!source) return;
                const timestamp = new Date(source);
                if (Number.isNaN(timestamp.getTime())) return;
                const normalized = formatDateKey(timestamp);
                if (normalized !== dateKey) return;
                matches.push({ setup, timestamp });
            });

            if (!matches.length) {
                return { hasEntries: false };
            }

            // Sort by timestamp and get the latest one only
            matches.sort((a, b) => b.timestamp - a.timestamp);
            const latest = matches[0];
            const setupName = latest.setup.name || 'Opstilling';
            const partsCount = Array.isArray(latest.setup.parts) ? latest.setup.parts.length : 0;
            const latestTime = latest.timestamp.toLocaleTimeString('da-DK', { hour: '2-digit', minute: '2-digit' });

            // Show the latest opstilling name, but count all matches
            const count = matches.length;
            const displayText = `${setupName}`;

            return {
                hasEntries: true,
                displayText,
                latestTime,
                partsCount,
                count // Show actual count of opstillinger on this day
            };
        }

        async function getCompareActivityInfo(dateKey, allData) {
            if (!dateKey) {
                return { hasEntries: false };
            }

            const compareData = allData && allData.compareData ? allData.compareData : await getCompareData();
            if (!compareData || !Array.isArray(compareData.comparisons)) {
                return { hasEntries: false };
            }

            const matches = [];
            compareData.comparisons.forEach(comparison => {
                const source = comparison.timestamp || comparison.updated;
                if (!source) return;
                const timestamp = new Date(source);
                if (Number.isNaN(timestamp.getTime())) return;
                const normalized = formatDateKey(timestamp);
                if (normalized !== dateKey) return;
                matches.push({ comparison, timestamp });
            });

            if (!matches.length) {
                return { hasEntries: false };
            }

            matches.sort((a, b) => b.timestamp - a.timestamp);
            const latest = matches[0];
            const leftParticipant = latest.comparison.leftParticipant || {};
            const rightParticipant = latest.comparison.rightParticipant || {};
            let leftName = leftParticipant.name || 'Venstre';
            let rightName = rightParticipant.name || 'Højre';
            
            // Truncate names to 10 characters with ".."
            const truncateName = (name) => {
                if (name.length > 10) {
                    return name.substring(0, 10) + '..';
                }
                return name;
            };
            leftName = truncateName(leftName);
            rightName = truncateName(rightName);
            
            const latestTime = latest.timestamp.toLocaleTimeString('da-DK', { hour: '2-digit', minute: '2-digit' });

            const count = matches.length;
            const displayText = `${leftName} & ${rightName}`;

            return {
                hasEntries: true,
                displayText,
                latestTime,
                count
            };
        }

        let activeLogDate = getTodayDateKey();

        async function upsertLogbookEntry(dateKey, partial) {
            const entries = await getLogbookData();
            let entry = entries.find(item => item.date === dateKey);
            if (!entry) {
                entry = { date: dateKey, dagbog: '', dreams: '', timestamp: new Date().toISOString() };
                entries.push(entry);
            }

            Object.assign(entry, partial);
            await saveLogbookData(entries);
            return entry;
        }

        async function getSortedLogEntries() {
            const entries = await getLogbookData();

            // Ensure there is always an entry for "i dag" (kun i memory, ingen auto-save)
            try {
                const todayKey = getTodayDateKey();
                const hasToday = entries.some(entry => {
                    if (!entry || typeof entry !== 'object') return false;
                    const normalized = normalizeDateKey(entry.date);
                    return normalized === todayKey;
                });

                if (!hasToday && todayKey) {
                    entries.push({
                        date: todayKey,
                        dagbog: '',
                        dreams: '',
                        timestamp: new Date().toISOString()
                    });
                }
            } catch (e) {
                console.warn('Kunne ikke sikre dagens logbog entry:', e);
            }

            // Ensure all entries have valid dates and filter out any invalid entries
            const validEntries = entries.filter(entry => {
                if (!entry || typeof entry !== 'object') return false;
                const date = entry.date;
                if (!date) return false;
                // Normalize date to ensure it's in correct format
                const normalized = normalizeDateKey(date);
                if (normalized) {
                    entry.date = normalized; // Update to normalized date
                }
                return true;
            });
            
            return validEntries
                .slice()
                .sort((a, b) => {
                    // Use date as primary sort key (YYYY-MM-DD format sorts correctly)
                    const dateA = a.date || '';
                    const dateB = b.date || '';
                    
                    // Compare dates as strings (YYYY-MM-DD sorts correctly lexicographically)
                    if (dateB !== dateA) {
                        return dateB.localeCompare(dateA); // newer first
                    }
                    
                    // If dates are equal, use timestamp as tiebreaker
                    const tb = new Date(b.timestamp || `${b.date}T00:00:00`).getTime();
                    const ta = new Date(a.timestamp || `${a.date}T00:00:00`).getTime();
                    return tb - ta;
                });
        }

        function formatLogHistoryDate(dateStr, options) {
            const parsed = parseDanishDateTime(dateStr) || new Date(`${dateStr}T00:00:00`);
            if (!parsed || Number.isNaN(parsed.getTime())) return dateStr;
            return parsed.toLocaleDateString('da-DK', options).replace(/\./g, '');
        }

        async function renderLogHistory(externalEntries = null) {
            const listEl = document.getElementById('logHistoryList');
            if (!listEl) return;

            const entries = externalEntries !== null ? externalEntries : await getSortedLogEntries();
            listEl.innerHTML = '';

            let activeItemEl = null;

            entries.forEach(entry => {
                const item = document.createElement('div');
                item.className = 'log-history-item';
                // Mark item with its date so color picker can live-update styling without saving
                if (entry.date) {
                    item.dataset.date = entry.date;
                }
                const isActive = entry.date === activeLogDate;
                if (isActive) {
                    item.classList.add('active');
                    activeItemEl = item;
                }

                // Apply color if exists (matching other pages logic)
                const entryColor = entry.color || DEFAULT_HISTORY_COLOR;
                const baseBackground = lightenHex(entryColor, isActive ? 0.35 : 0.7);
                item.style.backgroundColor = baseBackground;
                item.style.borderColor = isActive ? entryColor : 'transparent';

                const headerEl = document.createElement('div');
                headerEl.className = 'log-history-item-header';
                // Set header background to entry color (pill-shape styling)
                headerEl.style.backgroundColor = entryColor;
                headerEl.style.color = '#ffffff';

                const dateLabelEl = document.createElement('div');
                dateLabelEl.className = 'log-history-item-date';
                dateLabelEl.textContent = formatLogHistoryDate(entry.date, { day: '2-digit', month: 'short', year: '2-digit' });
                headerEl.appendChild(dateLabelEl);

                const colorBtn = document.createElement('button');
                colorBtn.className = 'log-history-color-btn';
                colorBtn.textContent = 'C';
                colorBtn.title = 'Vælg farve';
                if (entry.date) {
                    colorBtn.dataset.date = entry.date;
                }
                // Make color button lighter version of entry color
                colorBtn.style.background = lightenHex(entryColor, 0.3);
                colorBtn.style.color = '#ffffff';
                // Color button handlers - both touch and click for mobile compatibility
                const handleColorClick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    openLogHistoryColorPicker(entry.date);
                };
                
                colorBtn.addEventListener('click', handleColorClick);
                colorBtn.addEventListener('touchend', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    handleColorClick(e);
                }, { passive: false });
                headerEl.appendChild(colorBtn);

                const weekDayEl = document.createElement('div');
                weekDayEl.className = 'log-history-item-weekday';
                const parsedWeekdayDate = parseDanishDateTime(entry.date) || new Date(`${entry.date}T00:00:00`);
                let weekdayText = !parsedWeekdayDate || Number.isNaN(parsedWeekdayDate.getTime())
                    ? formatLogHistoryDate(entry.date, { weekday: 'long' })
                    : parsedWeekdayDate.toLocaleDateString('da-DK', { weekday: 'long' });
                
                // Capitalize first letter of weekday
                weekdayText = weekdayText.charAt(0).toUpperCase() + weekdayText.slice(1);
                
                // Add character count to weekday line
                const totalChars = (entry.dagbog || '').length + (entry.dreams || '').length;
                weekDayEl.textContent = `${weekdayText} • ${totalChars} tegn`;

                const snippetEl = document.createElement('div');
                snippetEl.className = 'log-history-item-snippet';
                const snippetSource = (entry.dagbog || entry.dreams || '').trim();
                if (snippetSource.length === 0) {
                    snippetEl.textContent = 'Ingen noter endnu.';
                } else {
                    const shortened = snippetSource.length > 41 ? `${snippetSource.slice(0, 41)}…` : snippetSource;
                    snippetEl.textContent = shortened;
                }

                // Removed bottom meta line with date - no longer needed
                item.append(headerEl, weekDayEl, snippetEl);

                // Shared handler function for both touch and click
                const handleItemActivation = async (e) => {
                    // Check current active state
                    const currentlyActive = entry.date === activeLogDate;
                    
                    // First click/touch: If item is not active, activate it
                    if (!currentlyActive) {
                        e.preventDefault();
                        e.stopPropagation();
                        await setActiveLogDate(entry.date);
                    }
                    // No second click behavior needed - logbog has no editable text field
                };
                
                // Handle touch events for mobile (fires immediately, no delay)
                let touchStartTime = 0;
                item.addEventListener('touchstart', (e) => {
                    touchStartTime = Date.now();
                    // Mark that we're handling touch (stored on item to persist across handlers)
                    item.dataset.touchHandled = 'false';
                }, { passive: true });
                
                item.addEventListener('touchend', (e) => {
                    // Don't handle touches on color button - it has its own handler
                    if (e.target.classList.contains('log-history-color-btn')) {
                        return;
                    }
                    
                    // Only handle if it was a quick tap (not a scroll)
                    const touchDuration = Date.now() - touchStartTime;
                    if (touchDuration < 300) { // Quick tap, not a scroll
                        handleItemActivation(e);
                        // Mark that touch was handled to prevent click event
                        item.dataset.touchHandled = 'true';
                        // Prevent click event from firing after touch
                        e.preventDefault();
                    }
                });
                
                // Handle click events for desktop (only if touch wasn't handled)
                item.addEventListener('click', (e) => {
                    // Check if touch was already handled (on mobile)
                    if (item.dataset.touchHandled !== 'true') {
                        handleItemActivation(e);
                    }
                    // Reset for next interaction
                    item.dataset.touchHandled = 'false';
                });

                listEl.appendChild(item);
            });

            if (activeItemEl) {
                requestAnimationFrame(() => {
                    const listRect = listEl.getBoundingClientRect();
                    const itemRect = activeItemEl.getBoundingClientRect();
                    if (itemRect.top < listRect.top || itemRect.bottom > listRect.bottom) {
                        listEl.scrollTop = activeItemEl.offsetTop - listEl.offsetHeight / 2;
                    }
                });
            }
        }

        async function getTaknemForDate(dateKey) {
            try {
                // Load logbogData from Firestore
                if (!currentUser || !db) {
                    return '';
                }
                
                const logbogData = await getLogbookEntries();
                if (!logbogData || !Array.isArray(logbogData)) {
                    return '';
                }
                
                // dateKey should be in YYYY-MM-DD format
                const dateStr = dateKey || getTodayDateKey();
                
                // Find entry for this date
                const entry = logbogData.find(item => item.date === dateStr);
                
                // Return taknem if it exists and is not empty
                if (entry && entry.taknem && entry.taknem !== '' && entry.taknem !== null && entry.taknem !== undefined) {
                    return entry.taknem;
                }
                
                return '';
            } catch (error) {
                console.warn('[TAKNEM] Kunne ikke læse taknem-værdi:', error);
                return '';
            }
        }

        async function getAffirmForDate(dateKey) {
            try {
                // Load logbogData from Firestore
                if (!currentUser || !db) {
                    return '';
                }
                
                const logbogData = await getLogbookEntries();
                if (!logbogData || !Array.isArray(logbogData)) {
                    return '';
                }
                
                // dateKey should be in YYYY-MM-DD format
                const dateStr = dateKey || getTodayDateKey();
                
                // Find entry for this date
                const entry = logbogData.find(item => item.date === dateStr);
                
                // Return affirm if it exists and is not empty
                if (entry && entry.affirm && entry.affirm !== '' && entry.affirm !== null && entry.affirm !== undefined) {
                    return entry.affirm;
                }
                
                return '';
            } catch (error) {
                console.warn('[AFFIRM] Kunne ikke læse affirm-værdi:', error);
                return '';
            }
        }

        async function setActiveLogDate(dateKey) {
            const normalizedKey = normalizeDateKey(dateKey) || getTodayDateKey();
            activeLogDate = normalizedKey;
            const entries = await getLogbookData();
            let entry = entries.find(item => item.date === activeLogDate);
            if (!entry) {
                entry = { date: getLocalDateKey(), dagbog: '', dreams: '', timestamp: new Date().toISOString() };
                entries.push(entry);
                // Don't save - it's a load operation, entry will be saved when user edits
            }

            const logbookEntryEl = document.getElementById('logbookEntry');
            const dreamEntryEl = document.getElementById('dreamEntry');
            const tankerEntryEl = document.getElementById('tankerEntry');
            
            if (logbookEntryEl) {
                logbookEntryEl.value = entry.dagbog || '';
                autoResizeTextarea(logbookEntryEl);
            }
            if (dreamEntryEl) {
                dreamEntryEl.value = entry.dreams || '';
                autoResizeTextarea(dreamEntryEl);
            }
            if (tankerEntryEl) {
                // Get affirmation text for the selected date (now async)
                const affirmationText = await getAffirmationTextForDate(activeLogDate);
                // Get taknem value for the selected date (now async)
                const taknem = await getTaknemForDate(activeLogDate);
                
                // Combine affirmation text and taknem value
                let combinedText = '';
                if (affirmationText) {
                    combinedText = `Bekræftelse: "${affirmationText}"`;
                }
                if (taknem && taknem.trim()) {
                    if (combinedText) {
                        combinedText += '\n';
                    }
                    // Capitalize first letter of taknem value
                    const taknemValue = taknem.trim();
                    const capitalizedTaknem = taknemValue.charAt(0).toUpperCase() + taknemValue.slice(1);
                    combinedText += `Taknemmelighed : "${capitalizedTaknem}"`;
                }
                
                tankerEntryEl.value = combinedText;
                autoResizeTextarea(tankerEntryEl);
            }

            await renderActivitiesForDate(activeLogDate);
            await renderLogHistory();
            // Scroll chart to show the selected date
            scrollChartToDate(activeLogDate);
        }
        
        function scrollChartToDate(dateKey) {
            const chartWrapper = document.querySelector('.chart-wrapper');
            if (!chartWrapper) return;
            
            const canvas = document.getElementById('checkinChart');
            if (!canvas) return;
            
            // Wait for chart to render, then scroll
            requestAnimationFrame(async () => {
                const rawData = await loadCheckinData();
                const { labels } = processCheckinData(rawData);
                
                // Find the index of the selected date
                let dateIndex = labels.findIndex(label => label === dateKey);
                
                if (dateIndex === -1) {
                    // Date not found - find the closest date and scroll in the right direction
                    const targetDate = new Date(dateKey + 'T00:00:00');
                    if (isNaN(targetDate.getTime())) {
                        // Invalid date, scroll to newest days (right edge)
                        chartWrapper.scrollLeft = chartWrapper.scrollWidth - chartWrapper.clientWidth;
                        return;
                    }
                    
                    // Find closest date
                    let closestIndex = -1;
                    let minDiff = Infinity;
                    labels.forEach((label, idx) => {
                        const labelDate = new Date(label + 'T00:00:00');
                        if (!isNaN(labelDate.getTime())) {
                            const diff = Math.abs(targetDate - labelDate);
                            if (diff < minDiff) {
                                minDiff = diff;
                                closestIndex = idx;
                            }
                        }
                    });
                    
                    if (closestIndex === -1) {
                        // No valid dates found, scroll to newest days
                        chartWrapper.scrollLeft = chartWrapper.scrollWidth - chartWrapper.clientWidth;
                        return;
                    }
                    
                    // Check if we should scroll left (older) or right (newer)
                    const closestDate = new Date(labels[closestIndex] + 'T00:00:00');
                    if (targetDate < closestDate) {
                        // Target is older - scroll to left edge (oldest days)
                        chartWrapper.scrollLeft = 0;
                        return;
                    } else {
                        // Target is newer - scroll to right edge (newest days)
                        chartWrapper.scrollLeft = chartWrapper.scrollWidth - chartWrapper.clientWidth;
                        return;
                    }
                }
                
                // Calculate x position for the date at kl. 12 (midpoint)
                const padding = { left: 0, right: 0 };
                const canvasWidth = parseFloat(canvas.style.width) || canvas.width / (window.devicePixelRatio || 1);
                const chartWidth = canvasWidth - padding.left - padding.right;
                const xMin = 0; // First day starts at index 0 (kl. 00:00)
                const xMax = labels.length > 1 ? labels.length : 1;
                const xRange = xMax - xMin;
                const step = labels.length > 1 ? chartWidth / xRange : chartWidth;
                
                // Position at kl. 12 (dateIndex + 0.5)
                const targetX = padding.left + ((dateIndex + 0.5) - xMin) * step;
                
                // Scroll so the date is at the right edge of the visible area
                const scrollTarget = targetX - chartWrapper.clientWidth + padding.right;
                chartWrapper.scrollLeft = Math.max(0, Math.min(scrollTarget, chartWrapper.scrollWidth - chartWrapper.clientWidth));
            });
        }

        async function updateActiveLogEntry(field, value) {
            let entries = await getLogbookData();
            
            // SAFETY CHECK: If entries is empty but we should have data, try to reload
            if (!entries || entries.length === 0) {
                console.error('⚠️ WARNING: entries array is empty! This could overwrite data.');
                console.log('Attempting to reload data from Firestore...');
                window.allUserData = null; // Clear cache to force reload
                entries = await getLogbookData();
                if (!entries || entries.length === 0) {
                    console.error('❌ Still no data after reload. NOT SAVING to prevent data loss!');
                    alert('FEJL: Kunne ikke indlæse logbog data. Gem ikke for at undgå datatab!');
                    return;
                }
                console.log('✅ Data reloaded successfully, proceeding with save...');
            }
            
            let entry = entries.find(item => item.date === activeLogDate);
            if (!entry) {
                // BUG FIX: Use activeLogDate instead of getLocalDateKey()!
                entry = { date: activeLogDate, dagbog: '', dreams: '', timestamp: new Date().toISOString() };
                entries.push(entry);
            }
            entry[field] = value;
            await saveLogbookData(entries);
            // Pass entries to renderLogHistory to avoid another getLogbookData() call
            const sortedEntries = entries.slice().sort((a, b) => {
                // Use date as primary sort key (YYYY-MM-DD format)
                const dateA = a.date || '';
                const dateB = b.date || '';
                
                // Compare dates as strings (YYYY-MM-DD sorts correctly)
                if (dateB !== dateA) {
                    return dateB.localeCompare(dateA); // newer first
                }
                
                // If dates are equal, use timestamp as tiebreaker
                const tb = new Date(b.timestamp || `${b.date}T00:00:00`).getTime();
                const ta = new Date(a.timestamp || `${a.date}T00:00:00`).getTime();
                return tb - ta;
            });
            await renderLogHistory(sortedEntries);
        }

        async function refreshActiveLogEntry(externalEntries) {
            const logbookEntryEl = document.getElementById('logbookEntry');
            const dreamEntryEl = document.getElementById('dreamEntry');
            if (!logbookEntryEl || !dreamEntryEl) return;

            const entries = Array.isArray(externalEntries) ? externalEntries : await getLogbookData();
            const entry = entries.find(item => item.date === activeLogDate);
            if (!entry) return;

            if (document.activeElement !== logbookEntryEl) {
                logbookEntryEl.value = entry.dagbog || '';
                autoResizeTextarea(logbookEntryEl);
            }
            if (document.activeElement !== dreamEntryEl) {
                dreamEntryEl.value = entry.dreams || '';
                autoResizeTextarea(dreamEntryEl);
            }
        }

        async function handleLogbookStorageEvent(event) {
            // Firestore doesn't use storage events - data syncs via auth state changes
            // This function is kept for localStorage backup compatibility only
            if (event.key !== LOGBOOK_STORAGE_KEY) return;
            
            // Only handle if user is not logged in (using localStorage as primary)
            if (!currentUser || !db) {
                await refreshActiveLogEntry();
                await renderLogHistory();
            }
        }

        async function handleBodymapStorageEvent(event) {
            if (event.key && event.key !== BODYMAP_STORAGE_KEY) return;
            await renderActivitiesForDate(activeLogDate);
        }

        async function handleOpstillingStorageEvent(event) {
            if (event.key && event.key !== OPSTILLING_STORAGE_KEY) return;
            await renderActivitiesForDate(activeLogDate);
        }

        async function handleCompareStorageEvent(event) {
            if (event.key && event.key !== COMPARE_STORAGE_KEY) return;
            await renderActivitiesForDate(activeLogDate);
        }

        function toggleLogHistorySidebar() {
            const sidebar = document.getElementById('logHistorySidebar');
            if (!sidebar) return;

            const collapsed = sidebar.classList.toggle('collapsed');
            try {
                localStorage.setItem(LOG_HISTORY_COLLAPSED_KEY, String(collapsed));
            } catch (error) {
                console.warn('Kunne ikke gemme historiktilstand:', error);
            }
        }

        function buildLogHistoryColorGrid() {
            const gridEl = document.getElementById('logHistoryColorGrid');
            if (!gridEl) return;
            gridEl.innerHTML = '';
            LOG_HISTORY_COLOR_PRESETS.forEach(color => {
                const swatch = document.createElement('button');
                swatch.className = 'log-history-color-swatch';
                swatch.style.background = color;
                swatch.onclick = () => handleLogHistoryColorSelected(color);
                gridEl.appendChild(swatch);
            });
        }

        function openLogHistoryColorPicker(dateKey) {
            const modal = document.getElementById('logHistoryColorPickerModal');
            if (!modal) return;
            logHistoryColorPickerTarget = dateKey;
            buildLogHistoryColorGrid();
            modal.classList.add('show');
        }

        async function closeLogHistoryColorPicker() {
            // Save any pending color changes when picker closes
            if (window._pendingLogHistoryColorChanges && window._pendingLogHistoryColorChanges.size > 0) {
                const entries = await getLogbookData();
                let hasChanges = false;
                window._pendingLogHistoryColorChanges.forEach((color, dateKey) => {
                    const entry = entries.find(e => e.date === dateKey);
                    if (entry) {
                        if (color === null) {
                            delete entry.color;
                        } else {
                            entry.color = color;
                        }
                        hasChanges = true;
                    }
                });
                if (hasChanges) {
                    await saveLogbookData(entries);
                    const sortedEntries = entries.slice().sort((a, b) => {
                        // Use date as primary sort key (YYYY-MM-DD format)
                        const dateA = a.date || '';
                        const dateB = b.date || '';
                        
                        // Compare dates as strings (YYYY-MM-DD sorts correctly)
                        if (dateB !== dateA) {
                            return dateB.localeCompare(dateA); // newer first
                        }
                        
                        // If dates are equal, use timestamp as tiebreaker
                        const tb = new Date(b.timestamp || `${b.date}T00:00:00`).getTime();
                        const ta = new Date(a.timestamp || `${a.date}T00:00:00`).getTime();
                        return tb - ta;
                    });
                    await renderLogHistory(sortedEntries);
                }
                window._pendingLogHistoryColorChanges.clear();
            }
            logHistoryColorPickerTarget = null;
            const modal = document.getElementById('logHistoryColorPickerModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }

        function handleLogHistoryColorSelected(color) {
            if (!logHistoryColorPickerTarget) return;
            // Store color change - will be saved when picker closes
            if (!window._pendingLogHistoryColorChanges) {
                window._pendingLogHistoryColorChanges = new Map();
            }
            window._pendingLogHistoryColorChanges.set(logHistoryColorPickerTarget, color);
            
            // Live-update UI for the selected history item without saving to Firestore yet
            const item = document.querySelector(`.log-history-item[data-date="${logHistoryColorPickerTarget}"]`);
            if (item) {
                const isActive = item.classList.contains('active');
                const baseBackground = lightenHex(color, isActive ? 0.35 : 0.7);
                item.style.backgroundColor = baseBackground;
                item.style.borderColor = isActive ? color : 'transparent';
                
                // Update header background color
                const headerEl = item.querySelector('.log-history-item-header');
                if (headerEl) {
                    headerEl.style.backgroundColor = color;
                    headerEl.style.color = '#ffffff';
                }
            }
            const colorBtn = document.querySelector(`.log-history-color-btn[data-date="${logHistoryColorPickerTarget}"]`);
            if (colorBtn) {
                colorBtn.style.background = lightenHex(color, 0.3);
                colorBtn.style.color = '#ffffff';
            }
            // Don't close overlay - only close when clicking outside or pressing Escape
        }

        function removeLogHistoryColor() {
            if (!logHistoryColorPickerTarget) return;
            // Store color removal - will be saved when picker closes
            if (!window._pendingLogHistoryColorChanges) {
                window._pendingLogHistoryColorChanges = new Map();
            }
            window._pendingLogHistoryColorChanges.set(logHistoryColorPickerTarget, null);
            
            // Live-update UI for the selected history item (remove color) without saving endnu
            const item = document.querySelector(`.log-history-item[data-date="${logHistoryColorPickerTarget}"]`);
            if (item) {
                const isActive = item.classList.contains('active');
                const baseBackground = lightenHex(DEFAULT_HISTORY_COLOR, isActive ? 0.35 : 0.7);
                item.style.backgroundColor = baseBackground;
                item.style.borderColor = isActive ? DEFAULT_HISTORY_COLOR : 'transparent';
                
                // Update header background color to default
                const headerEl = item.querySelector('.log-history-item-header');
                if (headerEl) {
                    headerEl.style.backgroundColor = DEFAULT_HISTORY_COLOR;
                    headerEl.style.color = '#ffffff';
                }
            }
            const colorBtn = document.querySelector(`.log-history-color-btn[data-date="${logHistoryColorPickerTarget}"]`);
            if (colorBtn) {
                colorBtn.style.background = lightenHex(DEFAULT_HISTORY_COLOR, 0.3);
                colorBtn.style.color = '#ffffff';
            }
            // Don't close overlay - only close when clicking outside or pressing Escape
        }

        // Store handlers to prevent listener accumulation
        let logbookInputHandler = null;
        let dreamInputHandler = null;
        let logbookDebounceTimeout = null;
        let dreamDebounceTimeout = null;

        function autoResizeTextarea(textarea) {
            if (!textarea) return;
            textarea.style.height = 'auto';
            const scrollHeight = textarea.scrollHeight;
            const maxHeight = 450; // max-height in pixels
            if (scrollHeight <= maxHeight) {
                textarea.style.height = scrollHeight + 'px';
                textarea.style.overflowY = 'hidden';
            } else {
                textarea.style.height = maxHeight + 'px';
                textarea.style.overflowY = 'auto';
            }
        }

        async function hydrateLogbookFields() {
            const logbookEntryEl = document.getElementById('logbookEntry');
            const dreamEntryEl = document.getElementById('dreamEntry');
            if (!logbookEntryEl || !dreamEntryEl) return;

            // Remove old listeners if they exist
            if (logbookInputHandler) {
                logbookEntryEl.removeEventListener('input', logbookInputHandler);
            }
            if (dreamInputHandler) {
                dreamEntryEl.removeEventListener('input', dreamInputHandler);
            }
            
            // Clear existing debounce timeouts
            if (logbookDebounceTimeout) {
                clearTimeout(logbookDebounceTimeout);
                logbookDebounceTimeout = null;
            }
            if (dreamDebounceTimeout) {
                clearTimeout(dreamDebounceTimeout);
                dreamDebounceTimeout = null;
            }
            
            // Create new handlers with debounce (3 seconds)
            logbookInputHandler = () => {
                autoResizeTextarea(logbookEntryEl);
                
                // Clear previous timeout
                if (logbookDebounceTimeout) {
                    clearTimeout(logbookDebounceTimeout);
                }
                
                // Debounce: wait 3 seconds after last input
                logbookDebounceTimeout = setTimeout(async () => {
                    await updateActiveLogEntry('dagbog', logbookEntryEl.value);
                    logbookDebounceTimeout = null;
                }, 3000);
            };
            
            dreamInputHandler = () => {
                autoResizeTextarea(dreamEntryEl);
                
                // Clear previous timeout
                if (dreamDebounceTimeout) {
                    clearTimeout(dreamDebounceTimeout);
                }
                
                // Debounce: wait 3 seconds after last input
                dreamDebounceTimeout = setTimeout(async () => {
                    await updateActiveLogEntry('dreams', dreamEntryEl.value);
                    dreamDebounceTimeout = null;
                }, 3000);
            };

            // Add new listeners
            logbookEntryEl.addEventListener('input', logbookInputHandler);
            dreamEntryEl.addEventListener('input', dreamInputHandler);

            // Auto-resize on load
            autoResizeTextarea(logbookEntryEl);
            autoResizeTextarea(dreamEntryEl);

            await setActiveLogDate(activeLogDate);
        }

        const navBox = document.getElementById('navBox');
        const navOverlay = document.getElementById('navOverlay');
        const navControls = document.querySelector('.nav-controls');

        function openNavMenu() {
            if (navBox) {
                navBox.classList.add('show');
            }
            if (navOverlay) {
                navOverlay.classList.add('show');
            }
        }

        function closeNavMenu() {
            if (navBox) {
                navBox.classList.remove('show');
            }
            if (navOverlay) {
                navOverlay.classList.remove('show');
            }
        }

        function toggleNavBox(event) {
            if (event) {
                event.stopPropagation();
            }
            if (!navBox) {
                return;
            }
            if (navBox.classList.contains('show')) {
                closeNavMenu();
            } else {
                openNavMenu();
            }
        }

        if (navOverlay) {
            navOverlay.addEventListener('click', closeNavMenu);
        }

        document.addEventListener('click', (event) => {
            if (!navBox || !navBox.classList.contains('show')) {
                return;
            }
            if (navControls && navControls.contains(event.target)) {
                return;
            }
            closeNavMenu();
        });

        function formatDanishDate(date) {
            return date.toLocaleDateString('da-DK', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
        }

        const CLOCK_ICON_SVG = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>';

        let renderingActivities = false;
        async function renderActivitiesForDate(dateKey) {
            // Guard: Skip render during initial load (wait for all data to be loaded first)
            if (!initialActivityRenderDone) {
                return;
            }
            
            // Prevent multiple simultaneous renders
            if (renderingActivities) return;
            renderingActivities = true;
            
            const normalizedKey = normalizeDateKey(dateKey) || getTodayDateKey();
            
            // Update activity date label
            const activityLabel = document.getElementById('activityDateLabel');
            if (activityLabel && normalizedKey) {
                try {
                    const [year, month, day] = normalizedKey.split('-');
                    const date = new Date(year, month - 1, day);
                    activityLabel.textContent = date.toLocaleDateString('da-DK');
                } catch (e) {
                    activityLabel.textContent = normalizedKey;
                }
            }
            
            const grid = document.getElementById('activitiesGrid');
            if (!grid) {
                renderingActivities = false;
                return;
            }

            // Always render exactly 4 activities (opstilling, dialog, relationer, bodymap)
            // The content changes based on whether there's data for the selected date
            if (!mockActivities || mockActivities.length < 4) {
                console.error('mockActivities must contain exactly 4 activities');
                renderingActivities = false;
                return;
            }

            // Get or create the 4 activity links (one of each type)
            // First, ensure we only have exactly 4 links (remove any extras or duplicates)
            const allLinks = Array.from(grid.querySelectorAll('.activity-link[data-activity-type]'));
            const linksByType = {};
            const expectedTypes = new Set(mockActivities.map(a => a.type));
            const seenTypes = new Set();
            
            // Remove duplicates and invalid links
            allLinks.forEach(link => {
                const type = link.getAttribute('data-activity-type');
                if (type && expectedTypes.has(type)) {
                    // If we've already seen this type, remove the duplicate
                    if (seenTypes.has(type)) {
                        link.remove();
                        return;
                    }
                    seenTypes.add(type);
                    linksByType[type] = link;
                } else {
                    // Remove link if type is invalid or not in expected types
                    link.remove();
                }
            });

            // Process activities sequentially to handle async data loading
            // Collect all link updates and apply them all at once
            const linkUpdates = new Map();
            
            for (const activity of mockActivities) {
                const styleConfig = activityStyles[activity.type] || activityStyles.default;
                const accentColor = styleConfig.accent || '#475569';

                // Find existing link or create new one
                let link = linksByType[activity.type];
                let tile;
                
                if (link && grid.contains(link)) {
                    // Use existing link - find existing tile (never create new tile)
                    tile = link.querySelector('.activity-tile');
                    if (!tile) {
                        // Only create tile if it truly doesn't exist (shouldn't happen normally)
                        tile = document.createElement('article');
                        tile.className = 'activity-tile';
                        link.appendChild(tile);
                    }
                } else {
                    // Create new link only if it doesn't exist
                    link = document.createElement('a');
                    link.className = 'activity-link';
                    link.setAttribute('data-activity-type', activity.type);
                    link.href = styleConfig.url || '#';

                    tile = document.createElement('article');
                    tile.className = 'activity-tile';
                    link.appendChild(tile);
                    grid.appendChild(link);
                    linksByType[activity.type] = link; // Store for next iteration
                }

                // Store link href update to apply all at once later
                linkUpdates.set(link, styleConfig.url || '#');

                // Only clear tile content (never remove/recreate the tile element itself)
                tile.innerHTML = '';
                tile.className = 'activity-tile';
                tile.style.background = styleConfig.gradient;
                tile.style.color = '#ffffff';
                tile.style.border = 'none';
                tile.classList.remove('empty');

                const labelEl = document.createElement('div');
                labelEl.className = 'activity-label';
                labelEl.textContent = activity.label || activity.type;

                let isEmptyState = false;
                let emptyTextLabel = 'Ingen aktivitet';
                let badgeText = '';

                if (activity.type === 'bodymap') {
                    const info = await getBodymapActivityInfo(normalizedKey, window.allUserData || null);
                    if (info.hasEntries) {
                        const mapLabel = info.mapCount === 1 ? '1 map' : `${info.mapCount} maps`;
                        badgeText = mapLabel;
                    } else {
                        isEmptyState = true;
                        emptyTextLabel = 'Lav et map';
                    }
                } else if (activity.type === 'dialog') {
                    const info = await getDialogActivityInfo(normalizedKey, window.allUserData || null);
                    if (info.hasEntries) {
                        const dialogLabel = info.count === 1 ? '1 dialog' : `${info.count} dialoger`;
                        badgeText = dialogLabel;
                    } else {
                        isEmptyState = true;
                        emptyTextLabel = 'Lav en dialog';
                    }
                } else if (activity.type === 'opstilling') {
                    const info = await getOpstillingActivityInfo(normalizedKey, window.allUserData || null);
                    if (info.hasEntries) {
                        const opstillingLabel = info.count === 1 ? '1 opstilling' : `${info.count} opstillinger`;
                        badgeText = opstillingLabel;
                    } else {
                        isEmptyState = true;
                        emptyTextLabel = 'Lav en opstilling';
                    }
                } else if (activity.type === 'relationer') {
                    const info = await getCompareActivityInfo(normalizedKey, window.allUserData || null);
                    if (info.hasEntries) {
                        const compareLabel = info.count === 1 ? '1 sammenligning' : `${info.count} sammenligninger`;
                        badgeText = compareLabel;
                    } else {
                        isEmptyState = true;
                        emptyTextLabel = 'Find ligheder';
                    }
                }

                if (isEmptyState) {
                    tile.classList.add('empty');
                    tile.style.background = '#ffffff';
                    tile.style.backgroundImage = 'none';
                    tile.style.color = accentColor;
                    tile.style.border = `3px dashed ${accentColor}`;
                    tile.style.boxShadow = 'none';

                    // Left side: content wrapper with label and text
                    const contentWrapper = document.createElement('div');
                    contentWrapper.className = 'activity-content';

                    const emptyTextEl = document.createElement('div');
                    emptyTextEl.className = 'activity-empty-text';
                    emptyTextEl.textContent = emptyTextLabel;

                    contentWrapper.append(labelEl, emptyTextEl);

                    // Right side: circle with cross icon
                    const emptyCircle = document.createElement('div');
                    emptyCircle.className = 'activity-empty-circle';

                    const emptyIcon = document.createElement('div');
                    emptyIcon.className = 'activity-empty-icon';

                    emptyCircle.appendChild(emptyIcon);

                    tile.append(contentWrapper, emptyCircle);
                } else {
                    tile.append(labelEl);
                    if (badgeText) {
                        const badgeEl = document.createElement('div');
                        badgeEl.className = 'activity-meta';
                        if (activity.type === 'relationer') {
                            badgeEl.innerHTML = badgeText;
                        } else {
                            badgeEl.textContent = badgeText;
                        }
                        tile.appendChild(badgeEl);
                    }
                }
            }
            
            // Update all link hrefs at once after all activities are processed
            linkUpdates.forEach((url, link) => {
                link.href = url;
            });
            
            renderingActivities = false;
        }

        let checkinDetailedView = false; // Default to simple view
        let checkinDaysView = 5; // Default to 5 days

        // Temporary debug data storage (doesn't overwrite localStorage)
        let debugCheckinData = null;

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCl6ZYtkfYx3kFF9329eGpeazsmJAPMKzA",
            authDomain: "relationer-fe5fe.firebaseapp.com",
            projectId: "relationer-fe5fe",
            storageBucket: "relationer-fe5fe.firebasestorage.app",
            messagingSenderId: "156720560629",
            appId: "1:156720560629:web:1a138e4e89f02a131f88bc",
            measurementId: "G-K5W7J8JHZG"
        };
        
        // Initialize Firebase
        let auth = null;
        let db = null;
        let currentUser = null;
        
        // Global cache of all user-related Firestore data (shared via window)
        // {
        //   bodymapData,
        //   dialogData,
        //   opstillingData,
        //   compareData,
        //   logbogData
        // }
        // NOTE: forside_checkin_data is deprecated - now using logbogData.checkins
        window.allUserData = window.allUserData || null;
        window.allDataLoadingPromise = window.allDataLoadingPromise || null;
        
        // Flags for race condition protection
        let initialActivityRenderDone = false;
        
        try {
            firebase.initializeApp(firebaseConfig);
            auth = firebase.auth();
            db = firebase.firestore();
        } catch (error) {
            console.error('Firebase initialization error:', error);
        }
        
        // Check auth state - create a promise that resolves when auth state is determined
        let authStateReady = false;
        let authStateResolver = null;
        const authStatePromise = new Promise(resolve => {
            authStateResolver = resolve;
        });
        
        if (auth) {
            auth.onAuthStateChanged(async user => {
                currentUser = user;
                
                // Mark auth as ready and resolve promise
                if (!authStateReady) {
                    authStateReady = true;
                    if (authStateResolver) {
                        authStateResolver();
                        authStateResolver = null;
                    }
                }
                
                // When user logs in, reload data
                if (user) {
                    await setActiveLogDate(activeLogDate);
                    await renderLogHistory();
                    // Update tanker field
                    const tankerEntryEl = document.getElementById('tankerEntry');
                    if (tankerEntryEl) {
                        const affirmationText = await getAffirmationTextForDate(activeLogDate);
                        const taknem = await getTaknemForDate(activeLogDate);
                        let combinedText = '';
                        if (affirmationText) {
                            combinedText = `Bekræftelse: "${affirmationText}"`;
                        }
                        if (taknem && taknem.trim()) {
                            if (combinedText) combinedText += '\n';
                            // Capitalize first letter of taknem value
                            const taknemValue = taknem.trim();
                            const capitalizedTaknem = taknemValue.charAt(0).toUpperCase() + taknemValue.slice(1);
                            combinedText += `Taknemmelighed : "${capitalizedTaknem}"`;
                        }
                        tankerEntryEl.value = combinedText;
                        autoResizeTextarea(tankerEntryEl);
                    }
                    // Reload check-in chart if needed
                    if (typeof renderCheckinChart === 'function') {
                        await loadCheckinData();
                        renderCheckinChart();
                    }
                }
            });
        }
        
        // DEPRECATED: Old functions kept for reference but no longer used
        // Check-in data is now stored in logbogData.checkins arrays
        // Use saveLogbookDataToFirestore and getLogbookEntries instead
        
        // Load bodymap data from Firestore via cached user document
        async function loadBodymapDataFromFirestore() {
            if (!currentUser || !db) return null;
            
            try {
                const data = await loadAllUserData();
                return data ? data.bodymapData || null : null;
            } catch (error) {
                console.error('Error loading bodymapData from Firestore:', error);
                return null;
            }
        }
        
        // Load opstilling data from Firestore via cached user document
        async function loadOpstillingDataFromFirestore() {
            if (!currentUser || !db) return null;
            
            try {
                const data = await loadAllUserData();
                return data ? data.opstillingData || null : null;
            } catch (error) {
                console.error('Error loading opstillingData from Firestore:', error);
                return null;
            }
        }
        
        // Load dialog data from Firestore via cached user document
        async function loadDialogDataFromFirestore() {
            if (!currentUser || !db) return null;
            
            try {
                const data = await loadAllUserData();
                return data ? data.dialogData || null : null;
            } catch (error) {
                console.error('Error loading dialogData from Firestore:', error);
                return null;
            }
        }
        
        // Load compare data from Firestore via cached user document
        async function loadCompareDataFromFirestore() {
            if (!currentUser || !db) return null;
            
            try {
                const data = await loadAllUserData();
                return data ? data.compareData || null : null;
            } catch (error) {
                console.error('Error loading compareData from Firestore:', error);
                return null;
            }
        }

        async function loadCheckinData() {
            try {
                // If debug data is loaded, use it instead of Firestore
                if (debugCheckinData !== null) {
                    return processCheckinDataForDisplay(debugCheckinData);
                }

                // Always load from Firestore if user is logged in
                if (currentUser && db) {
                    const logbogData = await getLogbookEntries();
                    if (logbogData !== null && Array.isArray(logbogData)) {
                        return processLogbogDataForCheckins(logbogData);
                    }
                    // If Firestore fails, return empty array
                    return [];
                }

                // User not logged in - return empty array
                return [];
            } catch (error) {
                console.error('[CHECKIN] Fejl ved indlæsning af check-in data:', error);
                return [];
            }
        }
        
        // Helper function to extract check-ins from logbogData for display
        function processLogbogDataForCheckins(logbogData) {
            if (!Array.isArray(logbogData)) {
                return [];
            }
            
            const allCheckins = [];
            
            // Extract all check-ins from all entries
            logbogData.forEach(entry => {
                if (!entry.date || !Array.isArray(entry.checkins)) {
                    return;
                }
                
                entry.checkins.forEach(checkin => {
                    if (typeof checkin.status !== 'number') {
                        return;
                    }
                    
                    // Create a Date object from the date key and time
                    // dateKey is YYYY-MM-DD, time is HH:MM
                    let dateObj;
                    if (checkin.time && typeof checkin.time === 'string') {
                        // Parse time string (HH:MM)
                        const [hours, minutes] = checkin.time.split(':').map(s => parseInt(s, 10));
                        if (!isNaN(hours) && !isNaN(minutes)) {
                            dateObj = new Date(entry.date + 'T' + checkin.time + ':00');
                        } else {
                            // Fallback if time parsing fails
                            dateObj = new Date(entry.date + 'T12:00:00');
                        }
                    } else {
                        // No time available, default to noon
                        dateObj = new Date(entry.date + 'T12:00:00');
                    }
                    
                    allCheckins.push({
                        date: dateObj,
                        status: Math.max(0, Math.min(100, Number(checkin.status))),
                        dateKey: entry.date,
                        time: checkin.time || '12:00'
                    });
                });
            });
            
            // Sort by date (oldest first)
            return allCheckins.sort((a, b) => a.date - b.date);
        }
        
        // Helper function to process check-in data for display (LEGACY - for debug data)
        function processCheckinDataForDisplay(parsed) {
                if (!Array.isArray(parsed)) {
                    return [];
                }
                return parsed
                    .filter(entry => typeof entry.status === 'number')
                    .map(entry => {
                        const dateObj = entry.date ? new Date(entry.date) : new Date();
                        return {
                            date: dateObj,
                            status: Math.max(0, Math.min(100, Number(entry.status))),
                            dateKey: dateObj.toISOString().split('T')[0],
                            time: dateObj.toLocaleTimeString('da-DK', { hour: '2-digit', minute: '2-digit', hour12: false })
                        };
                    })
                    .sort((a, b) => a.date - b.date);
        }

        function processCheckinData(data) {
            if (!data || !Array.isArray(data) || data.length === 0) {
                return { data: [], labels: [], totalDays: 0 };
            }

            // Group by date
            const groupedByDate = data.reduce((acc, entry) => {
                if (!entry || !entry.dateKey) return acc;
                if (!acc[entry.dateKey]) {
                    acc[entry.dateKey] = [];
                }
                acc[entry.dateKey].push(entry);
                return acc;
            }, {});

            // Get unique dates with data, sorted (oldest first for display)
            // Always use ALL days - no filtering
            const allUniqueDates = Object.keys(groupedByDate).sort();

            if (checkinDetailedView) {
                // Detailed view: show all entries with horizontal offset
                const processedData = [];
                // Process ALL days, not just the visible ones
                allUniqueDates.forEach((dateKey, dateIndex) => {
                    const dayEntries = groupedByDate[dateKey];
                    const isMorning = (timeStr) => {
                        const hour = parseInt(timeStr.split(':')[0]);
                        return hour < 12;
                    };

                    if (dayEntries.length === 1) {
                        // Single entry: use precise time position
                        let timeOffset = 0.5; // Default to noon if time parsing fails
                        if (dayEntries[0].time && typeof dayEntries[0].time === 'string') {
                            // Handle both ':' and '.' as separators
                            const timeParts = dayEntries[0].time.split(/[:.]/);
                            if (timeParts.length >= 2) {
                                const hours = parseInt(timeParts[0], 10);
                                const minutes = parseInt(timeParts[1], 10);
                                if (!isNaN(hours) && !isNaN(minutes)) {
                                    const timeInHours = hours + minutes / 60;
                                    timeOffset = timeInHours / 24;
                                }
                            }
                        }
                        processedData.push({
                            x: dateIndex + timeOffset,
                            y: dayEntries[0].status,
                            date: dateKey,
                            time: dayEntries[0].time,
                            size: 100,
                            originalDate: dayEntries[0].date
                        });
                    } else {
                        // Multiple entries: use precise time position for each
                        dayEntries.forEach((entry, idx) => {
                            let timeOffset = 0.5; // Default to noon if time parsing fails
                            if (entry.time && typeof entry.time === 'string') {
                                // Handle both ':' and '.' as separators
                                const timeParts = entry.time.split(/[:.]/);
                                if (timeParts.length >= 2) {
                                    const hours = parseInt(timeParts[0], 10);
                                    const minutes = parseInt(timeParts[1], 10);
                                    if (!isNaN(hours) && !isNaN(minutes)) {
                                        const timeInHours = hours + minutes / 60;
                                        timeOffset = timeInHours / 24;
                                    }
                                }
                            }
                            
                            processedData.push({
                                x: dateIndex + timeOffset,
                                y: entry.status,
                                date: dateKey,
                                time: entry.time,
                                size: 80,
                                originalDate: entry.date
                            });
                        });
                    }
                });
                return { data: processedData, labels: allUniqueDates, totalDays: allUniqueDates.length };
            } else {
                // Simple view: average per day, positioned at noon (kl. 12)
                // Process ALL days, not just the visible ones
                const processedData = allUniqueDates.map((dateKey, dateIndex) => {
                    const dayEntries = groupedByDate[dateKey];
                    const avgStatus = dayEntries.reduce((sum, e) => sum + e.status, 0) / dayEntries.length;
                    return {
                        x: dateIndex + 0.5, // Position at noon (kl. 12)
                        y: Math.round(avgStatus),
                        date: dateKey,
                        count: dayEntries.length,
                        size: 100,
                        originalDate: dayEntries[0].date
                    };
                });
                return { data: processedData, labels: allUniqueDates, totalDays: allUniqueDates.length };
            }
        }

        async function renderCheckinChart() {
            const canvas = document.getElementById('checkinChart');
            if (!canvas) return;
            const tooltip = document.getElementById('checkinTooltip');
            const ctx = canvas.getContext('2d');
            const rawData = await loadCheckinData();
            const { data, labels, totalDays } = processCheckinData(rawData);
            const parent = canvas.parentElement;

            const dpr = window.devicePixelRatio || 1;
            const height = 240;
            
            // Get parent width (chart-wrapper) - canvas should fill it completely
            const baseWidth = parent.clientWidth || parent.offsetWidth;
            
            // Calculate canvas width: if we have more than checkinDaysView days, make it wider for scrolling
            // Use totalDays (all available data) instead of labels.length (filtered data) for width calculation
            const width = totalDays > checkinDaysView 
                ? baseWidth * (totalDays / checkinDaysView)
                : baseWidth;

            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;

            // Auto-scroll to show active date if canvas is wider than parent
            if (width > baseWidth) {
                requestAnimationFrame(() => {
                    // Scroll to active date if it exists, otherwise scroll to newest days
                    scrollChartToDate(activeLogDate);
                });
            }

            ctx.scale(dpr, dpr);
            ctx.clearRect(0, 0, width, height);

            const padding = { top: 0, right: 0, bottom: 0, left: 0 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            ctx.save();
            ctx.beginPath();
            ctx.rect(0, 0, width, height);
            ctx.clip();
            ctx.fillStyle = '#FCE68A';
            ctx.fillRect(0, 0, width, height / 2);
            ctx.fillStyle = '#BAE6FD';
            ctx.fillRect(0, height / 2, width, height / 2);
            ctx.restore();

            if (!data.length) {
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#94a3b8';
                ctx.font = '16px Arial';
                ctx.fillText('Ingen check-ins endnu', width / 2, height / 2);
                return;
            }

            // Calculate average as: average of all days' averages
            // Group raw data by date
            const groupedByDate = rawData.reduce((acc, entry) => {
                if (!entry || !entry.dateKey) return acc;
                if (!acc[entry.dateKey]) {
                    acc[entry.dateKey] = [];
                }
                acc[entry.dateKey].push(entry);
                return acc;
            }, {});
            
            // Calculate average per day, then average of those
            const dayAverages = Object.values(groupedByDate).map(dayEntries => {
                return dayEntries.reduce((sum, e) => sum + e.status, 0) / dayEntries.length;
            });
            const average = dayAverages.length > 0 
                ? dayAverages.reduce((sum, avg) => sum + avg, 0) / dayAverages.length 
                : 0;
            const yAverage = padding.top + chartHeight - (average / 100) * chartHeight;

            // Average zone
            const zoneThickness = 25;
            const topZone = Math.max(padding.top, yAverage - zoneThickness);
            const bottomZone = Math.min(padding.top + chartHeight, yAverage + zoneThickness);

            ctx.fillStyle = '#10b981';
            ctx.beginPath();
            ctx.rect(0, topZone, width, bottomZone - topZone);
            ctx.fill();

            ctx.strokeStyle = '#34d399';
            ctx.lineWidth = 3;
            ctx.setLineDash([6, 6]);
            ctx.beginPath();
            ctx.moveTo(0, yAverage);
            ctx.lineTo(width, yAverage);
            ctx.stroke();
            ctx.setLineDash([]);

            // Sort data by x for line drawing
            const sortedData = data.slice().sort((a, b) => a.x - b.x);

            // No padding - chart starts at kl. 00:00 of first day and ends at kl. 24:00 of last day
            const xMin = 0; // First day starts at index 0 (kl. 00:00)
            // Last day index is (labels.length - 1), kl. 24:00 is at (labels.length - 1) + 1.0 = labels.length
            const xMax = labels.length;
            const xRange = xMax - xMin;
            
            // Draw line connecting points
            const step = chartWidth / xRange;
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 3.5;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.beginPath();

            if (sortedData.length === 0) {
                // No data, don't draw line
            } else if (sortedData.length === 1) {
                // Single point: draw horizontal line from first day's kl. 00:00 to end of last day (kl. 24:00)
                const point = sortedData[0];
                const x = padding.left + (point.x - xMin) * step;
                const y = padding.top + chartHeight - (point.y / 100) * chartHeight;
                const firstDayStartX = padding.left + (0 - xMin) * step; // kl. 00:00 of first day
                // Use the actual last day index from all labels (all available data)
                const lastDayIndex = labels.length - 1;
                const lastDayEndX = padding.left + ((lastDayIndex + 1.0) - xMin) * step;
                ctx.moveTo(firstDayStartX, y);
                ctx.lineTo(lastDayEndX, y);
            } else {
                // Multiple points: horizontal line to first, connect all, horizontal line from last
                const firstPoint = sortedData[0];
                const lastPoint = sortedData[sortedData.length - 1];
                const firstX = padding.left + (firstPoint.x - xMin) * step;
                const firstY = padding.top + chartHeight - (firstPoint.y / 100) * chartHeight;
                const lastX = padding.left + (lastPoint.x - xMin) * step;
                const lastY = padding.top + chartHeight - (lastPoint.y / 100) * chartHeight;

                // Convert points to screen coordinates
                const screenPoints = sortedData.map((point) => ({
                    x: padding.left + (point.x - xMin) * step,
                    y: padding.top + chartHeight - (point.y / 100) * chartHeight
                }));

                // Start with horizontal line from first day's kl. 00:00 to first point
                const firstDayStartX = padding.left + (0 - xMin) * step; // kl. 00:00 of first day
                ctx.moveTo(firstDayStartX, screenPoints[0].y);
                ctx.lineTo(screenPoints[0].x, screenPoints[0].y);

                // Connect all points with straight lines
                sortedData.forEach((point, index) => {
                    const x = padding.left + (point.x - xMin) * step;
                    const y = padding.top + chartHeight - (point.y / 100) * chartHeight;

                    if (index === 0) {
                        ctx.lineTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                // End with horizontal line from last point to end of last day (kl. 24:00)
                // Use the actual last day index from all labels (all available data) for proper scrolling
                const lastDayIndex = labels.length - 1;
                const lastDayEndX = padding.left + ((lastDayIndex + 1.0) - xMin) * step;
                ctx.lineTo(lastDayEndX, lastY);
            }
            ctx.stroke();

            // Draw midnight markers (kl. 24) in detailed view only
            if (checkinDetailedView && labels.length > 0) {
                ctx.strokeStyle = '#cbd5e1';
                ctx.lineWidth = 1;
                // Solid line (no dash)
                
                labels.forEach((dateKey, index) => {
                    // Calculate x position for midnight (kl. 24) - this is at the end of each day (index + 1.0)
                    // This represents 24:00 / 00:00 of the next day
                    const x = padding.left + ((index + 1.0) - xMin) * step;
                    
                    // Draw vertical line from top to bottom of chart area
                    ctx.beginPath();
                    ctx.moveTo(x, padding.top);
                    ctx.lineTo(x, padding.top + chartHeight);
                    ctx.stroke();
                });
            }

            // Store point positions for hover detection
            const pointPositions = [];

            // Draw points
            sortedData.forEach((point, idx) => {
                const x = padding.left + (point.x - xMin) * step;
                const y = padding.top + chartHeight - (point.y / 100) * chartHeight;
                const radius = point.size / 19;
                const isHollow = !checkinDetailedView && point.count > 1;

                // Skip if coordinates are invalid
                if (isNaN(x) || isNaN(y) || isNaN(radius)) {
                    return;
                }

                pointPositions.push({
                    x, y, radius, point
                });

                if (isHollow) {
                    // Hollow circle for multiple entries in simple view
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = 'white';
                    ctx.fill();
                    ctx.strokeStyle = '#8b5cf6';
                    ctx.lineWidth = 2.5;
                    ctx.stroke();
                } else {
                    // Filled circle - darker for single entries (size 100)
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    const isSingleEntry = point.size === 100;
                    ctx.fillStyle = isSingleEntry ? '#6d28d9' : '#8b5cf6'; // Darker purple for single entries
                    ctx.fill();
                }
            });

            // X-axis labels
            ctx.fillStyle = '#475569';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            labels.forEach((dateKey, index) => {
                // Position labels at noon (kl. 12) - index + 0.5
                const x = padding.left + (index + 0.5 - xMin) * step;
                const dateObj = new Date(dateKey);
                
                // Get day and month separately for two-line display
                const day = dateObj.toLocaleDateString('da-DK', { day: '2-digit' });
                const month = dateObj.toLocaleDateString('da-DK', { month: 'short' }).replace('.', '');
                
                // Draw day on first line (inside chart area, near bottom)
                ctx.fillText(day, x, height - 28);
                // Draw month on second line
                ctx.fillText(month, x, height - 14);
            });

            // Hover functionality - remove old listeners first
            const oldMouseMove = canvas.onmousemove;
            const oldMouseLeave = canvas.onmouseleave;
            canvas.onmousemove = null;
            canvas.onmouseleave = null;

            // Use a single event handler function
            const handleMouseMove = (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width) / dpr;
                const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height) / dpr;

                let hoveredPoint = null;
                for (const pos of pointPositions) {
                    const distance = Math.sqrt(Math.pow(mouseX - pos.x, 2) + Math.pow(mouseY - pos.y, 2));
                    if (distance <= pos.radius + 5) {
                        hoveredPoint = pos;
                        break;
                    }
                }

                if (hoveredPoint) {
                    tooltip.style.display = 'block';
                    if (checkinDetailedView) {
                        // Detailed view: show time and value
                        tooltip.innerHTML = `
                            <p>Tid: ${hoveredPoint.point.time || 'N/A'}</p>
                            <p>Værdi: ${hoveredPoint.point.y}</p>
                        `;
                    } else {
                        // Simple view: show only value
                        tooltip.innerHTML = `
                            <p>Værdi: ${hoveredPoint.point.y}</p>
                        `;
                    }
                    const tooltipX = e.clientX - rect.left + 10;
                    const tooltipY = e.clientY - rect.top - 40;
                    tooltip.style.left = `${tooltipX}px`;
                    tooltip.style.top = `${tooltipY}px`;
                    canvas.style.cursor = 'pointer';
                } else {
                    tooltip.style.display = 'none';
                    canvas.style.cursor = 'default';
                }
            };

            const handleMouseLeave = () => {
                tooltip.style.display = 'none';
                canvas.style.cursor = 'default';
            };

            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseleave', handleMouseLeave);
        }

        // DEBUG HELPERS - remove before production
        async function read_debug_data() {
            console.warn('read_debug_data is a temporary debugging helper and should be removed before release.');
            try {
                const response = await fetch('debug_logbog.json', { cache: 'no-cache' });
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status} ${response.statusText}`);
                }
                const payload = await response.json();
                if (!Array.isArray(payload)) {
                    throw new Error('debug_logbog.json does not contain an array');
                }

                const normalizedEntries = payload
                    .filter(entry => entry && typeof entry === 'object')
                    .map(entry => {
                        const date = normalizeDateKey(entry.date) || getTodayDateKey();
                        return {
                            date,
                            dagbog: entry.dagbog || '',
                            dreams: entry.dreams || ''
                        };
                    });

                // Save to Firestore if user is logged in, otherwise localStorage
                if (currentUser && db) {
                    await saveLogbookDataToFirestore(normalizedEntries);
                }
                localStorage.setItem(LOGBOOK_STORAGE_KEY, JSON.stringify(normalizedEntries));

                const sorted = normalizedEntries.slice().sort((a, b) => {
                    // Use date as primary sort key (YYYY-MM-DD format)
                    const dateA = a.date || '';
                    const dateB = b.date || '';
                    return dateB.localeCompare(dateA); // newer first
                });
                const latestDate = sorted.length ? sorted[0].date : getTodayDateKey();
                await setActiveLogDate(latestDate);
                console.info(`Loaded ${normalizedEntries.length} entries into logbogData from debug_logbog.json`);
            } catch (error) {
                console.error('Failed to load debug log data:', error);
            }
        }

        async function read_debug_body() {
            console.warn('read_debug_body is a temporary debugging helper and should be removed before release.');
            try {
                const response = await fetch('debug_body.json', { cache: 'no-cache' });
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status} ${response.statusText}`);
                }
                const payload = await response.json();
                if (!Array.isArray(payload)) {
                    throw new Error('debug_body.json does not contain an array');
                }

                const mapPalette = ['#ec4899', '#10b981', '#1d4ed8', '#f97316', '#8b5cf6', '#ef4444', '#14b8a6', '#f59e0b'];
                const mapNameToId = new Map();
                const maps = [];
                let nextMapId = 1;

                const acquireMapId = (name) => {
                    const safeName = name && typeof name === 'string' ? name.trim() : 'Debug Map';
                    if (mapNameToId.has(safeName)) {
                        return mapNameToId.get(safeName);
                    }
                    const id = nextMapId++;
                    mapNameToId.set(safeName, id);
                    maps.push({
                        id,
                        name: safeName,
                        color: mapPalette[(id - 1) % mapPalette.length]
                    });
                    return id;
                };

                let indexCounter = 1;
                let labelCounter = 1;

                const dataIndexes = payload
                    .filter(entry => entry && typeof entry === 'object')
                    .map(entry => {
                        const normalizedDate = normalizeDateKey(entry.date) || getTodayDateKey();
                        const time = typeof entry.time === 'string' && entry.time.trim().length ? entry.time.trim() : '08:00';
                        const mapId = acquireMapId(entry.map);

                        const timestampSource = parseDanishDateTime(`${normalizedDate} ${time}`) || new Date(`${normalizedDate}T${time}`);
                        const timestamp = timestampSource && !Number.isNaN(timestampSource.getTime())
                            ? timestampSource.toISOString()
                            : new Date().toISOString();

                        const labels = Array.isArray(entry.labels) && entry.labels.length
                            ? entry.labels.map((label, idx) => {
                                const textParts = [];
                                if (label && typeof label.text === 'string') {
                                    textParts.push(label.text.trim());
                                }
                                if (label && typeof label.notes === 'string' && label.notes.trim().length) {
                                    textParts.push(label.notes.trim());
                                }
                                const text = textParts.length ? textParts.join(' – ') : `Notat ${idx + 1}`;
                                const baseX = 420 + (idx * 14);
                                const baseY = 220 + (idx * 18);
                                const basePointerX = baseX - 40;
                                const basePointerY = baseY + 30;
                                return {
                                    id: labelCounter++,
                                    text,
                                    x: baseX,
                                    y: baseY,
                                    pointerX: basePointerX,
                                    pointerY: basePointerY,
                                    labelNumber: idx + 1
                                };
                            })
                            : [{
                                id: labelCounter++,
                                text: 'Ingen noter',
                                x: 420,
                                y: 220,
                                pointerX: 380,
                                pointerY: 250,
                                labelNumber: 1
                            }];

                        return {
                            id: indexCounter++,
                            mapId,
                            date: normalizedDate,
                            time,
                            title: typeof entry.map === 'string' && entry.map.trim().length ? entry.map.trim() : `Lag ${indexCounter}`,
                            labels,
                            timestamp
                        };
                    });

                const nowIso = new Date().toISOString();
                const activeIndexId = dataIndexes.length ? dataIndexes[dataIndexes.length - 1].id : null;
                const activeMapId = dataIndexes.length ? dataIndexes[dataIndexes.length - 1].mapId : (maps[0] ? maps[0].id : null);

                const bodymapData = {
                    version: '2.0',
                    metadata: {
                        title: 'Debug Body Data',
                        created: nowIso,
                        updated: nowIso,
                        showOnionLayers: true,
                        activeMapId,
                        activeIndexId
                    },
                    maps,
                    dataIndexes
                };

                localStorage.setItem(BODYMAP_STORAGE_KEY, JSON.stringify(bodymapData));
                await renderActivitiesForDate(activeLogDate);
                console.info(`Loaded ${dataIndexes.length} indexes across ${maps.length} maps into bodymapData from debug_body.json`);
            } catch (error) {
                console.error('Failed to load debug body data:', error);
            }
        }

        async function read_debug_checkin() {
            console.warn('read_debug_checkin is a temporary debugging helper and should be removed before release.');
            try {
                const response = await fetch('testcheckin.json', { cache: 'no-cache' });
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status} ${response.statusText}`);
                }
                const payload = await response.json();
                if (!Array.isArray(payload)) {
                    throw new Error('testcheckin.json does not contain an array');
                }

                // Convert to the same format as loadCheckinData returns
                const processedData = payload
                    .filter(entry => entry && typeof entry === 'object' && typeof entry.status === 'number')
                    .map(entry => {
                        const dateObj = entry.date ? new Date(entry.date) : new Date();
                        return {
                            date: dateObj,
                            status: Math.max(0, Math.min(100, Number(entry.status))),
                            dateKey: dateObj.toISOString().split('T')[0],
                            time: dateObj.toLocaleTimeString('da-DK', { hour: '2-digit', minute: '2-digit', hour12: false })
                        };
                    })
                    .sort((a, b) => a.date - b.date);

                // Store in debug variable (doesn't overwrite localStorage)
                debugCheckinData = processedData;
                
                // Re-render chart with debug data
                renderCheckinChart();
                
                console.info(`Loaded ${processedData.length} check-in entries from testcheckin.json (temporary, not saved to localStorage)`);
            } catch (error) {
                console.error('Failed to load debug check-in data:', error);
            }
        }

        // Function to clear debug data and return to localStorage
        function clear_debug_checkin() {
            debugCheckinData = null;
            renderCheckinChart();
            console.info('Cleared debug check-in data, returning to localStorage');
        }

        function initCheckinViewToggle() {
            // Toggle view button
            const toggleViewBtn = document.getElementById('toggleCheckinView');
            if (toggleViewBtn) {
                const updateToggleButton = () => {
                    toggleViewBtn.src = checkinDetailedView 
                        ? 'imagefiles/simpleCurve.svg' 
                        : 'imagefiles/detailedCurve.svg';
                };
                updateToggleButton();

                toggleViewBtn.addEventListener('click', () => {
                    checkinDetailedView = !checkinDetailedView;
                    updateToggleButton();
                    renderCheckinChart();
                });
            }
        }

        function initCheckinDaysButtons() {
            const daysButtons = document.querySelectorAll('.checkin-days-btn');
            if (!daysButtons.length) return;

            // Set initial active button (5 days)
            daysButtons.forEach(btn => {
                const days = parseInt(btn.getAttribute('data-days'), 10);
                if (days === checkinDaysView) {
                    btn.classList.add('active');
                }
            });

            daysButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const days = parseInt(btn.getAttribute('data-days'), 10);
                    checkinDaysView = days;
                    
                    // If 1 day is selected, automatically enable detailed view
                    if (days === 1) {
                        checkinDetailedView = true;
                        const toggleViewBtn = document.getElementById('toggleCheckinView');
                        if (toggleViewBtn) {
                            // Update toggle button icon to reflect detailed view
                            toggleViewBtn.src = checkinDetailedView 
                                ? 'imagefiles/simpleCurve.svg' 
                                : 'imagefiles/detailedCurve.svg';
                        }
                    }
                    
                    // Update active state
                    daysButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    // Re-render chart with new days view
                    renderCheckinChart();
                });
            });
        }

        function initCheckinModal() {
            const modal = document.getElementById('checkinModal');
            const openBtn = document.getElementById('openCheckinModal');
            const closeBtn = document.getElementById('closeCheckinModal');
            const slider = document.getElementById('checkinSlider');
            const sliderValue = document.getElementById('checkinSliderValue');
            const saveBtn = document.getElementById('saveCheckinBtn');

            if (!modal || !openBtn || !closeBtn || !slider || !sliderValue || !saveBtn) return;

            // Check if user can make a new check-in
            const checkIfCanMakeCheckin = async () => {
                if (!currentUser || !db) {
                    alert('Du skal være logget ind for at lave et check-in.');
                    return false;
                }
                
                const now = new Date();
                
                // Load logbogData from Firestore
                try {
                    const logbogData = await getLogbookEntries();
                    if (!logbogData || !Array.isArray(logbogData)) {
                        return true; // No data, allow check-in
                    }
                    
                    // Find all check-ins from all dates and get the most recent one
                    let allCheckins = [];
                    logbogData.forEach(entry => {
                        if (Array.isArray(entry.checkins) && entry.date) {
                            entry.checkins.forEach(checkin => {
                                if (checkin.time) {
                                    // Create Date from date + time
                                    const dateTimeStr = `${entry.date}T${checkin.time}:00`;
                                    allCheckins.push(new Date(dateTimeStr));
                                }
                            });
                        }
                    });
                    
                    if (allCheckins.length > 0) {
                        // Sort by date (newest first)
                        allCheckins.sort((a, b) => b.getTime() - a.getTime());
                        const lastCheckInDate = allCheckins[0];
                        const timeDiff = now.getTime() - lastCheckInDate.getTime();
                        const thirtyMinutes = 30 * 60 * 1000; // milliseconds in 30 minutes

                        if (timeDiff < thirtyMinutes) {
                            const minutesRemaining = Math.ceil((thirtyMinutes - timeDiff) / (60 * 1000));
                            alert(`Du kan maksimalt lave et check-in i halv time. Vent venligst ${minutesRemaining} ${minutesRemaining === 1 ? 'minut' : 'minutter'} før du kan lave et nyt check-in.`);
                            return false;
                        }
                    }
                } catch (error) {
                    console.warn('[CHECKIN] Kunne ikke læse check-in data fra logbogData:', error);
                }
                
                return true;
            };

            // Open modal
            openBtn.addEventListener('click', async () => {
                if (!(await checkIfCanMakeCheckin())) {
                    return; // Don't open modal if too soon
                }
                modal.classList.add('show');
                slider.value = 50;
                sliderValue.textContent = 50;
            });

            // Close modal
            const closeModal = () => {
                modal.classList.remove('show');
            };

            closeBtn.addEventListener('click', closeModal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeModal();
                }
            });

            // Update slider value display
            slider.addEventListener('input', (e) => {
                sliderValue.textContent = e.target.value;
            });

            // Save check-in
            saveBtn.addEventListener('click', async () => {
                if (!currentUser || !db) {
                    alert('Du skal være logget ind for at gemme et check-in.');
                    return;
                }
                
                const status = parseInt(slider.value, 10);
                const now = new Date();
                
                // Get current time in HH:MM format
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const timeStr = `${hours}:${minutes}`;
                
                // Get today's date key
                const dateKey = getTodayDateKey();

                try {
                    // Load existing logbogData
                    const logbogData = await getLogbookEntries();
                    
                    // Find or create entry for today
                    let entry = logbogData.find(item => item.date === dateKey);
                    if (!entry) {
                        entry = {
                            date: dateKey,
                            dagbog: '',
                            dreams: '',
                            checkins: [],
                            timestamp: now.toISOString(),
                            color: '#b8735e'
                        };
                        logbogData.push(entry);
                    }
                    
                    // Initialize checkins array if it doesn't exist
                    if (!Array.isArray(entry.checkins)) {
                        entry.checkins = [];
                    }
                    
                    // Add new check-in to the array
                    entry.checkins.push({
                        time: timeStr,
                        status: status
                    });
                    
                    // Update timestamp
                    entry.timestamp = now.toISOString();
                    
                    // Save to Firestore
                    await saveLogbookDataToFirestore(logbogData);
                    
                    console.log(`[CHECKIN] Manual check-in saved for ${dateKey} at ${timeStr}`);
                    
                    closeModal();
                    renderCheckinChart();
                    
                    // Update tanker field if viewing today's date
                    const tankerEntryEl = document.getElementById('tankerEntry');
                    if (tankerEntryEl) {
                        // Get affirmation text for the selected date (now async)
                        const affirmationText = await getAffirmationTextForDate(activeLogDate);
                        // Get taknem value for the selected date (now async)
                        const taknem = await getTaknemForDate(activeLogDate);
                        
                        // Combine affirmation text and taknem value
                        let combinedText = '';
                        if (affirmationText) {
                            combinedText = `Bekræftelse: "${affirmationText}"`;
                        }
                        if (taknem && taknem.trim()) {
                            if (combinedText) {
                                combinedText += '\n';
                            }
                            // Capitalize first letter of taknem value
                            const taknemValue = taknem.trim();
                            const capitalizedTaknem = taknemValue.charAt(0).toUpperCase() + taknemValue.slice(1);
                            combinedText += `Taknemmelighed : "${capitalizedTaknem}"`;
                        }
                        
                        tankerEntryEl.value = combinedText;
                        autoResizeTextarea(tankerEntryEl);
                    }
                } catch (error) {
                    console.error('[CHECKIN] Kunne ikke gemme check-in data:', error);
                    alert('Kunne ikke gemme check-in. Prøv igen.');
                }
            });
        }

        function hydrateHeaderDates() {
            const today = new Date();
            const activityLabel = document.getElementById('activityDateLabel');

            activityLabel.textContent = today.toLocaleDateString('da-DK');
        }

        function copyLogbookEntry() {
            const logbookEntryEl = document.getElementById('logbookEntry');
            if (!logbookEntryEl) return;

            const text = logbookEntryEl.value || '';
            if (!text.trim()) {
                // Optional: show a message that there's nothing to copy
                return;
            }

            // Use Clipboard API if available (modern browsers)
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(text).then(() => {
                    // Optional: show success feedback
                    const btn = document.getElementById('journalCopyBtn');
                    if (btn) {
                        const originalText = btn.textContent;
                        btn.textContent = 'Kopieret!';
                        setTimeout(() => {
                            btn.textContent = originalText;
                        }, 2000);
                    }
                }).catch(err => {
                    console.error('Kunne ikke kopiere til udklipsholder:', err);
                });
            } else {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    const successful = document.execCommand('copy');
                    if (successful) {
                        const btn = document.getElementById('journalCopyBtn');
                        if (btn) {
                            const originalText = btn.textContent;
                            btn.textContent = 'Kopieret!';
                            setTimeout(() => {
                                btn.textContent = originalText;
                            }, 2000);
                        }
                    }
                } catch (err) {
                    console.error('Kunne ikke kopiere til udklipsholder:', err);
                } finally {
                    document.body.removeChild(textArea);
                }
            }
        }

        function copyDreamEntry() {
            const dreamEntryEl = document.getElementById('dreamEntry');
            if (!dreamEntryEl) return;

            const text = dreamEntryEl.value || '';
            if (!text.trim()) {
                // Optional: show a message that there's nothing to copy
                return;
            }

            // Use Clipboard API if available (modern browsers)
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(text).then(() => {
                    // Optional: show success feedback
                    const btn = document.getElementById('dreamsCopyBtn');
                    if (btn) {
                        const originalText = btn.textContent;
                        btn.textContent = 'Kopieret!';
                        setTimeout(() => {
                            btn.textContent = originalText;
                        }, 2000);
                    }
                }).catch(err => {
                    console.error('Kunne ikke kopiere til udklipsholder:', err);
                });
            } else {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    const successful = document.execCommand('copy');
                    if (successful) {
                        const btn = document.getElementById('dreamsCopyBtn');
                        if (btn) {
                            const originalText = btn.textContent;
                            btn.textContent = 'Kopieret!';
                            setTimeout(() => {
                                btn.textContent = originalText;
                            }, 2000);
                        }
                    }
                } catch (err) {
                    console.error('Kunne ikke kopiere til udklipsholder:', err);
                } finally {
                    document.body.removeChild(textArea);
                }
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            // GUARD 1: Extend initial load period - wait for ALL
            
            // 1. Wait for auth state (max 3 seconds)
            try {
                await Promise.race([
                    authStatePromise,
                    new Promise(resolve => setTimeout(resolve, 3000))
                ]);
            } catch (e) {
                console.warn('Auth state wait error:', e);
            }
            
            // Resolve manually if not resolved yet
            if (!authStateReady && authStateResolver) {
                authStateResolver();
                authStateResolver = null;
            }
            
            // 2. Check if user is logged in - require login
            if (!currentUser) {
                alert('Du skal være logget ind for at bruge denne side. Redirecter til login...');
                window.location.href = 'index.html';
                return;
            }
            
            // 3. Load affirmations first
            await loadAffirmations();
            
            hydrateHeaderDates();
            initCheckinDaysButtons();
            initCheckinViewToggle();
            initCheckinModal();
            renderCheckinChart();
            
            // 4. Load data ÉN gang
            const entries = await ensureSeedLogbookData();
            console.log('[INIT] Loaded logbook data, entries:', entries?.length || 0);
            
            // 5. Wait for DOM to be fully rendered
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            console.log('[INIT] Initial load complete');
            
            // Always use today's date when page loads
            const todayKey = getTodayDateKey();
            if (activeLogDate !== todayKey) {
                activeLogDate = todayKey;
            }
            
            // 7. Load ALL activity data in parallel before first render
            console.log('[INIT] Loading activity data in parallel...');
            await Promise.all([
                getBodymapData(),
                getDialogData(),
                getOpstillingData(),
                getCompareData()
            ]);
            console.log('[INIT] All activity data loaded');
            
            // 8. Now render activities ONCE with all data loaded
            await renderActivitiesForDate(activeLogDate);
            initialActivityRenderDone = true;
            console.log('[INIT] Initial activity render complete');
            
            // 9. Render history and hydrate fields
            await renderLogHistory();
            await hydrateLogbookFields();
            
            // Track the last checked date to detect actual date changes (e.g., at midnight)
            let lastCheckedDateKey = getTodayDateKey();
            
            // Check date periodically and update ONLY if date actually changed (e.g., at midnight)
            // Don't change if user has manually selected a different date
            setInterval(() => {
                const currentTodayKey = getTodayDateKey();
                
                // Only update if the date actually changed (lastCheckedDateKey != currentTodayKey)
                // AND the active date is the old date (meaning user hasn't manually selected a different date)
                if (lastCheckedDateKey !== currentTodayKey && activeLogDate === lastCheckedDateKey) {
                    // Date actually changed (e.g., midnight passed) - update to today
                    activeLogDate = currentTodayKey;
                    setActiveLogDate(currentTodayKey);
                }
                
                // Update last checked date
                lastCheckedDateKey = currentTodayKey;
            }, 300000); // Check every 5 minutes (date only changes at midnight, so frequent checks not needed)
            
            // Also check when page becomes visible again (user comes back to tab)
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    const currentTodayKey = getTodayDateKey();
                    
                    // Only update if the date actually changed (lastCheckedDateKey != currentTodayKey)
                    // AND the active date is the old date (meaning user hasn't manually selected a different date)
                    if (lastCheckedDateKey !== currentTodayKey && activeLogDate === lastCheckedDateKey) {
                        // Date actually changed (e.g., user came back after midnight) - update to today
                        activeLogDate = currentTodayKey;
                        setActiveLogDate(currentTodayKey);
                    }
                    
                    // Update last checked date
                    lastCheckedDateKey = currentTodayKey;
                }
            });

            // Add copy button functionality
            const journalCopyBtn = document.getElementById('journalCopyBtn');
            if (journalCopyBtn) {
                journalCopyBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent triggering the label's click
                    copyLogbookEntry();
                });
            }

            const dreamsCopyBtn = document.getElementById('dreamsCopyBtn');
            if (dreamsCopyBtn) {
                dreamsCopyBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent triggering the label's click
                    copyDreamEntry();
                });
            }

            // Use event delegation for nav button clicks (only one listener instead of multiple)
            const navBox = document.querySelector('.nav-box');
            if (navBox) {
                navBox.addEventListener('click', function(e) {
                    const navButton = e.target.closest('.nav-button');
                    if (navButton) {
                        closeNavMenu();
                        const href = navButton.getAttribute('href');
                        if (href) {
                            window.location.href = href;
                        }
                    }
                });
                
                // Mark current page as active
                const navLinks = navBox.querySelectorAll('.nav-button');
                navLinks.forEach(link => {
                    if (link.getAttribute('href') === 'logbog_01.html') {
                        link.classList.add('active');
                    }
                });
            }

            window.addEventListener('storage', handleLogbookStorageEvent);
            window.addEventListener('storage', handleBodymapStorageEvent);
            window.addEventListener('storage', handleOpstillingStorageEvent);
            window.addEventListener('storage', handleCompareStorageEvent);

            const historySidebar = document.getElementById('logHistorySidebar');
            if (historySidebar) {
                // Default to collapsed (true) unless explicitly set to false in localStorage
                const savedState = localStorage.getItem(LOG_HISTORY_COLLAPSED_KEY);
                const collapsedState = savedState === null ? true : savedState === 'true';
                if (collapsedState) {
                    historySidebar.classList.add('collapsed');
                } else {
                    historySidebar.classList.remove('collapsed');
                }
            }

            window.addEventListener('resize', () => {
                    renderCheckinChart();
            });

            // Initialize log history color picker
            buildLogHistoryColorGrid();
            const logHistoryColorPickerModal = document.getElementById('logHistoryColorPickerModal');
            const logHistoryRemoveColorBtn = document.getElementById('logHistoryRemoveColorBtn');
            
            if (logHistoryColorPickerModal) {
                logHistoryColorPickerModal.addEventListener('click', (e) => {
                    if (e.target === logHistoryColorPickerModal) {
                        closeLogHistoryColorPicker();
                    }
                });
            }

            if (logHistoryRemoveColorBtn) {
                logHistoryRemoveColorBtn.addEventListener('click', removeLogHistoryColor);
            }

            // Close color picker on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const modal = document.getElementById('logHistoryColorPickerModal');
                    if (modal && modal.classList.contains('show')) {
                        closeLogHistoryColorPicker();
                    }
                }
            });
        });

    </script>
</body>
</html>

