<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="imagefiles/apple-touch-icon.png">
    <title>Forskelle og Ligheder</title>
    <!-- Firebase SDK v8.10.1 -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 0px;
            touch-action: manipulation;
            -webkit-text-size-adjust: none;
        }
        
        .comparison-container {
            width: 100%;
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 0px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            padding: 16px 24px;
            padding-top: calc(env(safe-area-inset-top) + 16px);
            text-align: center;
            border-radius: 0px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .header h1 {
            font-size: 2.0em;
            margin-bottom: 0px;
            font-weight: 300;
            width: 100%;
            text-align: center;
        }

        .header .nav-controls {
            position: absolute;
            top: 16px;
            left: 24px;
            display: inline-flex;
            flex-direction: column;
            gap: 0;
            align-items: flex-start;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .controls-bar {
            background: #f8fafc;
            padding: 12px 20px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .dropdown-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .dropdown-label {
            font-size: 14px;
            font-weight: 500;
            color: #374151;
            white-space: nowrap;
        }
        
        .participant-dropdown {
            padding: 8px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 15px;
            font-family: inherit;
            background: white;
            min-width: 160px;
            color: #374151;
            transition: all 0.3s ease;
        }
        
        .participant-dropdown:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        .controls-divider {
            width: 1px;
            height: 30px;
            background: #e2e8f0;
            margin: 0 8px;
            flex-shrink: 0;
        }
        
        /* Navigation overlay */
        .nav-toggle-btn {
            width: 35px;
            height: 35px;
            padding: 5px 8px;
            border: none;
            border-radius: 12px;
            background: #e5e7eb;
            color: #374151;
            box-shadow: 0 12px 26px rgba(15, 23, 42, 0.16);
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            cursor: pointer;
            transition: all 0.25s ease;
        }
        
        .nav-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(107, 114, 128, 0.3);
        }

        .nav-toggle-btn span {
            width: 16px;
            height: 2px;
            border-radius: 999px;
            background: #374151;
        }
        
        .nav-overlay {
            display: none !important;
        }
        
        .nav-box {
            position: fixed;
            top: 0;
            left: 0;
            background: white;
            border-radius: 20px;
            padding: 20px 25px;
            z-index: 9999;
            display: none;
            flex-direction: column;
            gap: 10px;
            min-width: 200px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        
        .nav-box.show {
            display: flex;
        }
        
        .nav-button {
            padding: 8px 16px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            text-align: center;
            display: block;
            min-width: auto;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
        }
        
        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }
        
        .nav-button.active {
            background: #9ca3af !important;
            cursor: default;
            pointer-events: none;
        }
        .nav-button.nav-checkin {
            background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);
        }
        .nav-button.nav-checkin:hover:not(.active) {
            background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
            box-shadow: 0 5px 15px rgba(124, 58, 237, 0.3);
        }
        
        .nav-button:nth-child(1) {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        
        .nav-button:nth-child(1):hover:not(.active) {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }
        
        .nav-button:nth-child(2) {
            background: linear-gradient(135deg, #E6B94F 0%, #d97706 100%);
        }
        
        .nav-button:nth-child(2):hover:not(.active) {
            background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
            box-shadow: 0 5px 15px rgba(245, 158, 11, 0.3);
        }
        
        .nav-button:nth-child(3) {
            background: linear-gradient(135deg, #3368AE 0%, #1e40af 100%);
        }
        
        .nav-button:nth-child(3):hover:not(.active) {
            background: linear-gradient(135deg, #1e40af 0%, #1e3a8a 100%);
            box-shadow: 0 5px 15px rgba(37, 99, 235, 0.3);
        }
        
        .nav-button:nth-child(4) {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
        }
        
        .nav-button:nth-child(4):hover:not(.active) {
            background: linear-gradient(135deg, #db2777 0%, #be185d 100%);
            box-shadow: 0 5px 15px rgba(236, 72, 153, 0.3);
        }
        
        .nav-button:nth-child(5) {
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
        }
        
        .nav-button:nth-child(5):hover:not(.active) {
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
            box-shadow: 0 5px 15px rgba(71, 85, 105, 0.3);
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .clear-btn { background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; }
        .save-btn { background: linear-gradient(135deg, #059669 0%, #047857 100%); color: white; }
        .random-btn { background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white; }
        .back-btn { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; }
        
        .btn:disabled { 
            background: #9ca3af !important; 
            cursor: not-allowed; 
        }
        .btn:hover:not(:disabled) { transform: translateY(-1px); }
        
        .participants-section {
            background: #f8fafc;
            padding: 0;
            border-bottom: 2px solid #e2e8f0;
            height: 250px;
            flex-shrink: 0;
            overflow: visible;
            position: relative;
        }
        
        .participants-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
            max-width: 700px;
            margin: 0 auto;
            gap: 75px;
            height: 100%;
            overflow: visible;
            position: relative;
        }

        
        
        .participant {
            flex: 0 0 200px;
            margin-top: -160px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            position: relative;
            overflow: visible;
            transform-origin: center center;
            min-width: 200px;
        }
        
        .participant-circle {
		width: 72px;
		height: 72px;
		border-radius: 50%;
		background: transparent;
		border: none;
		display: flex;
		align-items: center;
		justify-content: center;
		color: white;
		font-weight: bold;
		font-size: 10px;
		text-align: center;
		position: relative;
		padding: 5px;
		line-height: 1.1;
		z-index: 10;
		pointer-events: none;
	}
	.head {
		position: absolute;
		top: -74px;
		left: 50%;
		transform: translateX(-50%);
		width: 72px;
		height: 72px;
		border-radius: 50%;
		background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
		display: flex;
		align-items: center;
		justify-content: center;
		color: white;
		font-weight: bold;
		font-size: 10px;
		text-align: center;
		box-shadow: 0 8px 25px rgba(0,0,0,0.15);
		padding: 10px;
		line-height: 1.2;
		z-index: 5;
		pointer-events: auto;
		opacity: 1;
	}

.head span {
    font-size: 12px;
}


        /* New Advanced Figure Structure */
	.participant-body {
		position: absolute;
		top: 76px;
		
		transform-origin: 50px -40px;
		z-index: 5;
		pointer-events: none;
		width: 100px;
		height: 200px;
	}

	/* Torso */
	/* Torso */
.participant-torso {
    position: absolute;
    width: 54px;
    height: 72px;
    background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
    border-radius: 22px 22px 15px 15px;
    box-shadow: 0 3px 12px rgba(0,0,0,0.15);
    top: -2px;
	

    z-index: 8;
}

	/* Højre arm hierarki */
.skulder_translate_right {
    position: absolute;
    top: 0px;
    left: 62px;
    width: 15px;
    height: 15px;
    background: rgba(59, 130, 246, 0.0);
    z-index: 3;
}

.skulder_translate_right.front-arm {
    z-index: 15;
}

.skulder_rotate_right {
    width: 100%;
    height: 100%;
    background: rgba(239, 68, 68, 0.0);
    transform-origin: center center;
}

.arm_geo_right {
    width: 50px;
    height: 18px;
    background: #f59e0b;
    border-radius: 9px;
    position: relative;
    top: -1px;
    left: -1px;
}

.albue_rotate_right {
    position: relative;
    top: 1px;
    left: 34px;
    width: 15px;
    height: 15px;
    background: rgba(16, 185, 129, 0.0);
    transform-origin: center center;
}

.albue_geo_right {
    position: relative;
    top: -1px;
    left: 1px;
    width: 50px;
    height: 18px;
    background: #f59e0b;
    border-radius: 9px;
    z-index: 4;
}

.albue_geo_right.front {
    z-index: 20 !important;
    position: relative;
}

	/* Venstre arm hierarki */
.skulder_translate_left {
    position: absolute;
    top: 0px;
    left: 22px;
    width: 15px;
    height: 15px;
    background: rgba(59, 130, 246, 0.0);
    z-index: 3;
}

.skulder_translate_left.front-arm {
    z-index: 15;
}

.skulder_rotate_left {
    width: 100%;
    height: 100%;
    background: rgba(239, 68, 68, 0.0);
    transform-origin: center center;
}

.arm_geo_left {
    width: 50px;
    height: 18px;
    background: #f59e0b;
    border-radius: 9px;
    position: relative;
    top: -1px;
    left: -34px;
}

.albue_rotate_left {
    position: relative;
    top: 1px;
    left: 0px;
    width: 15px;
    height: 15px;
    background: rgba(16, 185, 129, 0.0);
    transform-origin: center center;
}

.albue_geo_left {
    position: relative;
    top: -1px;
    left: -33px;
    width: 50px;
    height: 18px;
    background: #f59e0b;
    border-radius: 9px;
    z-index: 4;
}

.albue_geo_left.front {
    z-index: 20 !important;
    position: relative;
}

	/* Højre ben hierarki */
.hofte_translate_right {
    position: absolute;
    top: 68px;
    left: 58px;
    width: 15px;
    height: 15px;
    background: rgba(59, 130, 246, 0.0);
}

.hofte_rotate_right {
    width: 100%;
    height: 100%;
    background: rgba(239, 68, 68, 0.0);
    transform-origin: center center;
}

.laar_geo_right {
    width: 18px;
    height: 55px;
    background: #f59e0b;
    border-radius: 9px;
    position: relative;
    top: -1px;
    left: -1px;
}

.knae_rotate_right {
    position: relative;
    top: 38px;
    left: 1px;
    width: 15px;
    height: 15px;
    background: rgba(16, 185, 129, 0.0);
    transform-origin: center center;
}

.skinneben_geo_right {
    position: relative;
    top: -1px;
    left: -1px;
    width: 18px;
    height: 50px;
    background: #f59e0b;
    border-radius: 9px;
}

/* Venstre ben hierarki */
.hofte_translate_left {
    position: absolute;
    top: 68px;
    left: 26px;
    width: 15px;
    height: 15px;
    background: rgba(59, 130, 246, 0.0);
}

.hofte_rotate_left {
    width: 100%;
    height: 100%;
    background: rgba(239, 68, 68, 0.0);
    transform-origin: center center;
}

.laar_geo_left {
    width: 18px;
    height: 55px;
    background: #f59e0b;
    border-radius: 9px;
    position: relative;
    top: -1px;
    left: -1px;
}

.knae_rotate_left {
    position: relative;
    top: 38px;
    left: 1px;
    width: 15px;
    height: 15px;
    background: rgba(16, 185, 129, 0.0);
    transform-origin: center center;
}

.skinneben_geo_left {
    position: relative;
    top: -1px;
    left: -1px;
    width: 18px;
    height: 50px;
    background: #f59e0b;
    border-radius: 9px;
}

	

        .participant-torso {
            width: 55px;
            height: 80px;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            margin: 0 auto;
            border-radius: 30px 30px 20px 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            position: relative;
            z-index: 5;
        }

        .participant-arms {
            position: absolute;
            top: 0px;
            left: 50%;
            transform: translateX(-50%);
            width: 140px;
            height: 30px;
            z-index: 0;
        }

        .participant-arm-left, .participant-arm-right {
            position: absolute;
            width: 75px;
            height: 20px;
            background: #f59e0b;
            border-radius: 10px;
            transform-origin: right center;
        }

        .participant-arm-left {
            left: -22px;
            top: -5px;
            transform: rotate(-50deg);
        }

        .participant-arm-right {
            right: -22px;
            top: -5px;
            transform: rotate(55deg);
            transform-origin: left center;
        }

        .participant-legs {
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 35px;
            z-index: 0;
        }

        .participant-leg-left, .participant-leg-right {
            position: absolute;
            width: 20px;
            height: 100px;
            background: #f59e0b;
            border-radius: 10px;
            transform-origin: top center;
        }

        .participant-leg-left {
            left: 27px;
            transform: rotate(-10deg);
        }

        .participant-leg-right {
            right: 27px;
            transform: rotate(10deg);
        }
        
        .participant-circle span[contenteditable] {
            outline: none;
            border-radius: 4px;
            padding: 2px;
            transition: all 0.2s ease;
            cursor: default;
        }
        
        .participant-circle span[contenteditable]:focus {
            background-color: white;
            color: black;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.5);
        }

        .color-circle-btn {
            position: absolute;
            bottom: 0px;
            right: 0px;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #a855f7;
            border: 2px solid white;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: bold;
            color: white;
            transition: all 0.3s ease;
            z-index: 150;
            opacity: 0;
			pointer-events: auto;
        }
        
        .color-circle-btn:hover {
            transform: scale(1.1);
            background: #9333ea;
        }
        
		
		#leftPoseBtn, #rightPoseBtn {
    position: absolute;
    bottom: 0px;
    right: 0px;
    width: 25px;
    height: 25px;
    border-radius: 50%;
    background: #06b6d4;
    border: 2px solid white;
    cursor: pointer;
    display: none;
    align-items: center;
    justify-content: center;
    font-size: 9px;
    font-weight: bold;
    color: white;
    transition: all 0.3s ease;
    z-index: 150;
    opacity: 0;
    transform: translate(0px, -25px);
	pointer-events: auto;  
}

#leftPoseBtn:hover, #rightPoseBtn:hover {
    transform: translate(0px, -25px) scale(1.1);
    background: #0891b2;
}

.participant-circle:hover #leftPoseBtn,
.participant-circle:hover #rightPoseBtn {
    display: flex !important;
    opacity: 1;
}
		
		
		
		
        .participant-circle:hover .color-circle-btn {
            display: flex;
            opacity: 1;
        }
        
        .note-circle-btn {
            position: absolute;
            bottom: 0px;
            left: 0px;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #f97316;
            border: 2px solid white;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: bold;
            color: white;
            transition: all 0.3s ease;
            z-index: 150;
            opacity: 0;
			pointer-events: auto;
        }
        
        .note-circle-btn:hover {
            transform: scale(1.1);
            background: #ea580c;
        }
        
        .participant-circle:hover .note-circle-btn {
            display: flex;
            opacity: 1;
        }
        
        /* Name Editor Overlay Styles */
        .note-overlay {
            position: fixed;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            border: 3px solid rgba(226, 232, 240, 0.5);
            z-index: 10000;
            width: 105px;
            display: none;
        }
        
        .note-overlay.show {
            display: block;
        }
        
        .note-overlay textarea {
            width: 100%;
            height: auto;
            min-height: auto;
            max-height: 110px;
            padding: 6px 10px;
            border: 3px solid rgba(226, 232, 240, 0.8);
            border-radius: 6px;
            font-size: 16px;
            font-family: 'Arial', sans-serif;
            resize: none;
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.9);
            color: #374151;
            line-height: 1.4;
            overflow-y: auto;
            word-break: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        
        .note-overlay textarea:focus {
            outline: none;
            border-color: #f97316;
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.1);
        }
        
        #leftName, #rightName {
            pointer-events: auto;
            font-size: 12px;
            display: inline-block;
            min-width: 20px;
            min-height: 16px;
            padding: 2px 4px;
            word-break: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        
        .status {
            text-align: center;
            color: #6b7280;
            font-size: 12px;
            padding: 5px;
        }

        /* Color Picker Styles */
        .color-picker-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }
        
        .color-picker-modal.show {
            display: flex;
        }
        
        .picker {
            width: 224px;
            background: #ffffff;
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border: 1px solid #e2e8f0;
        }
        
        .swatch {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            border: 1px solid rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .swatch:hover {
            transform: scale(1.2);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 10;
        }
        
        .color-grid {
            display: grid;
            grid-template-columns: repeat(12, 15px);
            grid-template-rows: repeat(14, 15px);
            gap: 2px;
            background: transparent;
        }
		
		
		/* Pose Picker Styles */
.pose-picker-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: transparent;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 3000;
}

.pose-picker-modal.show {
    display: flex;
}

.pose-picker {
    width: 280px;
    background: #ffffff;
    padding: 15px;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    border: 1px solid #e2e8f0;
}

.pose-mirror-section {
    text-align: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #e2e8f0;
}

.pose-mirror-label {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    font-size: 14px;
    font-weight: 500;
    color: #374151;
    cursor: pointer;
}

.pose-mirror-label input[type="checkbox"] {
    width: 16px;
    height: 16px;
    transform: scale(1.2);
}

.pose-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
}

.pose-button {
    padding: 8px 12px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    background: white;
    color: #374151;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
}

.pose-button:hover {
    border-color: #3b82f6;
    background: #f0f9ff;
    color: #1d4ed8;
}

.pose-button.active {
    border-color: #3b82f6;
    background: #3b82f6;
    color: white;
}
		
		
		
		
		
        
        /* Comparison Section Styles */
        .main-content {
            position: relative;
            flex: 1;
            overflow: hidden;
            min-height: 0;
            display: flex;
        }
        
        .comparison-workspace-container {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex: 1;
            min-height: 0;
            position: relative;
        }
        
        .comparison-section {
            flex: 1;
            background: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }
        
        .comparison-header {
            background: #f1f5f9;
            padding: 15px 20px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .comparison-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #fafafa;
            min-height: 0;
        }
        
        .step-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            margin-bottom: 20px;
        }
        
        .step-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .step-title {
            font-size: 18px;
            font-weight: bold;
            color: #374151;
        }
        
        .step-nav {
            display: flex;
            gap: 10px;
        }
        
        .step-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .step-btn.active {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
        }
        
        .step-btn:not(.active) {
            background: #e5e7eb;
            color: #6b7280;
        }
        
        .step-btn:hover:not(.active) {
            background: #d1d5db;
        }
        
        .step-content {
            display: none;
        }
        
        .step-content.active {
            display: block;
        }
        
        .single-side-traits {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .single-trait-item {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: 12px;
    padding: 15px;
    background: #f8fafc;
    border-radius: 8px;
    border: 1px solid #e2e8f0;
    width: 100%;
    max-width: 430px;
    margin: 0 auto;
}

#step1 .single-trait-item {
    margin-left: 0;
    margin-right: auto;
}

#step2 .single-trait-item {
    margin-left: auto;
    margin-right: 0;
}
        
  #leftTraits .single-trait-item {
    justify-content: flex-start;
}

#leftTraits .single-slider-container {
    flex: 0 0 auto;
}

#rightTraits .single-trait-item {
    justify-content: flex-end;
}

#rightTraits .single-slider-container {
    flex: 0 0 auto;
}

#comparisonResults > div {
    justify-content: center;
}

#leftTraits .single-trait-item {
    justify-content: flex-start;
}

#leftTraits .single-slider-container {
    flex: 0 0 auto;
}

#rightTraits .single-trait-item {
    justify-content: flex-end;
}

#rightTraits .single-slider-container {
    flex: 0 0 auto;
}

#comparisonResults > div > div {
    justify-content: center;
    margin: 0 auto;
    width: fit-content;
}

.comparison-slider-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
    width: 100%;
}

.comparison-labels {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 15px;
    width: 100%;
}    
        
.single-slider-container {
    display: flex;
    flex-direction: column;
    gap: 6px;
    width: 100%;
}

.single-slider-labels {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

.trait-left-label {
    min-width: 120px;
    text-align: left;
    font-size: 16px;
    color: #4b5563;
    font-weight: 500;
}

.trait-right-label {
    min-width: 120px;
    text-align: right;
    font-size: 16px;
    color: #4b5563;
    font-weight: 500;
}
        
        .single-slider {
    width: 100%;
    max-width: 400px;
    height: 6px;
    border-radius: 3px;
    background: #e2e8f0;
    outline: none;
    cursor: pointer;
    -webkit-appearance: none;
    appearance: none;
}
        
        .single-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }
        
        .single-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        
        .single-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }
        
        .single-slider.left-color::-webkit-slider-thumb {
            background: var(--left-color, #3b82f6);
        }
        
        .single-slider.right-color::-webkit-slider-thumb {
            background: var(--right-color, #3b82f6);
        }
        
        .single-slider.left-color::-moz-range-thumb {
            background: var(--left-color, #3b82f6);
        }
        
        .single-slider.right-color::-moz-range-thumb {
            background: var(--right-color, #3b82f6);
        }
        
        .slider-value {
            min-width: 60px;
            text-align: center;
            font-weight: 500;
            color: #4b5563;
        }
        
        .speedometer-section {
            display: flex;
            justify-content: space-around;
            margin-top: 30px;
            gap: 30px;
        }
        
        .speedometer-container {
            text-align: center;
        }
        
        .speedometer {
            width: 150px;
            height: 150px;
            position: relative;
            margin: 0 auto 10px;
        }
        
        .speedometer svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }
        
        .speedometer-bg {
            fill: none;
            stroke: #e5e7eb;
            stroke-width: 12;
        }
        
        .speedometer-fill {
            fill: none;
            stroke-width: 12;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s ease;
        }
        
        .speedometer-similarity .speedometer-fill {
            stroke: #10b981;
        }
        
        .speedometer-difference .speedometer-fill {
            stroke: #ef4444;
        }
        
        .speedometer-label {
            font-size: 16px;
            font-weight: bold;
            color: #374151;
            margin-bottom: 5px;
        }
        
        .speedometer-value {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .speedometer-similarity .speedometer-value {
            color: #10b981;
        }
        
        .speedometer-difference .speedometer-value {
            color: #ef4444;
        }
        
.comparison-slider-container {
    position: relative;
    width: 100%;
    max-width: 400px;
    height: 20px;
}

.compare-color-btn {
    min-width: 32px;
    height: 32px;
    border-radius: 6px;
    border: 2px solid white;
    color: white;
    font-size: 12px;
    font-weight: bold;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    transition: all 0.2s ease;
}

.compare-color-btn:hover {
    transform: translateY(-1px);
    filter: brightness(1.05);
}

.comparison-labels {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 15px;
}

.comparison-left-label {
    min-width: 120px;
    text-align: left;
    font-size: 16px;
    color: #4b5563;
    font-weight: 500;
}

.comparison-right-label {
    min-width: 120px;
    text-align: right;
    font-size: 16px;
    color: #4b5563;
    font-weight: 500;
}
        
        .comparison-slider {
            position: absolute;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            cursor: default;
            -webkit-appearance: none;
            pointer-events: none;
            appearance: none;
        }
        
        .comparison-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3b82f6;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            pointer-events: none;
            position: relative;
            z-index: 2;
        }
        
        .comparison-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3b82f6;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            pointer-events: none;
        }
        
        .comparison-slider.left-color::-webkit-slider-thumb {
            background: var(--left-color, #3b82f6);
        }
        
        .comparison-slider.right-color::-webkit-slider-thumb {
            background: var(--right-color, #ef4444);
        }
        
        .comparison-slider.left-color::-moz-range-thumb {
            background: var(--left-color, #3b82f6);
        }
        
        .comparison-slider.right-color::-moz-range-thumb {
            background: var(--right-color, #ef4444);
        }
        
        .progress-indicators {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #d1d5db;
            transition: all 0.2s ease;
        }
        
        .progress-dot.active {
            background: #3b82f6;
            transform: scale(1.2);
        }
        
        .progress-dot.completed {
            background: #10b981;
        }
        
        .empty-state {
            text-align: center;
            color: #9ca3af;
            font-style: italic;
            padding: 40px;
        }
		
		
/* distance knapper */
.distance-controls-wrapper {
    position: relative;
    height: 0;
    z-index: 200;
	
	
}

.distance-controls {
    position: absolute;
	top: -26px; 
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 12px;
    opacity: 1;
    transition: opacity 0.3s ease;
}

.distance-controls-wrapper:hover .distance-controls,
.participants-section:hover ~ .distance-controls-wrapper .distance-controls {
    opacity: 1;
}


.distance-label {
    font-size: 10px;
    color: #6b7280;
    font-weight: 500;
    white-space: nowrap;
}


.distance-btn {
    width: 30px;
    height: 15px;
    border-radius: 25%;
	background: linear-gradient(135deg, #d1d5db 0%, #9ca3af 100%);
    border: 1px solid white;
    color: white;
    font-size: 12px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    transition: all 0.2s ease;
}

.distance-btn:hover {
    transform: scale(1.1);
    background: linear-gradient(135deg, #9ca3af 0%, #6b7280 100%);  
    box-shadow: 0 4px 12px rgba(0,0,0,0.25);
}

.distance-btn:active {
    transform: scale(0.95);
}
		
		
		
		/* History Sidebar */
        .history-sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 200px;
            height: 100vh;
            background: #f8fafc;
            border: none;
            border-radius: 18px 0 0 18px;
            overflow-x: visible;
            overflow-y: hidden;
            display: flex;
            flex-direction: column;
            transition: transform 0.6s ease;
            box-shadow: 0 20px 40px rgba(15, 23, 42, 0.18);
            z-index: 4000;
        }

        .history-top-bar {
            height: calc(env(safe-area-inset-top) + 69px);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            position: relative;
            flex-shrink: 0;
            overflow: visible;
        }
        
        .history-sidebar.collapsed {
            transform: translateX(200px);
            overflow: visible;
            border-radius: 18px 0 0 18px;
        }
        
        .history-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            height: 100%;
        }
        
        .history-sidebar.collapsed .history-content {
            display: none;
        }
        
        .collapse-toggle {
            position: absolute;
            left: 2px;
            bottom: 10px;
            background: #4f46e5;
            color: white;
            border: none;
            width: 20px;
            height: 50px;
            border-radius: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 100;
            padding: 0;
        }

        .collapse-toggle img {
            width: 12px;
            height: 30px;
            filter: brightness(0) invert(1);
            transition: transform 0.6s ease;
        }

        .history-sidebar.collapsed .collapse-toggle img {
            transform: rotate(180deg);
        }

        .history-sidebar.collapsed .collapse-toggle {
            left: -28px;
        }
        
        .collapse-toggle:hover {
            background: #4338ca;
            transform: scale(1.1);
        }
        
        .collapse-toggle-bottom {
            top: auto;
            bottom: 8px;
        }
        
        .history-sidebar.collapsed .collapse-toggle-bottom {
            left: -28px;
        }
        
        .nav-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: white !important;
            cursor: pointer;
            font-size: 0;
            color: black;
            transition: all 0.2s;
            position: relative;
            padding: 0;
        }
        
        .nav-btn::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .nav-btn#navUp::before {
            border-bottom: 12px solid black;
            border-top: none;
        }
        
        .nav-btn#navDown::before {
            border-top: 12px solid black;
            border-bottom: none;
        }
        
        .nav-btn:hover {
            background: #f3f4f6;
        }
        
        .nav-btn:hover::before {
            opacity: 0.7;
        }
        
        .nav-btn:disabled {
            background: #d1d5db;
            color: #9ca3af;
            cursor: not-allowed;
        }
        
        .nav-btn:disabled::before {
            opacity: 0.4;
        }
        
        .history-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px;
            min-height: 0;
        }
        
        .history-item {
            padding: 10px;
            margin-bottom: 6px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            border: 2px solid transparent;
            position: relative;
            touch-action: manipulation;
        }
        
        .history-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 18px rgba(15, 23, 42, 0.15);
        }
        
        .history-item.active {
            box-shadow: 0 10px 24px rgba(15, 23, 42, 0.25);
        }

        .history-item-title {
            display: flex;
            align-items: center;
            padding: 2px 12px;
            border-radius: 999px;
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 6px;
            max-width: 100%;
            overflow: hidden;
        }
        
        .history-item-date {
            width: 100%;
            flex: 1;
            border: none;
            background: transparent;
            outline: none;
            font-weight: 600;
            font-size: 16px;
            color: #ffffff;
            padding: 0;
            margin: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .history-item.active .history-item-date {
            padding: 2px 12px;
            margin: -2px -12px;
            cursor: text;
            transition: background 0.15s ease, box-shadow 0.15s ease;
            white-space: normal;
            border-radius: 999px;
        }
        
        .history-item.active .history-item-date:hover,
        .history-item.active .history-item-date:focus {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5);
        }
        
        .history-item .history-item-date[readonly] {
            cursor: default;
            opacity: 0.95;
        }
        
        .history-item-meta {
            display: flex;
            flex-direction: column;
            font-size: 16px;
            opacity: 0.85;
            gap: 4px;
        }
        
        .history-item-meta-line {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        
        .history-item-time {
            white-space: nowrap;
        }
        
        .history-item-participants {
            white-space: normal;
        }
        
        .history-item-delete {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: none;
            background: #ef4444;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            line-height: 1;
            z-index: 10;
            pointer-events: none;
        }
        
        .history-item:hover .history-item-delete,
        .history-item.active .history-item-delete {
            opacity: 1;
            pointer-events: auto;
        }
        
        .history-item-delete:hover {
            background: #dc2626;
            transform: scale(1.1);
        }

        .history-item-color-btn {
            position: absolute;
            top: 2px;
            right: 28px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: none;
            background: #e5e7eb;
            color: #374151;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            z-index: 10;
            pointer-events: none;
        }

        .history-item:hover .history-item-color-btn,
        .history-item.active .history-item-color-btn {
            opacity: 1;
            pointer-events: auto;
        }

        .history-item-color-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(15, 23, 42, 0.2);
        }
        
        .log-history-month-header {
            padding: 12px 14px;
            margin-bottom: 8px;
            border-radius: 12px;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            transition: all 0.2s ease;
            user-select: none;
        }

        .log-history-month-header:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        }

        .log-history-month-header.expanded {
            margin-bottom: 12px;
        }

        .log-history-month-title {
            font-weight: 600;
            font-size: 0.95rem;
        }

        .log-history-month-count {
            font-size: 0.8rem;
            opacity: 0.85;
            flex: 1;
            text-align: right;
        }

        .log-history-month-arrow {
            font-size: 0.7rem;
            opacity: 0.9;
            transition: transform 0.2s ease;
        }
        
        /* History Item Color Picker */
        .history-color-picker-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(15, 23, 42, 0.35);
            z-index: 5001;
        }

        .history-color-picker-modal.show {
            display: flex;
        }

        .history-color-picker {
            width: calc(32px * 6 + 8px * 5 + 16px * 2);
            background: #ffffff;
            border-radius: 14px;
            padding: 16px;
            box-shadow: 0 18px 45px rgba(15, 23, 42, 0.25);
            border: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .history-color-picker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-color-picker-header h3 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: #1f2937;
        }

        .history-color-grid {
            display: grid;
            grid-template-columns: repeat(6, 32px);
            gap: 8px;
            justify-content: center;
        }

        .history-color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 1px solid rgba(15, 23, 42, 0.08);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .history-color-swatch:hover {
            transform: scale(1.08);
            box-shadow: 0 6px 14px rgba(15, 23, 42, 0.2);
        }

        .history-remove-color-btn {
            padding: 8px 16px;
            background: #f3f4f6;
            color: #6b7280;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .history-remove-color-btn:hover {
            background: #e5e7eb;
            color: #374151;
        }
        
        .nav-btn-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Samling Manager Overlay */
        .samling-manager-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 5000;
        }
        
        .samling-manager-overlay.show {
            display: flex;
        }
        
        .samling-manager-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.45);
            backdrop-filter: blur(4px);
        }
        
        .samling-manager-panel {
            position: relative;
            width: min(520px, 90vw);
            max-height: 80vh;
            background: #ffffff;
            border-radius: 18px;
            box-shadow: 0 25px 60px rgba(15, 23, 42, 0.25);
            padding: 24px 28px;
            display: flex;
            flex-direction: column;
            gap: 18px;
            z-index: 1;
        }
        
        .samling-manager-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        
        .samling-manager-header h2 {
            font-size: 1.25rem;
            color: #111827;
        }
        
        .samling-manager-close {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 10px;
            background: #e2e8f0;
            color: #1f2937;
            font-size: 18px;
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s ease;
        }
        
        .samling-manager-close:hover {
            background: #cbd5f5;
            transform: scale(1.05);
        }
        
        .samling-manager-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            padding-right: 6px;
        }
        
        .samling-manager-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 12px;
            border: none;
            background: #f8fafc;
        }
        
        .samling-name-btn {
            flex: 1;
            border: none;
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 16px;
            font-weight: 600;
            text-align: left;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            color: #1f2937;
        }
        
        .samling-name-input {
            flex: 1;
            border: 2px solid #6366f1;
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 16px;
            font-weight: 600;
            outline: none;
            color: #1f2937;
        }
        
        .samling-color-select {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-weight: 700;
            color: white;
            font-size: 16px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        .samling-color-select:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        }
        
        .samling-delete-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 8px;
            background: #ef4444;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s ease;
        }
        
        .samling-delete-btn:hover {
            background: #dc2626;
            transform: scale(1.05);
        }
        
        .samling-manager-divider {
            height: 1px;
            background: #e2e8f0;
            margin: 8px 0;
        }
        
        .samling-manager-new {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 12px;
            border: none;
            background: #f8fafc;
        }
        
        .samling-manager-new input {
            flex: 1;
            border: none;
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 16px;
            outline: none;
            background: white;
            border: 2px solid #e2e8f0;
        }
        
        .samling-manager-new input:focus {
            outline: none;
            border-color: #e2e8f0;
            box-shadow: none;
        }
        
        .samling-manager-actions {
            display: flex;
            gap: 8px;
        }
        
        .samling-create-btn {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            border: none;
            background: #10b981;
            color: white;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s ease;
        }
        
        .samling-create-btn:hover {
            background: #059669;
            transform: scale(1.05);
        }
        
        .samling-color-picker-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 5001;
        }
        
        .samling-color-picker-modal.show {
            display: flex;
        }
        
        .samling-color-picker {
            background: white;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 25px 60px rgba(15, 23, 42, 0.3);
            max-width: 400px;
            width: 90vw;
        }
        
        .samling-color-picker-header {
            margin-bottom: 16px;
        }
        
        .samling-color-picker-header h3 {
            font-size: 1.1rem;
            color: #111827;
            margin: 0;
        }
        
        .samling-color-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
        }
        
        .samling-color-swatch {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 10px;
            border: 3px solid transparent;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .samling-color-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .samling-color-swatch.selected {
            border-color: #1f2937;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
        }
        
        /* Comparison section needs to be relative for history sidebar positioning */
        .comparison-section {
            position: relative;
        }
    
    /* Touch devices adjustments */
    @media (hover: none) and (pointer: coarse) {
        body { padding: 0px; }
        .header { padding: 16px 24px; padding-top: calc(env(safe-area-inset-top) + 16px); }
        .header h1 { font-size: 2.0em; margin-bottom: 0; }
        .comparison-container { border-radius: 0px; }
        .controls-bar { padding: 8px 12px; gap: 10px; }
        .participant-dropdown { font-size: 13px; padding: 6px 10px; border-radius: 8px; }
        .btn { padding: 6px 12px; font-size: 13px; border-radius: 8px; }
    }
    </style>
</head>
<body>
    <div class="comparison-container">
        <div class="header">
            <div class="nav-controls">
                <button class="nav-toggle-btn" onclick="toggleNavBox()" title="Navigation">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <div class="nav-box" id="navBox">
                    <a href="opstilling_01.html" class="nav-button">Opstilling</a>
                    <a href="dialog_01.html" class="nav-button">Dialog</a>
                    <a href="compare_01.html" class="nav-button">Ligheder</a>
                    <a href="bodymap_01.html" class="nav-button">BodyMap</a>
                    <a href="logbog_01.html" class="nav-button">Logbog</a>
                    <a href="checkin.html" class="nav-button nav-checkin">Check in</a>
                </div>
            </div>
            <h1>Forskelle og ligheder</h1>
        </div>
        
        <div class="controls-bar">
            <div class="dropdown-group">
                <select class="participant-dropdown" id="leftDropdown"></select>
            </div>
            
            <div class="dropdown-group">
                <select class="participant-dropdown" id="rightDropdown"></select>
            </div>
            
            <div class="controls-divider"></div>
            
            <button class="btn" onclick="createNewComparison()" style="background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%); color: white;">Ny Spejling</button>
            <button class="btn random-btn" id="randomBtn" disabled>Random</button>
            <button class="btn clear-btn">Ryd Alt</button>
        </div>
        
        <div class="main-content">
            <div class="comparison-workspace-container">
        <div class="status" id="status">Vælg to dele for at begynde sammenligning</div>
        
        <div class="participants-section">
            <div class="participants-container" id="compareParticipants">
               
			   <div class="participant">
					<div class="participant-circle" id="leftCircle" style="display: none;">
						<button class="color-circle-btn" id="leftPoseBtn" title="Skift pose">P</button>
						<button class="color-circle-btn" id="leftColorBtn" title="Skift farve">C</button>
						<button class="note-circle-btn" id="leftNoteBtn" title="Rediger navn">N</button>
						
						<div class="participant-body">
							<div class="head">
								<span id="leftName"></span>
							</div>
							
							<div class="participant-torso"></div>
							
							<!-- Venstre arm hierarki -->
							<div class="skulder_translate_left">
								<div class="skulder_rotate_left">
									<div class="arm_geo_left">
										<div class="albue_rotate_left">
											<div class="albue_geo_left"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Højre arm hierarki -->
							<div class="skulder_translate_right">
								<div class="skulder_rotate_right">
									<div class="arm_geo_right">
										<div class="albue_rotate_right">
											<div class="albue_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Venstre ben hierarki -->
							<div class="hofte_translate_left">
								<div class="hofte_rotate_left">
									<div class="laar_geo_left">
										<div class="knae_rotate_left">
											<div class="skinneben_geo_left"></div>
										</div>
									</div>
								</div>
							</div>

							<!-- Højre ben hierarki -->
							<div class="hofte_translate_right">
								<div class="hofte_rotate_right">
									<div class="laar_geo_right">
										<div class="knae_rotate_right">
											<div class="skinneben_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
                
                <div class="participant">
					<div class="participant-circle" id="rightCircle" style="display: none;">
						<button class="color-circle-btn" id="rightColorBtn" title="Skift farve">C</button>
						<button class="color-circle-btn" id="rightPoseBtn" title="Skift pose">P</button>
						<button class="note-circle-btn" id="rightNoteBtn" title="Rediger navn">N</button>
						
						<div class="participant-body">
							<div class="head">
								<span id="rightName"></span>
							</div>
							
							<div class="participant-torso"></div>
							
							<!-- Venstre arm hierarki -->
							<div class="skulder_translate_left">
								<div class="skulder_rotate_left">
									<div class="arm_geo_left">
										<div class="albue_rotate_left">
											<div class="albue_geo_left"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Højre arm hierarki -->
							<div class="skulder_translate_right">
								<div class="skulder_rotate_right">
									<div class="arm_geo_right">
										<div class="albue_rotate_right">
											<div class="albue_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Venstre ben hierarki -->
							<div class="hofte_translate_left">
								<div class="hofte_rotate_left">
									<div class="laar_geo_left">
										<div class="knae_rotate_left">
											<div class="skinneben_geo_left"></div>
										</div>
									</div>
								</div>
							</div>

							<!-- Højre ben hierarki -->
							<div class="hofte_translate_right">
								<div class="hofte_rotate_right">
									<div class="laar_geo_right">
										<div class="knae_rotate_right">
											<div class="skinneben_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
						</div>
						
						
                    </div>
                </div>
				
				
				
				
            </div>
        </div>
        
        <div class="comparison-section">
            <div class="comparison-header">
                <h3 style="color: #475569; font-size: 16px;">Sammenligning og Analyse</h3>
            </div>
            <div class="comparison-content" id="comparisonContent">
                <div class="empty-state">
                    <h4 style="margin-bottom: 15px; color: #374151;">Sådan bruger du Sammenlignings-værktøjet:</h4>
                    <p style="margin-bottom: 12px; text-align: left;"><strong>1. Vælg dele:</strong> Brug dropdown-menuerne til at vælge to indre dele du vil sammenligne.</p>
                    <p style="margin-bottom: 12px; text-align: left;"><strong>2. Udfyld fakta:</strong> Indtast grundlæggende information om hver del.</p>
                    <p style="margin-bottom: 12px; text-align: left;"><strong>3. Score egenskaber:</strong> Vurder hvor hver del placerer sig på forskellige skalaer.</p>
                    <p style="margin-bottom: 12px; text-align: left;"><strong>4. Fokuser på ligheder:</strong> Se hvor delene minder om hinanden i stedet for kun at fokusere på forskelle.</p>
                    <p style="margin-top: 15px; font-style: italic; color: #6b7280;">Dette værktøj hjælper med at reducere indre konflikt ved at se nuancer og ligheder mellem dele af dig selv.</p>
                </div>
            </div>
            
            <!-- History Sidebar -->
        </div>
            
            <div class="history-sidebar" id="historySidebar">
                <div class="history-top-bar">
                    <button class="collapse-toggle" onclick="toggleHistorySidebar()" title="Kollaps/udvid historie"><img src="imagefiles/arrow.svg" alt="Toggle"></button>
                </div>
                <div class="history-content">
                    <div class="history-list" id="historyList"></div>
                </div>
                <button class="collapse-toggle collapse-toggle-bottom" onclick="toggleHistorySidebar()" title="Kollaps/udvid historie"><img src="imagefiles/arrow.svg" alt="Toggle"></button>
            </div>
        </div>
    </div>

    <!-- Color Picker Modal -->
    <div class="color-picker-modal" id="colorPickerModal">
        <div class="picker">
            <div class="color-grid" id="colorGrid"></div>
        </div>
    </div>
	
	
	
	<!-- Pose Picker Modal -->
<div class="pose-picker-modal" id="posePickerModal">
    <div class="pose-picker">
        <div class="pose-mirror-section">
            <label class="pose-mirror-label">
                <input type="checkbox" id="posePickerMirror" onchange="togglePosePickerMirror()">
                <span>Spejl</span>
            </label>
        </div>
        <div class="pose-grid" id="poseGrid"></div>
    </div>
</div>

	<!-- Note Overlay -->
	<div class="note-overlay" id="noteOverlay">
		<textarea id="noteTextarea" placeholder="Navn..." maxlength="24"></textarea>
	</div>
	
	<!-- History Item Color Picker Modal -->
	<div class="history-color-picker-modal" id="historyColorPickerModal">
		<div class="history-color-picker">
			<div class="history-color-picker-header">
				<h3>Vælg farve</h3>
			</div>
			<div class="history-color-grid" id="historyColorGrid"></div>
			<button class="history-remove-color-btn" id="historyRemoveColorBtn">Fjern farve</button>
		</div>
	</div>

    <script src="coaching_engine.js"></script>
    <script src="coaching_overlay_complete.js"></script>
    <script>
        // Wait for script to load and then check
        window.addEventListener('load', function() {
            (window.__APP_DEBUG__ && console.log('Page loaded, checking coaching functions...'));
            (window.__APP_DEBUG__ && console.log('openCoachingOverlayFromFile type:', typeof window.openCoachingOverlayFromFile));
            (window.__APP_DEBUG__ && console.log('CoachEngine type:', typeof window.CoachEngine));
            (window.__APP_DEBUG__ && console.log('CoachEngine class:', typeof CoachEngine));
            
            if (typeof openCoachingOverlayFromFile === 'undefined') {
                (window.__APP_DEBUG__ && console.log('Coaching functions not loaded, adding fallback...'));
                // Simple fallback function
                window.openCoachingOverlayFromFile = function(filename) {
                    (window.__APP_DEBUG__ && console.log('Fallback: Opening coaching overlay from file:', filename));
                    if (typeof openCoachingOverlay !== 'undefined') {
                        openCoachingOverlay('myCoachingProject');
                    } else {
                        alert('Coaching overlay system ikke tilgængeligt');
                    }
                };
            } else {
                (window.__APP_DEBUG__ && console.log('Coaching functions loaded successfully!'));
            }
        });
    </script>
    <script>
        // Firebase Configuration (same as other pages)
        const firebaseConfig = {
            apiKey: "AIzaSyCl6ZYtkfYx3kFF9329eGpeazsmJAPMKzA",
            authDomain: "relationer-fe5fe.firebaseapp.com",
            projectId: "relationer-fe5fe",
            storageBucket: "relationer-fe5fe.firebasestorage.app",
            messagingSenderId: "156720560629",
            appId: "1:156720560629:web:1a138e4e89f02a131f88bc",
            measurementId: "G-K5W7J8ZHZG"
        };

        // Initialize Firebase
        let auth, db, currentUser;
        
        // Global cache of all user-related Firestore data (shared via window)
        // {
        //   bodymapData,
        //   dialogData,
        //   opstillingData,
        //   compareData,
        //   logbogData,
        //   forside_checkin_data
        // }
        window.allUserData = window.allUserData || null;
        window.allDataLoadingPromise = window.allDataLoadingPromise || null;
        
        // Flag for UI updates during initial load (not for blocking saves)
        let isInitialLoad = true;

        try {
            firebase.initializeApp(firebaseConfig);
            auth = firebase.auth();
            db = firebase.firestore();
        } catch (error) {
            // If Firebase is already initialized, just get auth and db
            if (error.code === 'app/duplicate-app') {
                auth = firebase.auth();
                db = firebase.firestore();
            } else {
                console.error('Firebase initialization error:', error);
            }
        }

        // Check auth state - create a promise that resolves when auth state is determined
        let authStateReady = false;
        let authStateResolver = null;
        const authStatePromise = new Promise(resolve => {
            authStateResolver = resolve;
        });

        // Load all user data (cached) for this page, shared via window
        // Helper: Get month key from date (YYYY-MM format)
        function getMonthKey(date = null) {
            const d = date ? new Date(date) : new Date();
            if (isNaN(d.getTime())) return null;
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            return `${year}-${month}`;
        }
        
        // Helper: Get months to load based on current date
        // Returns array of month keys: [currentMonth, previousMonth?]
        function getMonthsToLoad() {
            const now = new Date();
            const currentMonthKey = getMonthKey(now);
            const dayOfMonth = now.getDate();
            
            const monthsToLoad = [currentMonthKey];
            
            // If before the 7th, also load previous month
            if (dayOfMonth <= 7) {
                const prevMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                const prevMonthKey = getMonthKey(prevMonth);
                monthsToLoad.push(prevMonthKey);
            }
            
            return monthsToLoad;
        }
        
        // Helper: Load data for specific month from Firestore subcollection
        async function loadMonthData(monthKey, forceRefresh = false) {
            if (!currentUser || !db) return null;
            
            try {
                const userDocRef = db.collection('users').doc(currentUser.uid);
                const monthDocRef = userDocRef.collection('months').doc(monthKey);
                console.log(`🔥 FIRESTORE READ - compare_01.html - loadMonthData(${monthKey})`);
                const doc = await monthDocRef.get();
                if (!doc.exists) return null;
                
                return doc.data() || null;
            } catch (error) {
                console.error(`[LOAD] Error loading month data for ${monthKey}:`, error);
                return null;
            }
        }
        
        // Helper: Merge data from multiple months into flat structure
        function mergeMonthlyData(monthsData) {
            const merged = {
                bodymapData: { dataIndexes: [] },
                dialogData: { dialogs: [] },
                opstillingData: { setups: [] },
                compareData: { comparisons: [] },
                logbogData: []
            };
            
            monthsData.forEach(monthData => {
                if (!monthData) return;
                
                // Merge bodymaps
                if (monthData.bodymaps && monthData.bodymaps.maps && Array.isArray(monthData.bodymaps.maps)) {
                    merged.bodymapData.dataIndexes.push(...monthData.bodymaps.maps);
                }
                
                // Merge dialog
                if (monthData.dialog && Array.isArray(monthData.dialog.dialogs)) {
                    merged.dialogData.dialogs.push(...monthData.dialog.dialogs);
                }
                
                // Merge opstilling
                if (monthData.opstilling && Array.isArray(monthData.opstilling.setups)) {
                    merged.opstillingData.setups.push(...monthData.opstilling.setups);
                }
                
                // Merge compare
                if (monthData.compare && Array.isArray(monthData.compare.comparisons)) {
                    merged.compareData.comparisons.push(...monthData.compare.comparisons);
                }
                
                // Merge logbog
                if (Array.isArray(monthData.logbog)) {
                    merged.logbogData.push(...monthData.logbog);
                }
            });
            
            return merged;
        }
        
        async function loadAllUserData(forceRefresh = false) {
            if (!currentUser || !db) return null;
            
            if (!forceRefresh && window.allUserData) {
                return window.allUserData;
            }
            
            if (!forceRefresh && window.allDataLoadingPromise) {
                return window.allDataLoadingPromise;
            }
            
            window.allDataLoadingPromise = (async () => {
                try {
                    const userDocRef = db.collection('users').doc(currentUser.uid);
                    console.log('🔥 FIRESTORE READ - compare_01.html - loadAllUserData');
                    const doc = await userDocRef.get();
                    const raw = doc.exists ? (doc.data() || {}) : {};
                    
                    // Check if data is in new monthly structure
                    const userData = raw.userData || {};
                    const registreringer = userData.registreringer || {};
                    const hasMonthlyStructure = Object.keys(registreringer).length > 0 || 
                                                 Object.keys(raw).some(key => /^\d{4}-\d{2}$/.test(key));
                    
                    if (hasMonthlyStructure) {
                        // New monthly structure: Load from subcollections
                        // Get months to load: current + previous (if before 7th) + any months with data in registreringer
                        const monthsToLoadSet = new Set(getMonthsToLoad());
                        
                        // NOTE: We do NOT load all months from registreringer or subcollections here
                        // registreringer is only used to show counts in history panel
                        // We only load months from getMonthsToLoad() (current + previous if before 7th)
                        // Older months are loaded on-demand when user expands them in history panel
                        
                        // Check main document for month-based data (e.g., "2025-11", "2025-12")
                        Object.keys(raw).forEach(key => {
                            if (/^\d{4}-\d{2}$/.test(key)) {
                                const monthKey = key;
                                const monthData = raw[monthKey] || {};
                                // Add month if it has compare data
                                if (monthData.compare && Array.isArray(monthData.compare.comparisons) && monthData.compare.comparisons.length > 0) {
                                    monthsToLoadSet.add(monthKey);
                                }
                            }
                        });
                        
                        // Load ALL months in ONE read from subcollections
                        const monthsDataMap = new Map(); // Use Map to merge data from both sources
                        
                        // First, load from main document
                        const monthsToLoad = Array.from(monthsToLoadSet);
                        monthsToLoad.forEach(monthKey => {
                            const monthDataFromMain = raw[monthKey];
                            if (monthDataFromMain) {
                                monthsDataMap.set(monthKey, monthDataFromMain);
                            }
                        });
                        
                        // Then, load from subcollections and merge
                        try {
                            const monthsCollectionRef = userDocRef.collection('months');
                            const monthsSnapshot = await monthsCollectionRef.get();
                            
                            monthsSnapshot.forEach(monthDoc => {
                                const monthKey = monthDoc.id;
                                const monthDataFromSub = monthDoc.data() || {};
                                
                                // Merge with existing data from main document, or use subcollection data
                                if (monthsDataMap.has(monthKey)) {
                                    // Merge: combine data from both sources
                                    const existing = monthsDataMap.get(monthKey);
                                    monthsDataMap.set(monthKey, {
                                        opstilling: monthDataFromSub.opstilling || existing.opstilling,
                                        dialog: monthDataFromSub.dialog || existing.dialog,
                                        compare: monthDataFromSub.compare || existing.compare,
                                        bodymap: monthDataFromSub.bodymap || existing.bodymap,
                                        logbog: monthDataFromSub.logbog || existing.logbog
                                    });
                                } else {
                                    monthsDataMap.set(monthKey, monthDataFromSub);
                                }
                            });
                        } catch (error) {
                            console.error(`[DEBUG] Error loading subcollections:`, error);
                        }
                        
                        // Convert Map to array for mergeMonthlyData, preserving order from monthsToLoad
                        const monthsData = monthsToLoad.map(monthKey => monthsDataMap.get(monthKey)).filter(m => m !== undefined);
                        const merged = mergeMonthlyData(monthsData);
                        
                        // Fallback to old structure if no data found in subcollections
                        let compareData = merged.compareData.comparisons.length > 0 ? merged.compareData : null;
                        if (!compareData && raw.compareData && Array.isArray(raw.compareData.comparisons) && raw.compareData.comparisons.length > 0) {
                            compareData = raw.compareData;
                        }
                        
                        // Update registreringer based on actual loaded data if missing or incorrect
                        if (compareData && Array.isArray(compareData.comparisons)) {
                            const comparisonsByMonth = {};
                            compareData.comparisons.forEach(comparison => {
                                const timestamp = comparison.timestamp || comparison.updated || new Date().toISOString();
                                const monthKey = getMonthKey(timestamp);
                                if (monthKey) {
                                    if (!comparisonsByMonth[monthKey]) {
                                        comparisonsByMonth[monthKey] = 0;
                                    }
                                    comparisonsByMonth[monthKey]++;
                                }
                            });
                            
                            // Update registreringer for all months with comparisons
                            for (const [monthKey, count] of Object.entries(comparisonsByMonth)) {
                                const monthReg = registreringer[monthKey];
                                const currentCount = monthReg && typeof monthReg === 'object' ? parseInt(monthReg.compare || '0', 10) : 0;
                                if (currentCount !== count) {
                                    await updateRegistreringer(monthKey, 'compare', count);
                                    registreringer[monthKey] = registreringer[monthKey] || {};
                                    registreringer[monthKey].compare = String(count);
                                }
                            }
                        }
                        
                        const data = {
                            bodymapData: merged.bodymapData.dataIndexes.length > 0 ? merged.bodymapData : null,
                            dialogData: merged.dialogData.dialogs.length > 0 ? merged.dialogData : null,
                            opstillingData: merged.opstillingData.setups.length > 0 ? merged.opstillingData : null,
                            compareData: compareData,
                            logbogData: merged.logbogData.length > 0 ? merged.logbogData : null,
                            userData: userData,
                            registreringer: registreringer,
                            loadedMonths: monthsToLoad
                        };
                        
                        window.allUserData = data;
                        return data;
                    } else {
                        // Old structure (backward compatibility)
                        const data = {
                            bodymapData: raw.bodymapData || null,
                            dialogData: raw.dialogData || null,
                            opstillingData: raw.opstillingData || null,
                            compareData: raw.compareData || null,
                            logbogData: Array.isArray(raw.logbogData) ? raw.logbogData : null,
                            forside_checkin_data: Array.isArray(raw.forside_checkin_data) ? raw.forside_checkin_data : null
                        };
                        window.allUserData = data;
                        return data;
                    }
                } catch (error) {
                    console.error('[LOAD] Error loading all user data in compare_01.html:', error);
                    window.allUserData = null;
                    return null;
                } finally {
                    window.allDataLoadingPromise = null;
                }
            })();
            
            return window.allDataLoadingPromise;
        }
        
        // Load compareData from Firestore via cached user document
        async function loadCompareDataFromFirestore() {
            if (!currentUser || !db) return null;
            
            try {
                const data = await loadAllUserData();
                return data ? data.compareData || null : null;
            } catch (error) {
                console.error('[LOAD] Error:', error);
                return null;
            }
        }

        // Save compareData to Firestore
        // Helper: Update registreringer with count for a specific data type and month
        async function updateRegistreringer(monthKey, dataType, count) {
            if (!currentUser || !db) return;
            
            try {
                const userDocRef = db.collection('users').doc(currentUser.uid);
                const doc = await userDocRef.get();
                const raw = doc.exists ? (doc.data() || {}) : {};
                const userData = raw.userData || {};
                const registreringer = userData.registreringer || {};
                
                // Initialize month object if it doesn't exist
                if (!registreringer[monthKey]) {
                    registreringer[monthKey] = {};
                }
                
                // Update count for this data type
                if (count > 0) {
                    registreringer[monthKey][dataType] = String(count);
                } else {
                    // Remove data type from month if count is 0
                    delete registreringer[monthKey][dataType];
                }
                
                // Remove month from registreringer if it has no data types left
                if (Object.keys(registreringer[monthKey]).length === 0) {
                    delete registreringer[monthKey];
                }
                
                await userDocRef.set({
                    userData: {
                        ...userData,
                        registreringer: registreringer
                    },
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
                
                // Update cache
                if (window.allUserData) {
                    window.allUserData.registreringer = registreringer;
                }
            } catch (error) {
                console.error('[SAVE] Error updating registreringer:', error);
            }
        }
        
        async function saveCompareDataToFirestore() {
            if (!currentUser || !db) return false;
            if (!CompareData) return false;
            
            // 🛡️ CRITICAL SAFETY CHECK: Prevent data loss from empty saves
            if (!CompareData.comparisons || !Array.isArray(CompareData.comparisons) || CompareData.comparisons.length === 0) {
                console.error('🚨 CRITICAL: Attempted to save empty compareData!');
                console.error('This would DELETE ALL COMPARISONS. Save blocked!');
                console.trace();
                alert('FEJL: Forsøgte at gemme tom compare data! Dette er blokeret for at beskytte dine data. Reload siden.');
                return false;
            }
            
            CompareData.updated = new Date().toISOString();
            
            try {
                const userDocRef = db.collection('users').doc(currentUser.uid);
                const doc = await userDocRef.get();
                const raw = doc.exists ? (doc.data() || {}) : {};
                
                // Check if data is in new monthly structure
                const userData = raw.userData || {};
                const registreringer = userData.registreringer || {};
                const hasMonthlyStructure = Object.keys(registreringer).length > 0 || 
                                             Object.keys(raw).some(key => /^\d{4}-\d{2}$/.test(key));
                
                if (hasMonthlyStructure) {
                    // New monthly structure: Group comparisons by month and save to subcollections
                    const comparisonsByMonth = {};
                    CompareData.comparisons.forEach(comparison => {
                        if (!comparison.timestamp && !comparison.updated) {
                            comparison.timestamp = new Date().toISOString();
                            comparison.updated = comparison.timestamp;
                        }
                        const timestamp = comparison.timestamp || comparison.updated || new Date().toISOString();
                        const monthKey = getMonthKey(timestamp);
                        if (!monthKey) return;
                        
                        if (!comparisonsByMonth[monthKey]) {
                            comparisonsByMonth[monthKey] = [];
                        }
                        comparisonsByMonth[monthKey].push(comparison);
                    });
                    
                    // Save each month to its subcollection
                    for (const [monthKey, monthComparisons] of Object.entries(comparisonsByMonth)) {
                        const monthDocRef = userDocRef.collection('months').doc(monthKey);
                        const existingMonthData = await monthDocRef.get();
                        const monthData = existingMonthData.exists ? (existingMonthData.data() || {}) : {};
                        
                        monthData.compare = {
                            comparisons: monthComparisons,
                            version: CompareData.version || '2.0',
                            updated: CompareData.updated
                        };
                        
                        await monthDocRef.set(monthData, { merge: true });
                        // NOTE: registreringer is updated only when comparisons are created or deleted, not on every save
                    }
                    
                    // Update cache
                    if (window.allUserData) {
                        window.allUserData.compareData = CompareData;
                    }
                    
                    console.log('[SAVE] Success - saved to monthly structure');
                    return true;
                } else {
                    // Old structure (backward compatibility)
                    await userDocRef.set({
                        compareData: CompareData,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });
                    
                    // Update cache directly without reading from Firestore
                    if (window.allUserData) {
                        window.allUserData.compareData = CompareData;
                    }
                    
                    console.log('[SAVE] Success - saved to old structure');
                    return true;
                }
            } catch (error) {
                console.error('[SAVE] Error:', error);
                return false;
            }
        }

        let leftColor = null;
        let rightColor = null;
        let leftLightColor = null;
        let rightLightColor = null;
        let currentColorTarget = null;
        let currentColorSide = null;
        let currentStep = 1;
        let leftScores = {};
        let rightScores = {};
		let currentPosePart = null;
		let comparisonNotes = ''; // Text field content
		
	// CompareData structure (flat, no collections)
	const COMPARE_STORAGE_KEY = 'compareData';
	let CompareData = null; // { version, updated, activeComparisonId, comparisons: [...] }
	let comparisonCounter = 1;
	
		// Color presets for collections
		const COMPARE_COLLECTION_COLOR_PRESETS = [
			'#ef4444', '#f97316', '#fbbf24', '#10b981', '#14b8a6', '#0ea5e9',
			'#3b82f6', '#6366f1', '#a855f7', '#ec4899', '#f472b6', '#94a3b8'
		];
		
		// Samling manager state
		let samlingManagerOverlayEl = null;
		let samlingManagerListEl = null;
		let newSamlingNameInputEl = null;
		let newSamlingColorBtnEl = null;
		let samlingColorPickerModalEl = null;
		let samlingColorGridEl = null;
		let samlingColorPickerTarget = null;
		let newSamlingDraftColor = COMPARE_COLLECTION_COLOR_PRESETS[0];
		let newSamlingDraftName = '';
		let newSamlingColorDirty = false;
		
		// History sidebar state
		let historySidebarCollapsed = true; // Default to collapsed
		
		// Helper functions for colors
		function hexToRgba(hex, alpha) {
			if (!hex) {
				return `rgba(232, 220, 198, ${alpha})`;
			}
			const normalized = hex.replace('#', '');
			if (normalized.length === 3) {
				const r = parseInt(normalized[0] + normalized[0], 16);
				const g = parseInt(normalized[1] + normalized[1], 16);
				const b = parseInt(normalized[2] + normalized[2], 16);
				return `rgba(${r}, ${g}, ${b}, ${alpha})`;
			}
			if (normalized.length === 6) {
				const r = parseInt(normalized.substring(0, 2), 16);
				const g = parseInt(normalized.substring(2, 4), 16);
				const b = parseInt(normalized.substring(4, 6), 16);
				return `rgba(${r}, ${g}, ${b}, ${alpha})`;
			}
			return hex;
		}
		
		function lightenHex(hex, amount = 0.5) {
			if (!hex) return '#f2e7d2';
			const normalized = hex.replace('#', '');
			const expand = normalized.length === 3
				? normalized.split('').map(ch => ch + ch).join('')
				: normalized.padEnd(6, '0');
			const r = parseInt(expand.substring(0, 2), 16);
			const g = parseInt(expand.substring(2, 4), 16);
			const b = parseInt(expand.substring(4, 6), 16);
			const clampAmount = Math.max(0, Math.min(1, amount));
			const newR = Math.round(r + (255 - r) * clampAmount);
			const newG = Math.round(g + (255 - g) * clampAmount);
			const newB = Math.round(b + (255 - b) * clampAmount);
			return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
		}

		function darkenHex(hex, amount = 0.5) {
			if (!hex) return '#000000';
			const normalized = hex.replace('#', '');
			const expand = normalized.length === 3
				? normalized.split('').map(ch => ch + ch).join('')
				: normalized.padEnd(6, '0');
			const r = parseInt(expand.substring(0, 2), 16);
			const g = parseInt(expand.substring(2, 4), 16);
			const b = parseInt(expand.substring(4, 6), 16);
			const clampAmount = Math.max(0, Math.min(1, amount));
			const newR = Math.round(r * (1 - clampAmount));
			const newG = Math.round(g * (1 - clampAmount));
			const newB = Math.round(b * (1 - clampAmount));
			return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
		}
		
		// Standard farve for alle history items (comparisons)
		const DEFAULT_HISTORY_COLOR = '#b8735e'; // Varm rødlig brun som standard
		
		// Color presets for history items
		const HISTORY_COLOR_PRESETS = [
			'#ef4444', '#f97316', '#fbbf24', '#10b981', '#14b8a6', '#0ea5e9',
			'#3b82f6', '#6366f1', '#a855f7', '#ec4899', '#f472b6', '#94a3b8'
		];
		
		let historyColorPickerTarget = null; // { comparisonId } for the target comparison
		let historyColorPickerModal = null;
		let historyColorPickerGrid = null;
		
		/**
		 * Læser brugerens timezone fra userData (indexuserData i localStorage)
		 * Fallback hierarki:
		 * 1. userData.timezone
		 * 2. Browser's timezone (Intl API)
		 * 3. 'Europe/Copenhagen' (default)
		 */
		function getUserTimezone() {
			try {
				// 1. Prøv at læse fra userData
				const userDataStr = localStorage.getItem('indexuserData');
				if (userDataStr) {
					const userData = JSON.parse(userDataStr);
					if (userData.timezone && isValidTimezone(userData.timezone)) {
						return userData.timezone;
					}
				}
			} catch (e) {
				console.warn('Kunne ikke læse timezone fra userData:', e);
			}
			
			// 2. Fallback til browser's timezone
			try {
				const browserTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
				if (browserTimezone && isValidTimezone(browserTimezone)) {
					return browserTimezone;
				}
			} catch (e) {
				console.warn('Kunne ikke læse browser timezone:', e);
			}
			
			// 3. Ultimate fallback
			return 'Europe/Copenhagen';
		}

		/**
		 * Validerer om en timezone string er gyldig
		 */
		function isValidTimezone(tz) {
			if (!tz || typeof tz !== 'string') return false;
			try {
				Intl.DateTimeFormat(undefined, { timeZone: tz });
				return true;
			} catch (e) {
				return false;
			}
		}

		/**
		 * Konverterer Date eller ISO string til lokal dato (YYYY-MM-DD) i brugerens timezone
		 * @param {Date|string|null} date - Dato at konvertere (default: nu)
		 * @returns {string|null} - Dato i YYYY-MM-DD format eller null ved fejl
		 */
		function getLocalDateKey(date = null) {
			const d = date ? new Date(date) : new Date();
			if (isNaN(d.getTime())) return null;
			
			const timezone = getUserTimezone();
			
			// Konverter til lokal tid ved at formatere med da-DK locale og brugerens timezone
			const localDateStr = d.toLocaleDateString('da-DK', {
				timeZone: timezone,
				year: 'numeric',
				month: '2-digit',
				day: '2-digit'
			});
			
			// Format er "DD.MM.YYYY" - konverter til "YYYY-MM-DD"
			const [day, month, year] = localDateStr.split('.');
			return `${year}-${month}-${day}`;
		}

		function formatDkDate(dateStr) {
			// Convert ISO date to DD-MM-YYYY for display
			if (typeof dateStr === 'string' && /^\d{4}-\d{2}-\d{2}/.test(dateStr)) {
				const datePart = dateStr.split('T')[0];
				const [y, m, d] = datePart.split('-');
				return `${d}-${m}-${y}`;
			}
			return dateStr || '';
		}
		
		function truncateName(name) {
			if (!name || typeof name !== 'string') return '';
			if (name.length > 20) {
				return name.substring(0, 20) + '..';
			}
			return name;
		}
		
		// CompareData functions
		async function loadCompareData() {
			if (!currentUser || !db) {
				console.error('[LOAD] User not logged in - cannot load data');
				return null;
			}
			
			const firestoreData = await loadCompareDataFromFirestore();
			return firestoreData;
		}
		
		async function saveCompareDataToLocalStorage() {
			
			if (!currentUser || !db) {
				console.error('[SAVE] User not logged in - cannot save data');
				return false;
			}
			
			try {
				if (!CompareData) return false;
				await saveCompareDataToFirestore();
				return true;
			} catch (error) {
				console.error('Error in saveCompareDataToLocalStorage:', error);
				return false;
			}
		}
		
	async function ensureDefaultCompareData() {
		let dataWasCreated = false;
		
		if (!CompareData || !Array.isArray(CompareData.comparisons)) {
			CompareData = {
				version: '2.0',
				updated: new Date().toISOString(),
				activeComparisonId: 1,
				comparisons: []
			};
			dataWasCreated = true;
		}
		if (!Array.isArray(CompareData.comparisons) || CompareData.comparisons.length === 0) {
			const now = new Date().toISOString();
			const initialComparison = {
				id: 1,
				name: 'Sammenligning 1',
				color: DEFAULT_HISTORY_COLOR,
				timestamp: now,
				updated: now,
				notes: '',
				participants: {
					left: {
					name: 'Venstre',
					color: '#3b82f6',
					pose: '',
					flipped: false
				},
					right: {
					name: 'Højre',
					color: '#ef4444',
					pose: '',
					flipped: false
					}
				},
				traitNames: [],
				leftScores: {},
				rightScores: {},
			};
			CompareData.comparisons = [initialComparison];
			CompareData.activeComparisonId = 1;
			dataWasCreated = true;
		}
		// Ensure all comparisons have timestamps and colors
		CompareData.comparisons.forEach((comparison, idx) => {
			if (!comparison.timestamp) {
				comparison.timestamp = comparison.updated || new Date().toISOString();
			}
			if (!comparison.updated) {
				comparison.updated = comparison.timestamp || new Date().toISOString();
			}
			if (!comparison.color) {
				comparison.color = DEFAULT_HISTORY_COLOR;
			}
		});
		// Only save if we actually created new data structure AND not during initial load
		// This prevents overwriting existing Firestore data with empty data on page load
		// Don't save during data creation - it's a load operation
	}
		
	function getActiveComparison() {
		if (!CompareData || !Array.isArray(CompareData.comparisons)) return null;
		return CompareData.comparisons.find(c => c.id === CompareData.activeComparisonId) || CompareData.comparisons[0] || null;
	}
		
		// Debounce timeout for comparison notes
		let comparisonNotesDebounceTimeout = null;

		async function updateComparisonNotes(value) {
			comparisonNotes = value || '';
			
			// Clear previous timeout
			if (comparisonNotesDebounceTimeout) {
				clearTimeout(comparisonNotesDebounceTimeout);
			}
			
			// Debounce: wait 2 seconds after last input
			comparisonNotesDebounceTimeout = setTimeout(async () => {
				await syncCurrentWorkspaceToActiveComparison();
				comparisonNotesDebounceTimeout = null;
			}, 2000);
		}
		
		async function syncCurrentWorkspaceToActiveComparison() {
			
			
			if (!CompareData) return;
			const comparison = getActiveComparison();
			if (!comparison) return;
			
			// Get active trait names (not indices)
			const activeTraits = getActiveTraits();
			comparison.traitNames = activeTraits.map(({ trait }) => trait);
			
			// Get participant data
			const leftNameEl = document.getElementById('leftName');
			const rightNameEl = document.getElementById('rightName');
			const leftDropdown = document.getElementById('leftDropdown');
			const rightDropdown = document.getElementById('rightDropdown');
			const leftPoseDropdown = document.getElementById('leftPose');
			const rightPoseDropdown = document.getElementById('rightPose');
			const leftMirror = document.getElementById('leftMirror');
			const rightMirror = document.getElementById('rightMirror');
			
			// Get pose from data-pose attribute (most reliable) or fallback to dropdown
			const leftParticipant = document.querySelector('#leftCircle')?.closest('.participant');
			const rightParticipant = document.querySelector('#rightCircle')?.closest('.participant');
			
			// Get pose index from data-pose or dropdown, then convert to pose name
			let leftPoseIndex = leftParticipant?.getAttribute('data-pose') || (leftPoseDropdown ? leftPoseDropdown.value : '');
			let rightPoseIndex = rightParticipant?.getAttribute('data-pose') || (rightPoseDropdown ? rightPoseDropdown.value : '');
			
			// Convert pose index to pose name (like dialog does)
			let leftPoseName = '';
			if (leftPoseIndex !== '' && leftPoseIndex !== null) {
				const poseIdx = parseInt(leftPoseIndex, 10);
				if (!Number.isNaN(poseIdx) && poseLibrary[poseIdx]) {
					leftPoseName = poseLibrary[poseIdx].name;
				}
			}
			
			let rightPoseName = '';
			if (rightPoseIndex !== '' && rightPoseIndex !== null) {
				const poseIdx = parseInt(rightPoseIndex, 10);
				if (!Number.isNaN(poseIdx) && poseLibrary[poseIdx]) {
					rightPoseName = poseLibrary[poseIdx].name;
				}
			}
			
			// Get flipped state from checkbox or data-mirror attribute (checkbox is most reliable)
			const leftFlipped = leftMirror ? leftMirror.checked : (leftParticipant?.getAttribute('data-mirror') === 'true');
			const rightFlipped = rightMirror ? rightMirror.checked : (rightParticipant?.getAttribute('data-mirror') === 'true');
			
			comparison.participants.left = {
				name: leftNameEl ? leftNameEl.textContent.trim() : 'Venstre',
				color: leftColor || '#3b82f6',
				pose: leftPoseName || '',
				flipped: leftFlipped
			};
			
			comparison.participants.right = {
				name: rightNameEl ? rightNameEl.textContent.trim() : 'Højre',
				color: rightColor || '#ef4444',
				pose: rightPoseName || '',
				flipped: rightFlipped
			};
			
			// Get scores
			comparison.leftScores = { ...leftScores };
			comparison.rightScores = { ...rightScores };
			
			// Get notes
			comparison.notes = comparisonNotes || '';
			
			const now = new Date().toISOString();
			comparison.updated = now;
			if (!comparison.timestamp) {
				comparison.timestamp = now;
			}
			await saveCompareDataToLocalStorage();
		}
		
		async function loadComparisonFromCompareData(comparison) {
			if (!comparison) return;
			
			try {
				
				// Load participants
			const leftCircle = document.getElementById('leftCircle');
			const rightCircle = document.getElementById('rightCircle');
			
			if (comparison.participants.left) {
				const leftNameEl = document.getElementById('leftName');
				if (leftNameEl) leftNameEl.textContent = comparison.participants.left.name || 'Venstre';
				leftColor = comparison.participants.left.color || '#3b82f6';
				leftLightColor = lightenColor(leftColor, 0.6);
				if (leftCircle && !isInitialLoad) {
					leftCircle.style.display = 'flex';
					const head = leftCircle.querySelector('.head');
					if (head) {
						head.style.background = `linear-gradient(135deg, ${leftColor}, ${leftColor})`;
					}
					updateBodyColors('left', leftColor);
				}
				const leftMirror = document.getElementById('leftMirror');
				if (leftMirror) {
					leftMirror.checked = comparison.participants.left.flipped || false;
				}
				const leftParticipant = document.querySelector('#leftCircle').closest('.participant');
				if (leftParticipant) {
					leftParticipant.setAttribute('data-mirror', String(comparison.participants.left.flipped || false));
				}
				// Apply pose using pose name (like dialog does)
				if (comparison.participants.left.pose) {
					applyParticipantPose('left', comparison.participants.left.pose, comparison.participants.left.flipped || false);
				} else {
					// Reset to default pose if no pose is set
					if (leftParticipant) {
						leftParticipant.removeAttribute('data-pose');
					}
					resetPose('left');
				}
			} else {
				// Default left participant
				const leftNameEl = document.getElementById('leftName');
				if (leftNameEl) leftNameEl.textContent = 'Venstre';
				leftColor = '#3b82f6';
				leftLightColor = lightenColor(leftColor, 0.6);
				if (leftCircle && !isInitialLoad) {
					leftCircle.style.display = 'flex';
					const head = leftCircle.querySelector('.head');
					if (head) {
						head.style.background = `linear-gradient(135deg, ${leftColor}, ${leftColor})`;
					}
					updateBodyColors('left', leftColor);
				}
			}
			
			if (comparison.participants.right) {
				const rightNameEl = document.getElementById('rightName');
				if (rightNameEl) rightNameEl.textContent = comparison.participants.right.name || 'Højre';
				rightColor = comparison.participants.right.color || '#ef4444';
				rightLightColor = lightenColor(rightColor, 0.6);
				if (rightCircle && !isInitialLoad) {
					rightCircle.style.display = 'flex';
					const head = rightCircle.querySelector('.head');
					if (head) {
						head.style.background = `linear-gradient(135deg, ${rightColor}, ${rightColor})`;
					}
					updateBodyColors('right', rightColor);
				}
				const rightMirror = document.getElementById('rightMirror');
				if (rightMirror) {
					rightMirror.checked = comparison.participants.right.flipped || false;
				}
				const rightParticipant = document.querySelector('#rightCircle').closest('.participant');
				if (rightParticipant) {
					rightParticipant.setAttribute('data-mirror', String(comparison.participants.right.flipped || false));
				}
				// Apply pose using pose name (like dialog does)
				if (comparison.participants.right.pose) {
					applyParticipantPose('right', comparison.participants.right.pose, comparison.participants.right.flipped || false);
				} else {
					// Reset to default pose if no pose is set
					if (rightParticipant) {
						rightParticipant.removeAttribute('data-pose');
					}
					resetPose('right');
				}
			} else {
				// Default right participant
				const rightNameEl = document.getElementById('rightName');
				if (rightNameEl) rightNameEl.textContent = 'Højre';
				rightColor = '#ef4444';
				rightLightColor = lightenColor(rightColor, 0.6);
				if (rightCircle && !isInitialLoad) {
					rightCircle.style.display = 'flex';
					const head = rightCircle.querySelector('.head');
					if (head) {
						head.style.background = `linear-gradient(135deg, ${rightColor}, ${rightColor})`;
					}
					updateBodyColors('right', rightColor);
				}
			}
			
			// Load trait names and set active traits
			if (Array.isArray(comparison.traitNames) && comparison.traitNames.length > 0) {
				// Find indices for trait names
				const traitIndices = comparison.traitNames.map(traitName => {
					return defaultTraits.findIndex(t => 
						(t.left === traitName.left && t.right === traitName.right) ||
						JSON.stringify(t) === JSON.stringify(traitName)
					);
				}).filter(idx => idx >= 0);
				
				if (traitIndices.length > 0) {
					activeTraitIndices = traitIndices.slice(0, ACTIVE_TRAIT_COUNT);
				}
			}
			
			// Load scores
			leftScores = comparison.leftScores ? { ...comparison.leftScores } : {};
			rightScores = comparison.rightScores ? { ...comparison.rightScores } : {};
			
			// Load notes
			comparisonNotes = comparison.notes || '';
			const notesTextarea = document.getElementById('comparisonNotes');
			if (notesTextarea) {
				notesTextarea.value = comparisonNotes;
			}
			
			// Update slider colors
			updateSliderColors();
			
			// Update UI
			updateComparisonView();
			
			return true;
		} catch (err) {
			console.error('[LOAD] Load failed:', err);
			return false;
		}
	}
		
		// ===== HISTORY SIDEBAR FUNCTIONS =====
		
		// Track which months are expanded (by month key like "2024-11")
		const expandedMonths = new Set();
		
		// Helper: Load month on-demand and merge with existing data
		async function loadMonthOnDemand(monthKey) {
			if (!currentUser || !db) return;
			
			// Check if month is already loaded
			if (window.allUserData && window.allUserData.loadedMonths && 
				window.allUserData.loadedMonths.includes(monthKey)) {
				return; // Already loaded
			}
			
			try {
				// Load month data from subcollection
				const monthData = await loadMonthData(monthKey);
				if (!monthData || !monthData.compare || !Array.isArray(monthData.compare.comparisons)) {
					return;
				}
				
				// Merge with existing CompareData
				if (!CompareData) {
					CompareData = {
						version: '2.0',
						updated: new Date().toISOString(),
						activeComparisonId: null,
						comparisons: []
					};
				}
				if (!Array.isArray(CompareData.comparisons)) {
					CompareData.comparisons = [];
				}
				
				// Add comparisons from this month (avoid duplicates by ID)
				const existingComparisonIds = new Set(CompareData.comparisons.map(c => c.id));
				monthData.compare.comparisons.forEach(comparison => {
					if (!existingComparisonIds.has(comparison.id)) {
						CompareData.comparisons.push(comparison);
					}
				});
				
				// Update loadedMonths in cache
				if (!window.allUserData) {
					window.allUserData = {};
				}
				if (!window.allUserData.loadedMonths) {
					window.allUserData.loadedMonths = [];
				}
				if (!window.allUserData.loadedMonths.includes(monthKey)) {
					window.allUserData.loadedMonths.push(monthKey);
				}
				
				console.log(`[LOAD] Loaded month ${monthKey} on-demand for compare`);
			} catch (error) {
				console.error(`[LOAD] Error loading month ${monthKey} on-demand:`, error);
			}
		}
		
	function getAllComparisonsSorted() {
		if (!CompareData || !Array.isArray(CompareData.comparisons)) return [];
		const allComparisons = [];
		CompareData.comparisons.forEach(comparison => {
			if (!comparison.timestamp && comparison.updated) {
				comparison.timestamp = comparison.updated;
			} else if (!comparison.timestamp) {
				comparison.timestamp = new Date().toISOString();
			}
			allComparisons.push({
				comparison
			});
		});
		return allComparisons.sort((a, b) => {
			const tsA = a.comparison.timestamp || '';
			const tsB = b.comparison.timestamp || '';
			return tsB.localeCompare(tsA);
		});
	}
		
	function getFilteredSortedComparisons() {
		return getAllComparisonsSorted();
	}
		
	
		async function renderHistory() {
			const listEl = document.getElementById('historyList');
			if (!listEl) return;
			listEl.innerHTML = '';
			
			const filtered = getFilteredSortedComparisons();
			
			// Group comparisons by month
			const monthGroups = {};
			filtered.forEach(({ comparison }) => {
				const timestamp = comparison.timestamp || comparison.updated || new Date().toISOString();
				const monthKey = getMonthKey(timestamp);
				if (!monthKey) return;
				
				if (!monthGroups[monthKey]) {
					monthGroups[monthKey] = [];
				}
				monthGroups[monthKey].push(comparison);
			});
			
			// Get registreringer to show all available months
			let allAvailableMonths = [];
			if (currentUser && db) {
				try {
					const userDocRef = db.collection('users').doc(currentUser.uid);
					const doc = await userDocRef.get();
					if (doc.exists) {
						const raw = doc.data() || {};
						const userData = raw.userData || {};
						const registreringer = userData.registreringer || {};
						// Get months that have compare data
						allAvailableMonths = Object.keys(registreringer)
							.filter(monthKey => {
								const monthReg = registreringer[monthKey];
								if (monthReg && typeof monthReg === 'object') {
									// New structure: { compare: "3", ... }
									return monthReg.compare && parseInt(monthReg.compare, 10) > 0;
								}
								return false;
							})
							.sort((a, b) => b.localeCompare(a));
					}
				} catch (error) {
					console.error('[LOAD] Error loading registreringer:', error);
				}
			}
			
			// Get current date info
			const now = new Date();
			const currentMonthKey = getMonthKey(now);
			const dayOfMonth = now.getDate();
			
			// Calculate previous month key
			const prevMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
			const prevMonthKey = getMonthKey(prevMonth);
			
			// Combine loaded months with available months from registreringer
			const allMonthKeys = new Set([...Object.keys(monthGroups), ...allAvailableMonths]);
			const sortedMonthKeys = Array.from(allMonthKeys).sort((a, b) => b.localeCompare(a));
			
			// Determine which months should show expanded by default
			const autoExpandedMonths = new Set([currentMonthKey]);
			if (dayOfMonth <= 7) {
				autoExpandedMonths.add(prevMonthKey);
			}
			
			// Render each month group
			for (const monthKey of sortedMonthKeys) {
				const monthComparisons = monthGroups[monthKey] || [];
				const isCurrentOrGracePeriod = autoExpandedMonths.has(monthKey);
				const isExpanded = isCurrentOrGracePeriod || expandedMonths.has(monthKey);
				
				// Get count from registreringer if comparisons not loaded yet
				let comparisonCount = monthComparisons.length;
				if (comparisonCount === 0 && currentUser && db) {
					try {
						const userDocRef = db.collection('users').doc(currentUser.uid);
						const doc = await userDocRef.get();
						if (doc && doc.exists) {
							const raw = doc.data() || {};
							const userData = raw.userData || {};
							const registreringer = userData.registreringer || {};
							const monthReg = registreringer[monthKey];
							if (monthReg) {
								if (typeof monthReg === 'object') {
									// New structure: { compare: "3", ... }
									const countStr = monthReg.compare;
									if (countStr) {
										comparisonCount = parseInt(countStr, 10) || 0;
									}
								} else if (typeof monthReg === 'string') {
									// Old structure: "3" (backward compatibility)
									comparisonCount = parseInt(monthReg, 10) || 0;
								}
							}
						}
					} catch (error) {
						// Ignore errors
					}
				}
				
				// For non-current months, show a collapsible header
				if (!isCurrentOrGracePeriod) {
					const monthHeader = document.createElement('div');
					monthHeader.className = 'log-history-month-header' + (isExpanded ? ' expanded' : '');
					monthHeader.dataset.monthKey = monthKey;
					
					// Parse month for display
					const [year, month] = monthKey.split('-');
					const monthDate = new Date(parseInt(year), parseInt(month) - 1, 1);
					const monthName = monthDate.toLocaleDateString('da-DK', { month: 'short' }).replace('.', '');
					const capitalizedMonth = monthName.charAt(0).toUpperCase() + monthName.slice(1);
					
					monthHeader.innerHTML = `
						<span class="log-history-month-title">${capitalizedMonth} ${year}</span>
						<span class="log-history-month-count">${comparisonCount} sammenligninger</span>
						<span class="log-history-month-arrow">${isExpanded ? '▼' : '▶'}</span>
					`;
					
					monthHeader.addEventListener('click', async () => {
						// Remember header position relative to viewport before re-render
						const headerRect = monthHeader.getBoundingClientRect();
						const listRect = listEl.getBoundingClientRect();
						const offsetFromListTop = headerRect.top - listRect.top;
						
						if (expandedMonths.has(monthKey)) {
							expandedMonths.delete(monthKey);
						} else {
							expandedMonths.add(monthKey);
							// Load month on-demand if not already loaded
							await loadMonthOnDemand(monthKey);
							// Reload CompareData after loading month
							await loadCompareData();
						}
						
						// Store scroll restore info globally so renderHistory can use it
						window._monthScrollRestore = {
							monthKey: monthKey,
							offsetFromListTop: offsetFromListTop
						};
						
						// Re-render with updated data
						await renderHistory();
					});
					
					listEl.appendChild(monthHeader);
				}
				
				// Only render comparisons if expanded
				if (!isExpanded) continue;
				
				monthComparisons.forEach(comparison => {
				const item = document.createElement('div');
				const isActive = comparison.id === CompareData.activeComparisonId;
				item.className = `history-item ${isActive ? 'active' : ''}`;
				
				// Set simple background color (not based on collection)
				const comparisonColor = comparison.color || DEFAULT_HISTORY_COLOR;
				const baseBackground = lightenHex(comparisonColor, isActive ? 0.35 : 0.7);
				item.style.backgroundColor = baseBackground;
				item.style.color = '#1f2937';
				item.style.borderColor = isActive ? comparisonColor : 'transparent';
				
				const titleDiv = document.createElement('div');
				titleDiv.className = 'history-item-title';
				// Set background color to comparison's custom color or default
				titleDiv.style.backgroundColor = comparisonColor;
				titleDiv.style.color = '#ffffff';
				
				const dateInput = document.createElement('input');
				dateInput.type = 'text';
				dateInput.className = 'history-item-date';
				dateInput.value = comparison.name || 'Sammenligning';
				dateInput.readOnly = !isActive;
				dateInput.setAttribute('data-comparison-id', comparison.id);
			dateInput.addEventListener('focus', (e) => {
				// Check current active state
				const currentlyActive = comparison.id === CompareData.activeComparisonId;
				// If not active, prevent focus and activate item instead
				if (!currentlyActive) {
					e.preventDefault();
					e.stopPropagation();
					// Activate the item (first click behavior)
					CompareData.activeComparisonId = comparison.id;
						loadComparisonFromCompareData(comparison);
						renderHistory();
						updateHistoryNavState();
						return;
					}
					// If active, allow normal focus for editing
				});
				
			// Textarea touch handler for mobile - allow direct focus on touch
			dateInput.addEventListener('touchend', (e) => {
				// Check current active state
				const currentlyActive = comparison.id === CompareData.activeComparisonId;
				
				if (!currentlyActive) {
					// If not active, activate first, then focus
					e.stopPropagation();
					e.preventDefault();
					CompareData.activeComparisonId = comparison.id;
					loadComparisonFromCompareData(comparison);
					renderHistory();
					updateHistoryNavState();
					// After re-render, focus the input
					setTimeout(() => {
						const newInput = document.querySelector(`.history-item-date[data-comparison-id="${comparison.id}"]`);
							if (newInput) {
								newInput.focus();
							}
						}, 100);
					} else {
						// If already active, just allow normal focus
						// Don't prevent default - let the input handle it
					}
				}, { passive: false });
				if (isActive) {
					dateInput.addEventListener('blur', async () => {
						const newName = dateInput.value.trim();
						if (newName && newName !== comparison.name) {
							comparison.name = newName;
							await saveCompareDataToLocalStorage();
						}
					});
					dateInput.addEventListener('keydown', (e) => {
						if (e.key === 'Enter') {
							dateInput.blur();
						}
					});
				}
				
				titleDiv.appendChild(dateInput);
				
				const metaDiv = document.createElement('div');
				metaDiv.className = 'history-item-meta';
				
				const firstLine = document.createElement('div');
				firstLine.className = 'history-item-meta-line';
				
				const dateTime = document.createElement('span');
				dateTime.className = 'history-item-time';
				const timestamp = comparison.timestamp || comparison.updated || '';
				if (timestamp) {
					const date = new Date(timestamp);
					const dateStr = formatDkDate(timestamp);
					const timeStr = date.toLocaleTimeString('da-DK', { hour: '2-digit', minute: '2-digit' });
					dateTime.textContent = `${dateStr} ${timeStr}`;
				}
				firstLine.appendChild(dateTime);
				
				const secondLine = document.createElement('div');
				secondLine.className = 'history-item-meta-line';
				
				const participants = document.createElement('span');
				participants.className = 'history-item-participants';
				const leftName = truncateName(comparison.participants.left?.name || 'Venstre');
				const rightName = truncateName(comparison.participants.right?.name || 'Højre');
				participants.innerHTML = `${leftName} &<br>${rightName}`;
				
				secondLine.appendChild(participants);
				
				metaDiv.appendChild(firstLine);
				metaDiv.appendChild(secondLine);
				
				const deleteBtn = document.createElement('button');
				deleteBtn.className = 'history-item-delete';
				deleteBtn.textContent = '×';
				
				// Delete button handlers - both touch and click for mobile compatibility
			const handleDelete = async (e) => {
				e.stopPropagation();
				e.preventDefault();
				await deleteComparison(comparison.id);
			};
				
				deleteBtn.addEventListener('click', handleDelete);
				
				// Color button
				const colorBtn = document.createElement('button');
				colorBtn.className = 'history-item-color-btn';
				colorBtn.textContent = 'C';
				colorBtn.title = 'Vælg farve';
				colorBtn.setAttribute('data-comparison-id', comparison.id);
				// Set button color to show current color (lighter version)
				const btnColor = comparison.color || DEFAULT_HISTORY_COLOR;
				colorBtn.style.background = lightenHex(btnColor, 0.3);
				colorBtn.style.color = '#ffffff';
				
				// Color button handlers - both touch and click for mobile compatibility
				const handleColorClick = (e) => {
					e.stopPropagation();
					e.preventDefault();
					openHistoryColorPicker(comparison.id);
				};
				colorBtn.addEventListener('click', handleColorClick);
				colorBtn.addEventListener('touchend', (e) => {
					e.stopPropagation();
					e.preventDefault();
					handleColorClick(e);
				}, { passive: false });
				deleteBtn.addEventListener('touchend', (e) => {
					e.stopPropagation();
					e.preventDefault();
					handleDelete(e);
				}, { passive: false });
				
				item.appendChild(titleDiv);
				item.appendChild(metaDiv);
				item.appendChild(deleteBtn);
				item.appendChild(colorBtn);
				
				// Shared handler function for both touch and click
				const handleItemActivation = async (e) => {
					// Don't handle clicks on delete button or color button
					if (e.target.classList.contains('history-item-delete')) return;
					if (e.target.classList.contains('history-item-color-btn')) return;
					
				// Check current active state
				const currentlyActive = comparison.id === CompareData.activeComparisonId;
				
				// If clicking directly on input field of active item, allow normal editing
				if (e.target.classList.contains('history-item-date') && currentlyActive) {
					// Let the input handle focus normally
					return;
				}
				
				// First click/touch: If item is not active, activate it
				if (!currentlyActive) {
					e.preventDefault();
					e.stopPropagation();
					CompareData.activeComparisonId = comparison.id;
						loadComparisonFromCompareData(comparison);
						await renderHistory();
						updateHistoryNavState();
					} else {
						// Second click/touch: Item is already active, focus the input field
						e.preventDefault();
						e.stopPropagation();
						const titleInput = item.querySelector('.history-item-date');
						if (titleInput) {
							// Use setTimeout to ensure focus happens after any re-renders
							setTimeout(() => {
								titleInput.focus();
								titleInput.select(); // Select all text for easy editing
							}, 0);
						}
					}
				};
				
				// Handle touch events for mobile (fires immediately, no delay)
				let touchStartTime = 0;
				item.addEventListener('touchstart', (e) => {
					touchStartTime = Date.now();
					// Mark that we're handling touch (stored on item to persist across handlers)
					item.dataset.touchHandled = 'false';
				}, { passive: true });
				
				item.addEventListener('touchend', (e) => {
					// Don't handle touches on delete button or textarea - they have their own handlers
					if (e.target.classList.contains('history-item-delete') || 
						e.target.classList.contains('history-item-date')) {
						return;
					}
					
					// Only handle if it was a quick tap (not a scroll)
					const touchDuration = Date.now() - touchStartTime;
					if (touchDuration < 300) { // Quick tap, not a scroll
						handleItemActivation(e);
						// Mark that touch was handled to prevent click event
						item.dataset.touchHandled = 'true';
						// Prevent click event from firing after touch
						e.preventDefault();
					}
				});
				
				// Handle click events for desktop (only if touch wasn't handled)
				item.addEventListener('click', (e) => {
					// Check if touch was already handled (on mobile)
					if (item.dataset.touchHandled !== 'true') {
						handleItemActivation(e);
					}
					// Reset for next interaction
					item.dataset.touchHandled = 'false';
				});
				
				listEl.appendChild(item);
				});
			} // End of sortedMonthKeys for...of loop
			
			// Handle scroll restoration for month fold/unfold
			if (window._monthScrollRestore) {
				const restore = window._monthScrollRestore;
				window._monthScrollRestore = null;
				const newHeader = listEl.querySelector(`.log-history-month-header[data-month-key="${restore.monthKey}"]`);
				if (newHeader) {
					// Try to restore position - browser will clamp if list is too short
					listEl.scrollTop = newHeader.offsetTop - restore.offsetFromListTop;
				}
			}
			
			// Update navigation state (if function exists)
			if (typeof updateHistoryNavState === 'function') {
				updateHistoryNavState();
			}
			
		}
		
		// Function to update navigation state (placeholder to prevent errors)
		function updateHistoryNavState() {
			// This function can be used to update navigation state if needed
			// Currently it's a placeholder to prevent errors
		}
		
		function toggleHistorySidebar() {
			const sidebar = document.getElementById('historySidebar');
			if (!sidebar) return;
			
			sidebar.classList.toggle('collapsed');
			const isCollapsed = sidebar.classList.contains('collapsed');
			localStorage.setItem('compare_historySidebarCollapsed', isCollapsed);
		}
		
	async function deleteComparison(comparisonId) {
		if (!CompareData || !Array.isArray(CompareData.comparisons)) return;
		
		if (CompareData.comparisons.length <= 1) {
			alert('Du kan ikke slette den sidste sammenligning.');
			return;
		}
		
		if (!confirm('Er du sikker på du vil slette denne sammenligning?')) {
			return;
		}
		
		CompareData.comparisons = CompareData.comparisons.filter(c => c.id !== comparisonId);
		
		if (CompareData.activeComparisonId === comparisonId) {
			if (CompareData.comparisons.length > 0) {
				CompareData.activeComparisonId = CompareData.comparisons[CompareData.comparisons.length - 1].id;
			}
		}
		
		// Save and update registreringer (count changed - comparison deleted)
		await saveCompareDataToLocalStorage();
		// Calculate counts per month and update registreringer
		const comparisonsByMonth = {};
		CompareData.comparisons.forEach(comparison => {
			const monthKey = getMonthKey(comparison.timestamp || comparison.updated);
			if (monthKey) {
				if (!comparisonsByMonth[monthKey]) {
					comparisonsByMonth[monthKey] = 0;
				}
				comparisonsByMonth[monthKey]++;
			}
		});
		// Update registreringer for all affected months
		for (const [monthKey, count] of Object.entries(comparisonsByMonth)) {
			await updateRegistreringer(monthKey, 'compare', count);
		}
		
		const activeComparison = getActiveComparison();
		if (activeComparison) {
			loadComparisonFromCompareData(activeComparison);
		}
		renderHistory();
	}
		
		// ===== HISTORY COLOR PICKER FUNCTIONS =====
		
		function openHistoryColorPicker(comparisonId) {
			if (!historyColorPickerModal) {
				historyColorPickerModal = document.getElementById('historyColorPickerModal');
				historyColorPickerGrid = document.getElementById('historyColorGrid');
			}
			if (!historyColorPickerModal || !historyColorPickerGrid) return;
			
			historyColorPickerTarget = comparisonId;
			buildHistoryColorGrid();
			historyColorPickerModal.classList.add('show');
		}
		
		function closeHistoryColorPicker() {
			historyColorPickerTarget = null;
			if (historyColorPickerModal) {
				historyColorPickerModal.classList.remove('show');
			}
		}
		
		function buildHistoryColorGrid() {
			if (!historyColorPickerGrid) return;
			historyColorPickerGrid.innerHTML = '';
			HISTORY_COLOR_PRESETS.forEach(color => {
				const swatch = document.createElement('button');
				swatch.className = 'history-color-swatch';
				swatch.style.background = color;
				swatch.onclick = () => handleHistoryColorSelected(color);
				historyColorPickerGrid.appendChild(swatch);
			});
		}
		
	async function handleHistoryColorSelected(color) {
		if (!historyColorPickerTarget) return;
		const comparisonId = historyColorPickerTarget;
		
		// Find and update the comparison
		const comparison = CompareData.comparisons.find(c => c.id === comparisonId);
		if (!comparison) return;
		
		comparison.color = color;
			
			// Live-update the UI
			const item = document.querySelector(`.history-item button[data-comparison-id="${comparisonId}"]`)?.closest('.history-item');
			if (item) {
				// Update item background color
				const isActive = item.classList.contains('active');
				item.style.backgroundColor = lightenHex(color, isActive ? 0.35 : 0.7);
				item.style.borderColor = isActive ? color : 'transparent';
				
				// Update title div
				const titleDiv = item.querySelector('.history-item-title');
				if (titleDiv) {
					titleDiv.style.backgroundColor = color;
				}
				
				// Update color button
				const colorBtn = item.querySelector('.history-item-color-btn');
				if (colorBtn) {
					colorBtn.style.background = lightenHex(color, 0.3);
					colorBtn.style.color = '#ffffff';
				}
			}
			
			await saveCompareDataToLocalStorage();
			// Don't close picker - let user select multiple colors or click outside to close
		}
		
	async function removeHistoryColor() {
		if (!historyColorPickerTarget) return;
		const comparisonId = historyColorPickerTarget;
		
		// Find and update the comparison
		const comparison = CompareData.comparisons.find(c => c.id === comparisonId);
		if (!comparison) return;
			
			delete comparison.color;
			
			// Live-update the UI
			const item = document.querySelector(`.history-item button[data-comparison-id="${comparisonId}"]`)?.closest('.history-item');
			if (item) {
				// Update item background color to default
				const isActive = item.classList.contains('active');
				item.style.backgroundColor = lightenHex(DEFAULT_HISTORY_COLOR, isActive ? 0.35 : 0.7);
				item.style.borderColor = isActive ? DEFAULT_HISTORY_COLOR : 'transparent';
				
				// Update title div
				const titleDiv = item.querySelector('.history-item-title');
				if (titleDiv) {
					titleDiv.style.backgroundColor = DEFAULT_HISTORY_COLOR;
				}
				
				// Update color button
				const colorBtn = item.querySelector('.history-item-color-btn');
				if (colorBtn) {
					colorBtn.style.background = lightenHex(DEFAULT_HISTORY_COLOR, 0.3);
					colorBtn.style.color = '#ffffff';
				}
			}
			
			await saveCompareDataToLocalStorage();
			// Don't close picker - let user click outside to close
		}
		
	async function createNewComparison() {
		if (!CompareData) {
			await ensureDefaultCompareData();
		}
		
		// Find highest comparison ID across all comparisons
		let maxId = 0;
		if (Array.isArray(CompareData.comparisons)) {
			CompareData.comparisons.forEach(c => {
				if (c.id > maxId) maxId = c.id;
			});
		}
		
		const newId = maxId + 1;
		const comparisonName = `Spejling ${newId}`;
		
		// DON'T save current or new comparison - wait until user changes a slider
		// There's nothing to save yet!
		
		// Create new comparison with color
		const now = new Date().toISOString();
		const newComparison = {
			id: newId,
			name: comparisonName,
			color: DEFAULT_HISTORY_COLOR,
			timestamp: now,
			updated: now,
			notes: '',
			participants: {
				left: {
				name: 'Venstre',
				color: '#3b82f6',
				pose: '',
				flipped: false
			},
				right: {
				name: 'Højre',
				color: '#ef4444',
				pose: '',
				flipped: false
				}
			},
			traitNames: [],
			leftScores: {},
			rightScores: {}
		};
		
		if (!Array.isArray(CompareData.comparisons)) {
			CompareData.comparisons = [];
		}
		CompareData.comparisons.push(newComparison);
		CompareData.activeComparisonId = newId;
		
		// Save and update registreringer (count changed - new comparison created)
		await saveCompareDataToLocalStorage();
		const monthKey = getMonthKey(newComparison.timestamp || newComparison.updated);
		if (monthKey) {
			await updateRegistreringer(monthKey, 'compare', CompareData.comparisons.length);
		}
			
			// Load the new empty comparison
			loadComparisonFromCompareData(newComparison);
			renderHistory();
			
			// Make the new history item's name editable and focus it
			requestAnimationFrame(() => {
				const newHistoryItem = document.querySelector(`.history-item.active input[data-comparison-id="${newId}"]`);
				if (newHistoryItem) {
					newHistoryItem.readOnly = false;
					newHistoryItem.focus();
					newHistoryItem.select();
				}
			});
		}

        
const partsData = {
    lav_ny_left: { 
        name: "Lav Ny Del", 
        color: "#10b981",
        pose: "",
        mirror: false
    },
    lav_ny_right: { 
        name: "Lav Ny Del", 
        color: "#3b82f6",
        pose: "",
        mirror: false
    },
    beskytter: { 
        name: "Beskytteren", 
        color: "#fbbf24",
        pose: "stærk",
        mirror: false
    },
    kritiker: { 
        name: "Den Kritiske", 
        color: "#ef4444",
        pose: "vred",
        mirror: false
    },
    manager: { 
        name: "Manager-delen", 
        color: "#3b82f6",
        pose: "tænke",
        mirror: false
    },
    perfektionist: { 
        name: "Den Perfektionistiske", 
        color: "#8b5cf6",
        pose: "lukket",
        mirror: false
    },
    barn: { 
        name: "Det Indre Barn", 
        color: "#10b981",
        pose: "Leg",
        mirror: false
    },
    saaret: { 
        name: "Det Sårede Barn", 
        color: "#06b6d4",
        pose: "trist",
        mirror: false
    },
    kreativ: { 
        name: "Den Kreative", 
        color: "#f97316",
        pose: "flyver",
        mirror: false
    },
    glade: { 
        name: "Den Glade", 
        color: "#84cc16",
        pose: "hej",
        mirror: false
    }
};

        const defaultTraits = [
            { left: "Leder", right: "Følger" },
            { left: "Planlægger", right: "Improviserer" },
            { left: "Struktureret", right: "Kreativ" },
            { left: "Aktiv", right: "Passiv" },
            { left: "Tænkende", right: "Følende" },
            { left: "Kritisk", right: "Accepterende" },
            { left: "Talende", right: "Lyttende" },
            { left: "Hurtig", right: "Langsom" },
            { left: "Ansvarsfuld", right: "Sorgløs" },
            { left: "Alvorlig", right: "Legende" },
            { left: "Konservativ", right: "Revolutionerende" },
            { left: "Empirisk", right: "Intuitiv" },
			{ left: "Dominerende", right: "Vigende" },
			{ left: "Larmende", right: "Stille" },
			{ left: "Indadvendt", right: "Udadvende" },
			{ left: "Gruppe", right: "Individ" },
			{ left: "Forsigtig", right: "Tager chancer" }
			
			
			
        ];
        const ACTIVE_TRAIT_COUNT = 6;
        let activeTraitIndices = [];
        let currentTraitSelectionKey = null;
        function ensureActiveTraits(forceReselect = false) {
            // Always ensure we have active traits - participants are always present (Venstre/Højre)
            // We no longer check for selected participants since Venstre and Højre are always available
            if (forceReselect || activeTraitIndices.length === 0) {
                // Use a fixed key since we always have the same participants
                currentTraitSelectionKey = 'venstre|højre';

                const indices = Array.from({ length: defaultTraits.length }, (_, idx) => idx);
                for (let i = indices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [indices[i], indices[j]] = [indices[j], indices[i]];
                }
                activeTraitIndices = indices
                    .slice(0, Math.min(ACTIVE_TRAIT_COUNT, defaultTraits.length))
                    .sort((a, b) => a - b);
                // Only clear scores if we're forcing a reselect
                if (forceReselect) {
                leftScores = {};
                rightScores = {};
                }
            }
        }

        function getActiveTraits() {
            if (activeTraitIndices.length === 0) {
                return defaultTraits.map((trait, index) => ({ trait, index }));
            }
            return activeTraitIndices.map(index => ({
                index,
                trait: defaultTraits[index]
            }));
        }
		
		
		
		
	///// animations bibliotek
		
		let animationsLibrary = {};
		
		// Load animations from JSON files - dynamically loads from manifest.json
        async function loadAnimations() {
            // Try to load manifest.json first (most reliable method)
            try {
                const manifestResponse = await fetch('Animations/manifest.json');
                if (manifestResponse.ok) {
                    const manifest = await manifestResponse.json();
                    if (manifest.files && Array.isArray(manifest.files)) {
                        for (const fileName of manifest.files) {
                            try {
                                const fileResponse = await fetch(`Animations/${fileName}`);
                                if (fileResponse.ok) {
                                    const animationData = await fileResponse.json();
                                    const animName = fileName.replace('.json', '');
                                    animationsLibrary[animName] = animationData;
                                }
                            } catch (error) {
                                console.error(`Failed to load animation ${fileName}:`, error);
                            }
                        }
                        return; // Successfully loaded from manifest
                    }
                }
            } catch (error) {
                // Manifest not available, try directory listing
            }
            
            // Fallback: Try directory listing
            try {
                const response = await fetch('Animations/');
                if (response.ok) {
                    const html = await response.text();
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const links = doc.querySelectorAll('a[href$=".json"]');
                    const jsonFiles = Array.from(links)
                        .map(link => link.getAttribute('href'))
                        .filter(file => file !== 'manifest.json'); // Exclude manifest itself
                    
                    if (jsonFiles.length > 0) {
                        for (const fileName of jsonFiles) {
                            try {
                                const fileResponse = await fetch(`Animations/${fileName}`);
                                if (fileResponse.ok) {
                                    const animationData = await fileResponse.json();
                                    const animName = fileName.replace('.json', '');
                                    animationsLibrary[animName] = animationData;
                                }
                            } catch (error) {
                                console.error(`Failed to load animation ${fileName}:`, error);
                            }
                        }
                        return; // Successfully loaded from directory listing
                    }
                }
            } catch (error) {
                // Directory listing not available
            }
        }
		
		
		
		
// Pose Library - loaded from external JSON file
let poseLibrary = [];

// Load pose library from external JSON file
async function loadPoseLibrary() {
    try {
        const response = await fetch('Standard_new_poses.json');
        if (response.ok) {
            poseLibrary = await response.json();
            (window.__APP_DEBUG__ && console.log('Loaded pose library with', poseLibrary.length, 'poses'));
        } else {
            console.error('Failed to load pose library');
            // Fallback to basic poses
            poseLibrary = [
                {
                    "name": "standard",
                    "pose": {
                        "translate_x_left": -3,
                        "translate_y_left": 0,
                        "skulder_rot_left": -70,
                        "albue_rot_left": 0,
                        "translate_x": 3,
                        "translate_y": 0,
                        "skulder_rot": 70,
                        "albue_rot": 0,
                        "translate_x_left_leg": 0,
                        "translate_y_left_leg": 0,
                        "hofte_rot_left": 6,
                        "knae_rot_left": 0,
                        "translate_x_right_leg": 0,
                        "translate_y_right_leg": 0,
                        "hofte_rot_right": -6,
                        "knae_rot_right": 0,
                        "left_arm_front": false,
                        "right_arm_front": false,
                        "duration": 0.3
                    }
                }
            ];
        }
    } catch (error) {
        console.error('Error loading pose library:', error);
        // Fallback to basic poses
        poseLibrary = [
            {
                "name": "standard",
                "pose": {
                    "translate_x_left": -3,
                    "translate_y_left": 0,
                    "skulder_rot_left": -70,
                    "albue_rot_left": 0,
                    "translate_x": 3,
                    "translate_y": 0,
                    "skulder_rot": 70,
                    "albue_rot": 0,
                    "translate_x_left_leg": 0,
                    "translate_y_left_leg": 0,
                    "hofte_rot_left": 6,
                    "knae_rot_left": 0,
                    "translate_x_right_leg": 0,
                    "translate_y_right_leg": 0,
                    "hofte_rot_right": -6,
                    "knae_rot_right": 0,
                    "left_arm_front": false,
                    "right_arm_front": false,
                    "duration": 0.3
                }
            }
        ];
    }
}

//// anim funktioner
function runAnimation(side, animName) {
    const animation = animationsLibrary[animName];
    if (!animation || !animation.slides) {
        (window.__APP_DEBUG__ && console.log(`Animation "${animName}" not found`));
        return;
    }
    
    // Add smooth transitions to all animated elements
    const circle = document.getElementById(side + 'Circle');
    const animatedElements = circle.querySelectorAll(
        '.skulder_translate_left, .skulder_rotate_left, .albue_rotate_left, ' +
        '.skulder_translate_right, .skulder_rotate_right, .albue_rotate_right, ' +
        '.hofte_translate_left, .hofte_rotate_left, .knae_rotate_left, ' +
        '.hofte_translate_right, .hofte_rotate_right, .knae_rotate_right'
    );
    
    let slideIndex = 0;
    
    function playNextSlide() {
        if (slideIndex < animation.slides.length) {
            const slide = animation.slides[slideIndex];
            
            // Set transition duration for this slide
            animatedElements.forEach(element => {
                element.style.transition = `transform ${slide.duration}s cubic-bezier(0.25, 0.1, 0.25, 1)`;
            });
            
            applyDirectSlideData(side, slide);
            slideIndex++;
            setTimeout(playNextSlide, slide.duration * 1000);
        } else {
            // Remove transitions when animation is done
            animatedElements.forEach(element => {
                element.style.transition = '';
            });
        }
    }
    
    playNextSlide();
}

function applyDirectSlideData(side, slideData) {
    const circle = document.getElementById(side + 'Circle');
    const skulderLeft = circle.querySelector('.skulder_translate_left');
    const skulderRight = circle.querySelector('.skulder_translate_right');
    const hofteLeft = circle.querySelector('.hofte_translate_left');
    const hofteRight = circle.querySelector('.hofte_translate_right');
    
    if (skulderLeft) {
        skulderLeft.style.transform = `translate(${slideData.translate_x_left || 0}px, ${slideData.translate_y_left || 0}px)`;
        const skulderRotLeft = skulderLeft.querySelector('.skulder_rotate_left');
        if (skulderRotLeft) {
            skulderRotLeft.style.transform = `rotate(${slideData.skulder_rot_left || 0}deg)`;
            const albueRotLeft = skulderRotLeft.querySelector('.albue_rotate_left');
            if (albueRotLeft) {
                albueRotLeft.style.transform = `rotate(${slideData.albue_rot_left || 0}deg)`;
            }
        }
    }
    
    if (skulderRight) {
        skulderRight.style.transform = `translate(${slideData.translate_x || 0}px, ${slideData.translate_y || 0}px)`;
        const skulderRotRight = skulderRight.querySelector('.skulder_rotate_right');
        if (skulderRotRight) {
            skulderRotRight.style.transform = `rotate(${slideData.skulder_rot || 0}deg)`;
            const albueRotRight = skulderRotRight.querySelector('.albue_rotate_right');
            if (albueRotRight) {
                albueRotRight.style.transform = `rotate(${slideData.albue_rot || 0}deg)`;
            }
        }
    }
    
    if (hofteLeft) {
        hofteLeft.style.transform = `translate(${slideData.translate_x_left_leg || 0}px, ${slideData.translate_y_left_leg || 0}px)`;
        const hofteRotLeft = hofteLeft.querySelector('.hofte_rotate_left');
        if (hofteRotLeft) {
            hofteRotLeft.style.transform = `rotate(${slideData.hofte_rot_left || 0}deg)`;
            const knaeRotLeft = hofteRotLeft.querySelector('.knae_rotate_left');
            if (knaeRotLeft) {
                knaeRotLeft.style.transform = `rotate(${slideData.knae_rot_left || 0}deg)`;
            }
        }
    }
    
    if (hofteRight) {
        hofteRight.style.transform = `translate(${slideData.translate_x_right_leg || 0}px, ${slideData.translate_y_right_leg || 0}px)`;
        const hofteRotRight = hofteRight.querySelector('.hofte_rotate_right');
        if (hofteRotRight) {
            hofteRotRight.style.transform = `rotate(${slideData.hofte_rot_right || 0}deg)`;
            const knaeRotRight = hofteRotRight.querySelector('.knae_rotate_right');
            if (knaeRotRight) {
                knaeRotRight.style.transform = `rotate(${slideData.knae_rot_right || 0}deg)`;
            }
        }
    }
    
    // Handle arm layering
    if (slideData.left_arm_front) {
        skulderLeft?.classList.add('front-arm');
    } else {
        skulderLeft?.classList.remove('front-arm');
    }
    
    if (slideData.right_arm_front) {
        skulderRight?.classList.add('front-arm');
    } else {
        skulderRight?.classList.remove('front-arm');
    }
}




/// pose functions
function openPosePicker(btn) {
    // Find the participant container (not just the circle)
    const participantCircle = btn.closest('.participant-circle');
    currentPosePart = participantCircle.parentElement; // This is the .participant div
    
    const modal = document.getElementById('posePickerModal');
    const picker = modal.querySelector('.pose-picker');
    
    // Get current pose and mirror from the participant element
    const currentPose = currentPosePart.getAttribute('data-pose') || '';
    const currentMirror = currentPosePart.getAttribute('data-mirror') === 'true';
    
    // Set mirror checkbox in picker
    document.getElementById('posePickerMirror').checked = currentMirror;
    
    // Populate pose grid (this will highlight the current pose)
    populatePoseGrid();
    
    // Show modal and position it
    const btnRect = btn.getBoundingClientRect();
    modal.classList.add('show');
    
    picker.style.position = 'absolute';
    picker.style.left = (btnRect.right + 10) + 'px';
    picker.style.top = (btnRect.top - 20) + 'px';
    
    // Adjust if goes off screen
    const pickerRect = picker.getBoundingClientRect();
    if (pickerRect.right > window.innerWidth) {
        picker.style.left = (btnRect.left - pickerRect.width - 10) + 'px';
    }
    if (pickerRect.bottom > window.innerHeight) {
        picker.style.top = (btnRect.bottom - pickerRect.height - 10) + 'px';
    }
}

function populatePoseGrid() {
    const grid = document.getElementById('poseGrid');
    grid.innerHTML = '';
    
    // Get current pose from the DOM element
    const currentPose = currentPosePart.getAttribute('data-pose') || '';
    const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
    
    // Add all poses from library (including "standard")
    poseLibrary.forEach((pose, index) => {
        const btn = document.createElement('button');
        btn.className = 'pose-button';
        btn.textContent = pose.name;
        btn.onclick = () => selectPose(index);
        
        if (currentPose === index.toString() || (currentPose === '' && index === standardIndex)) {
            btn.classList.add('active');
        }
        
        grid.appendChild(btn);
    });
}

function selectPose(poseIndex) {
    if (!currentPosePart) return;
    
    const mirror = document.getElementById('posePickerMirror').checked;
    
    // Find out which side by checking if it contains leftCircle or rightCircle
    const hasLeftCircle = currentPosePart.querySelector('#leftCircle');
    const side = hasLeftCircle ? 'left' : 'right';
    
    // Update the regular dropdowns to match
    const poseDropdown = document.getElementById(side + 'Pose');
    const mirrorCheckbox = document.getElementById(side + 'Mirror');
    
    // Map empty selection to standard index if available
    if (poseIndex === '') {
        const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
        if (standardIndex !== -1) {
            poseIndex = standardIndex;
        }
    }

    if (poseDropdown) poseDropdown.value = poseIndex;
    if (mirrorCheckbox) mirrorCheckbox.checked = mirror;
    
    // Use the existing applyPose function with mirror parameter
    applyPose(side, poseIndex, mirror);
    
    // Update active button
    populatePoseGrid();
}

function togglePosePickerMirror() {
    if (!currentPosePart) return;
    
    // Find out which side
    const hasLeftCircle = currentPosePart.querySelector('#leftCircle');
    const side = hasLeftCircle ? 'left' : 'right';
    
    // Update the regular mirror checkbox to match
    const regularMirrorCheckbox = document.getElementById(side + 'Mirror');
    const posePickerMirrorCheckbox = document.getElementById('posePickerMirror');
    
    if (regularMirrorCheckbox) {
        regularMirrorCheckbox.checked = posePickerMirrorCheckbox.checked;
    }
    
    // Re-apply current pose with new mirror state
    const currentPoseAttr = currentPosePart.getAttribute('data-pose');
    const poseIndex = currentPoseAttr != null ? currentPoseAttr : '';
    const mirror = posePickerMirrorCheckbox ? posePickerMirrorCheckbox.checked : false;
    applyPose(side, poseIndex, mirror);
}

async function closePosePicker() {
    // Save pose and flipped state when overlay closes
    await syncCurrentWorkspaceToActiveComparison();
    document.getElementById('posePickerModal').classList.remove('show');
    currentPosePart = null;
}



// end pose functions



		
		

        

        function hslToHex(h,s,l){
            s /= 100; l /= 100;
            const k = n => (n + h/30) % 12;
            const a = s * Math.min(l, 1 - l);
            const f = n => {
                const color = l - a * Math.max(Math.min(k(n) - 3, 9 - k(n), 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }

        function lightenColor(color, factor) {
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            
            const newR = Math.round(r + (255 - r) * factor);
            const newG = Math.round(g + (255 - g) * factor);
            const newB = Math.round(b + (255 - b) * factor);
            
            return `rgb(${newR}, ${newG}, ${newB})`;
        }

        function updateBodyColors(side, color) {
    const circle = document.getElementById(side + 'Circle');
    if (!circle) return;
    
    // Convert hex to RGB to darken it
    function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }
    
    function darkenColor(hex, factor = 0.8) {
        const rgb = hexToRgb(hex);
        if (!rgb) return hex;
        
        const r = Math.round(rgb.r * factor);
        const g = Math.round(rgb.g * factor);
        const b = Math.round(rgb.b * factor);
        
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    const darkerColor = darkenColor(color, 0.92); // 15% mørkere
    
    const torso = circle.querySelector('.participant-torso');
    const armParts = circle.querySelectorAll('.arm_geo_left, .arm_geo_right, .albue_geo_left, .albue_geo_right');
    const legParts = circle.querySelectorAll('.laar_geo_left, .laar_geo_right, .skinneben_geo_left, .skinneben_geo_right');
    
    // Torso og hoved beholder original farve
		const head = circle.querySelector('.head');
		if (head) head.style.background = color;
		if (torso) torso.style.background = color;
    
    // Arme og ben får mørkere farve
    armParts.forEach(part => part.style.background = darkerColor);
    legParts.forEach(part => part.style.background = darkerColor);
}

        function updateSliderColors() {
            const root = document.documentElement;
            
            if (leftColor) {
                root.style.setProperty('--left-color', leftColor);
            }
            
            if (rightColor) {
                root.style.setProperty('--right-color', rightColor);
            }
        }

        function updateParticipant(side) {
            // Don't show participants during initial load
            if (isInitialLoad) return;
            
            const dropdown = document.getElementById(side + 'Dropdown');
            const circle = document.getElementById(side + 'Circle');
            const name = document.getElementById(side + 'Name');
            const colorBtn = document.getElementById(side + 'ColorBtn');
            const selectedValue = dropdown.value;
            
            if (selectedValue && partsData[selectedValue]) {
                const partData = partsData[selectedValue];
                circle.style.display = 'flex';
                
                if (side === 'left') {
                    leftColor = partData.color;
                    leftLightColor = lightenColor(partData.color, 0.6);
                } else {
                    rightColor = partData.color;
                    rightLightColor = lightenColor(partData.color, 0.6);
                }
                
                if (!name.hasAttribute('data-edited')) {
                    name.textContent = partData.name;
                }
                
                name.contentEditable = true;
                name.style.cursor = 'text';
                
                name.onclick = function() { name.focus(); };
                name.onkeydown = function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        name.blur();
                        name.setAttribute('data-edited', 'true');
                    }
                };
                name.onblur = function() {
                    name.setAttribute('data-edited', 'true');
                };
				
				
                
                const head = circle.querySelector('.head');
				if (head) {
					head.style.background = `linear-gradient(135deg, ${partData.color}, ${partData.color}dd)`;
					
				}
                
				colorBtn.style.display = 'flex';
                updateBodyColors(side, partData.color);
				updateSliderColors();
				

				// Play welcome animation first, then reset to default pose
				// Play welcome animation first, then apply saved pose or reset to default
				setTimeout(() => {
					runAnimation(side, 'vinke');
					
					const animationDuration = animationsLibrary.vinke ? animationsLibrary.vinke.slides.reduce((total, slide) => total + slide.duration, 0) : 0;
					setTimeout(() => {
							// Get partData again inside this scope and re-apply pose after animation
						const dropdown = document.getElementById(side + 'Dropdown');
						const selectedValue = dropdown.value;
						const currentPartData = partsData[selectedValue];
						
						// Apply pose directly from partData (no dropdowns needed)
						if (currentPartData && currentPartData.pose) {
							// Find pose index by name (case-insensitive, trimmed)
							const targetName = (currentPartData.pose || '').toLowerCase().trim();
							const poseIndex = poseLibrary.findIndex(pose => (pose.name || '').toLowerCase().trim() === targetName);
							if (poseIndex !== -1) {
								// Apply pose with mirror if specified
								const circle = document.getElementById(side + 'Circle');
								if (circle) {
									const participant = circle.parentElement;
									if (participant) {
										participant.setAttribute('data-pose', poseIndex.toString());
										participant.setAttribute('data-mirror', (currentPartData.mirror || false).toString());
									}
								}
								applyPose(side, poseIndex);
							} else {
								resetPose(side);
							}
						} else {
							resetPose(side);
						}
					}, animationDuration * 1000 + 100);
				}, 200);
							
            } else {
                // If no dropdown selection, ensure default Venstre/Højre are shown
                // Venstre and Højre are always available, so we should never hide the circles
                const defaultName = side === 'left' ? 'Venstre' : 'Højre';
                const defaultColor = side === 'left' ? '#3b82f6' : '#ef4444';
                
                if (!name.hasAttribute('data-edited')) {
                    name.textContent = defaultName;
                }
                
                if (side === 'left') {
                    leftColor = defaultColor;
                    leftLightColor = lightenColor(defaultColor, 0.6);
                } else {
                    rightColor = defaultColor;
                    rightLightColor = lightenColor(defaultColor, 0.6);
                }
                
                // Ensure circle is visible
                circle.style.display = 'flex';
                const head = circle.querySelector('.head');
                if (head) {
                    head.style.background = `linear-gradient(135deg, ${defaultColor}, ${defaultColor})`;
                }
                updateBodyColors(side, defaultColor);
                updateSliderColors();
            }
            updateButtonStates();
            updateComparisonView();
			
			
			
        }
		
		
		

		
		function updatePartsData(newPartsData) {
            Object.keys(partsData).forEach(key => {
                if (key !== 'lav_ny_left' && key !== 'lav_ny_right') {
                    delete partsData[key];
                }
            });
            
            Object.assign(partsData, newPartsData);
            // Rebuild dropdowns after data update
            buildDropdownMenus();
        }
		
        function buildDropdownMenus() {
            const leftDropdown = document.getElementById('leftDropdown');
            const rightDropdown = document.getElementById('rightDropdown');
            
            const leftSelected = leftDropdown.value;
            const rightSelected = rightDropdown.value;
            
            leftDropdown.innerHTML = '';
            rightDropdown.innerHTML = '';
            
            [leftDropdown, rightDropdown].forEach((dropdown, index) => {
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = index === 0 ? 'Venstre del...' : 'Højre del...';
                dropdown.appendChild(defaultOption);
            });
            
            // partsData already may include shared items injected at init
            Object.keys(partsData).forEach(key => {
                if (key === 'lav_ny_left' || key === 'lav_ny_right') return;
                
                const partData = partsData[key];
                
                [leftDropdown, rightDropdown].forEach(dropdown => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = partData.name;
                    dropdown.appendChild(option);
                });
            });
            
            if (leftSelected && partsData[leftSelected]) {
                leftDropdown.value = leftSelected;
            }
            if (rightSelected && partsData[rightSelected]) {
                rightDropdown.value = rightSelected;
            }
        }
        
        function initializeDropdowns() {
            // Inject shared characters from localStorage into partsData once
            try {
                const raw = localStorage.getItem('relationsSetupData');
                if (raw) {
                    const parsed = JSON.parse(raw);
                    if (parsed && Array.isArray(parsed.characters) && parsed.characters.length > 0) {
                        const sharedParts = {};
                        parsed.characters.forEach((c, idx) => {
                            if (!c || !c.name) return;
                            sharedParts['shared_' + idx] = {
                                name: c.name,
                                color: c.color || '#10b981',
                                pose: c.pose || '',
                                mirror: !!c.mirror
                            };
                        });
                        if (Object.keys(sharedParts).length > 0) {
                            updatePartsData(sharedParts);
                        }
                    }
                }
            } catch(_) {}
            buildDropdownMenus();
        }
        
        function handleStorageUpdate() {
            (window.__APP_DEBUG__ && console.log('Handling storage update in comparison tool...'));
            
            // Store current selections
            const leftDropdown = document.getElementById('leftDropdown');
            const rightDropdown = document.getElementById('rightDropdown');
            const currentLeftSelected = leftDropdown.value;
            const currentRightSelected = rightDropdown.value;
            
            // Reinitialize dropdowns with new data
            initializeDropdowns();
            
            // Check if current selections still exist and are valid
            const leftStillValid = currentLeftSelected && partsData[currentLeftSelected];
            const rightStillValid = currentRightSelected && partsData[currentRightSelected];
            
            // Restore selections if they're still valid, otherwise clear them
            // Note: Venstre and Højre are always available, so circles should never be hidden
            if (leftStillValid) {
                leftDropdown.value = currentLeftSelected;
            } else {
                leftDropdown.value = '';
                // If selection was cleared, ensure default Venstre is shown
                const leftCircle = document.getElementById('leftCircle');
                const leftNameEl = document.getElementById('leftName');
                if (leftCircle && !isInitialLoad) {
                    leftCircle.style.display = 'flex';
                    if (leftNameEl && !leftNameEl.hasAttribute('data-edited')) {
                        leftNameEl.textContent = 'Venstre';
                    }
                    const head = leftCircle.querySelector('.head');
                    if (head) {
                        head.style.background = `linear-gradient(135deg, #3b82f6, #3b82f6)`;
                    }
                    updateBodyColors('left', '#3b82f6');
                }
                leftColor = '#3b82f6';
                leftLightColor = lightenColor(leftColor, 0.6);
                updateSliderColors();
            }
            
            if (rightStillValid) {
                rightDropdown.value = currentRightSelected;
            } else {
                rightDropdown.value = '';
                // If selection was cleared, ensure default Højre is shown
                const rightCircle = document.getElementById('rightCircle');
                const rightNameEl = document.getElementById('rightName');
                if (rightCircle && !isInitialLoad) {
                    rightCircle.style.display = 'flex';
                    if (rightNameEl && !rightNameEl.hasAttribute('data-edited')) {
                        rightNameEl.textContent = 'Højre';
                    }
                    const head = rightCircle.querySelector('.head');
                    if (head) {
                        head.style.background = `linear-gradient(135deg, #ef4444, #ef4444)`;
                    }
                    updateBodyColors('right', '#ef4444');
                }
                rightColor = '#ef4444';
                rightLightColor = lightenColor(rightColor, 0.6);
                updateSliderColors();
            }
            
            // Update participant displays - always update to ensure Venstre/Højre are shown
            updateParticipant('left');
            updateParticipant('right');
            
            // Update button states and comparison view
            updateButtonStates();
            updateComparisonView();
            
            // Show status message
            const updatedCount = Object.keys(partsData).length;
            setStatus(`Dropdowns opdateret - ${updatedCount} karakterer tilgængelige`);
            
            // Log what happened for debugging
            (window.__APP_DEBUG__ && console.log('Comparison storage update handled:', {
                leftWasValid: leftStillValid,
                rightWasValid: rightStillValid,
                leftSelected: leftDropdown.value,
                rightSelected: rightDropdown.value,
                availableCharacters: updatedCount
            }));
        }
		
		
		
		
		
		
		
		function initializePoseDropdowns() {
    const leftDropdown = document.getElementById('leftPose');
    const rightDropdown = document.getElementById('rightPose');
    
    // Return early if dropdowns don't exist (they were removed with info-left/right)
    if (!leftDropdown || !rightDropdown) {
        return;
    }
    
    // Clear existing options; if standard exists, we won't add a placeholder
    const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
    if (standardIndex !== -1) {
        leftDropdown.innerHTML = '';
        rightDropdown.innerHTML = '';
    } else {
        leftDropdown.innerHTML = '<option value="">Standard pose</option>';
        rightDropdown.innerHTML = '<option value="">Standard pose</option>';
    }
    
    // Add poses to dropdowns
    poseLibrary.forEach((pose, index) => {
        const leftOption = document.createElement('option');
        leftOption.value = index;
        leftOption.textContent = pose.name;
        leftDropdown.appendChild(leftOption);
        
        const rightOption = document.createElement('option');
        rightOption.value = index;
        rightOption.textContent = pose.name;
        rightDropdown.appendChild(rightOption);
    });
}

function applyPose(side, poseIndex, mirrorOverride) {
    const circle = document.getElementById(side + 'Circle');
    const mirrorCheckbox = document.getElementById(side + 'Mirror');
    const participantNode = circle ? circle.parentElement : null;
    
    if (!circle) {
        return;
    }
    // Map empty to standard index if available
    if (poseIndex === '') {
        const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
        if (standardIndex !== -1) {
            poseIndex = standardIndex;
        } else {
            resetPose(side);
            return;
        }
    }
    
    // Determine mirror state: use override if provided, otherwise check checkbox or data attribute
    let mirrorActive;
    if (typeof mirrorOverride === 'boolean') {
        mirrorActive = mirrorOverride;
    } else if (mirrorCheckbox) {
        mirrorActive = !!mirrorCheckbox.checked;
    } else if (participantNode && participantNode.hasAttribute('data-mirror')) {
        mirrorActive = participantNode.getAttribute('data-mirror') === 'true';
    } else {
        mirrorActive = false;
    }
    
    // Update checkbox to match mirror state
    if (mirrorCheckbox) {
        mirrorCheckbox.checked = mirrorActive;
    }
    
    // Add smooth transitions to all animated elements
    const animatedElements = circle.querySelectorAll(
        '.skulder_translate_left, .skulder_rotate_left, .albue_rotate_left, ' +
        '.skulder_translate_right, .skulder_rotate_right, .albue_rotate_right, ' +
        '.hofte_translate_left, .hofte_rotate_left, .knae_rotate_left, ' +
        '.hofte_translate_right, .hofte_rotate_right, .knae_rotate_right'
    );
    
    animatedElements.forEach(element => {
        element.style.transition = 'transform 0.8s cubic-bezier(0.25, 0.1, 0.25, 1)';
    });
    
    const pose = poseLibrary[poseIndex];
    if (!pose) return;
    
    let poseData = pose.pose;
    
    // If mirror is active, create mirrored version
    if (mirrorActive) {
        poseData = {
            translate_x_left: -(pose.pose.translate_x || 0),
            translate_x: -(pose.pose.translate_x_left || 0),
            translate_y_left: pose.pose.translate_y || 0,
            translate_y: pose.pose.translate_y_left || 0,
            skulder_rot_left: -(pose.pose.skulder_rot || 0),
            skulder_rot: -(pose.pose.skulder_rot_left || 0),
            albue_rot_left: -(pose.pose.albue_rot || 0),
            albue_rot: -(pose.pose.albue_rot_left || 0),
            translate_x_left_leg: -(pose.pose.translate_x_right_leg || 0),
            translate_x_right_leg: -(pose.pose.translate_x_left_leg || 0),
            translate_y_left_leg: pose.pose.translate_y_right_leg || 0,
            translate_y_right_leg: pose.pose.translate_y_left_leg || 0,
            hofte_rot_left: -(pose.pose.hofte_rot_right || 0),
            hofte_rot_right: -(pose.pose.hofte_rot_left || 0),
            knae_rot_left: -(pose.pose.knae_rot_right || 0),
            knae_rot_right: -(pose.pose.knae_rot_left || 0),
            left_arm_front: pose.pose.right_arm_front || false,
            right_arm_front: pose.pose.left_arm_front || false
        };
    }
    
    // Apply transforms to figure parts
    const skulderLeft = circle.querySelector('.skulder_translate_left');
    const skulderRight = circle.querySelector('.skulder_translate_right');
    const hofteLeft = circle.querySelector('.hofte_translate_left');
    const hofteRight = circle.querySelector('.hofte_translate_right');
    
    if (skulderLeft) {
        skulderLeft.style.transform = `translate(${poseData.translate_x_left || 0}px, ${poseData.translate_y_left || 0}px)`;
        const skulderRotLeft = skulderLeft.querySelector('.skulder_rotate_left');
        if (skulderRotLeft) {
            skulderRotLeft.style.transform = `rotate(${poseData.skulder_rot_left || 0}deg)`;
            const albueRotLeft = skulderRotLeft.querySelector('.albue_rotate_left');
            if (albueRotLeft) {
                albueRotLeft.style.transform = `rotate(${poseData.albue_rot_left || 0}deg)`;
            }
        }
    }
    
    if (skulderRight) {
        skulderRight.style.transform = `translate(${poseData.translate_x || 0}px, ${poseData.translate_y || 0}px)`;
        const skulderRotRight = skulderRight.querySelector('.skulder_rotate_right');
        if (skulderRotRight) {
            skulderRotRight.style.transform = `rotate(${poseData.skulder_rot || 0}deg)`;
            const albueRotRight = skulderRotRight.querySelector('.albue_rotate_right');
            if (albueRotRight) {
                albueRotRight.style.transform = `rotate(${poseData.albue_rot || 0}deg)`;
            }
        }
    }
    
    if (hofteLeft) {
        hofteLeft.style.transform = `translate(${poseData.translate_x_left_leg || 0}px, ${poseData.translate_y_left_leg || 0}px)`;
        const hofteRotLeft = hofteLeft.querySelector('.hofte_rotate_left');
        if (hofteRotLeft) {
            hofteRotLeft.style.transform = `rotate(${poseData.hofte_rot_left || 0}deg)`;
            const knaeRotLeft = hofteRotLeft.querySelector('.knae_rotate_left');
            if (knaeRotLeft) {
                knaeRotLeft.style.transform = `rotate(${poseData.knae_rot_left || 0}deg)`;
            }
        }
    }
    
    if (hofteRight) {
        hofteRight.style.transform = `translate(${poseData.translate_x_right_leg || 0}px, ${poseData.translate_y_right_leg || 0}px)`;
        const hofteRotRight = hofteRight.querySelector('.hofte_rotate_right');
        if (hofteRotRight) {
            hofteRotRight.style.transform = `rotate(${poseData.hofte_rot_right || 0}deg)`;
            const knaeRotRight = hofteRotRight.querySelector('.knae_rotate_right');
            if (knaeRotRight) {
                knaeRotRight.style.transform = `rotate(${poseData.knae_rot_right || 0}deg)`;
            }
        }
    }
    
    // Handle arm layering
    if (poseData.left_arm_front) {
        skulderLeft.classList.add('front-arm');
    } else {
        skulderLeft.classList.remove('front-arm');
    }
    
    if (poseData.right_arm_front) {
        skulderRight.classList.add('front-arm');
    } else {
        skulderRight.classList.remove('front-arm');
    }
	
	// Store pose state on DOM element
    const participant = circle.parentElement;
    if (participant) {
        participant.setAttribute('data-pose', poseIndex);
        participant.setAttribute('data-mirror', String(mirrorActive));
    }
	
	
}

function applyParticipantPose(side, poseName, mirror) {
    if (!poseLibrary || !poseLibrary.length) {
        return;
    }
    const circle = document.getElementById(side + 'Circle');
    const participantNode = circle ? circle.parentElement : null;
    const poseDropdown = document.getElementById(side + 'Pose');
    const defaultIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
    let poseIndex = -1;
    if (poseName) {
        poseIndex = poseLibrary.findIndex(p => p && p.name === poseName);
    }
    if (poseIndex === -1) {
        if (defaultIndex !== -1) {
            if (poseDropdown) poseDropdown.value = defaultIndex;
            applyPose(side, defaultIndex, typeof mirror === 'boolean' ? mirror : false);
        } else {
            if (poseDropdown) poseDropdown.value = '';
            resetPose(side);
        }
        return;
    }
    const mirrorValue = typeof mirror === 'boolean'
        ? mirror
        : !!(participantNode && participantNode.getAttribute('data-mirror') === 'true');
    if (poseDropdown) poseDropdown.value = poseIndex;
    applyPose(side, poseIndex, mirrorValue);
}

function toggleMirror(side) {
    // Get mirror state from participant data attribute if checkbox doesn't exist
    const circle = document.getElementById(side + 'Circle');
    const mirrorCheckbox = document.getElementById(side + 'Mirror');
    const participant = circle ? circle.parentElement : null;
    
    if (participant) {
        const currentMirror = mirrorCheckbox ? mirrorCheckbox.checked : (participant.getAttribute('data-mirror') === 'true');
        const newMirror = !currentMirror;
        
        // Update checkbox to match new mirror state
        if (mirrorCheckbox) {
            mirrorCheckbox.checked = newMirror;
        }
        
        // Update data-mirror attribute
        participant.setAttribute('data-mirror', String(newMirror));
        
        // Re-apply current pose with new mirror state
        const currentPose = participant.getAttribute('data-pose');
        if (currentPose !== null && currentPose !== '') {
            applyPose(side, currentPose, newMirror);
        }
        
        // Save to compareData when mirror changes
        syncCurrentWorkspaceToActiveComparison();
    }
}






function resetPose(side) {
    // Apply the relaxed pose using existing applyPose logic
    const circle = document.getElementById(side + 'Circle');
    if (!circle) return;
    // If standard exists, apply that index and persist state
    const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
    if (standardIndex !== -1) {
        const participant = circle.parentElement;
        if (participant) {
            participant.setAttribute('data-pose', standardIndex.toString());
            participant.setAttribute('data-mirror', 'false');
        }
        applyPose(side, standardIndex);
        return;
    }
    
    // Fallback relaxed default pose
    const relaxedPose = {
        translate_x_left: -3,
        translate_y_left: 0,
        skulder_rot_left: -70,
        albue_rot_left: 0,
        translate_x: 3,
        translate_y: 0,
        skulder_rot: 70,
        albue_rot: 0,
        translate_x_left_leg: 0,
        translate_y_left_leg: 0,
        hofte_rot_left: 6,
        knae_rot_left: 0,
        translate_x_right_leg: 0,
        translate_y_right_leg: 0,
        hofte_rot_right: -6,
        knae_rot_right: 0,
        left_arm_front: false,
        right_arm_front: false
    };
	// Add smooth transitions
		const animatedElements = circle.querySelectorAll(
			'.skulder_translate_left, .skulder_rotate_left, .albue_rotate_left, ' +
			'.skulder_translate_right, .skulder_rotate_right, .albue_rotate_right, ' +
			'.hofte_translate_left, .hofte_rotate_left, .knae_rotate_left, ' +
			'.hofte_translate_right, .hofte_rotate_right, .knae_rotate_right'
		);

		animatedElements.forEach(element => {
			element.style.transition = 'transform 0.8s cubic-bezier(0.25, 0.1, 0.25, 1)';
		});
    
    const poseData = relaxedPose;
    
    // Apply transforms (samme logik som i applyPose)
    const skulderLeft = circle.querySelector('.skulder_translate_left');
    const skulderRight = circle.querySelector('.skulder_translate_right');
    const hofteLeft = circle.querySelector('.hofte_translate_left');
    const hofteRight = circle.querySelector('.hofte_translate_right');
    
    if (skulderLeft) {
        skulderLeft.style.transform = `translate(${poseData.translate_x_left}px, ${poseData.translate_y_left}px)`;
        const skulderRotLeft = skulderLeft.querySelector('.skulder_rotate_left');
        if (skulderRotLeft) {
            skulderRotLeft.style.transform = `rotate(${poseData.skulder_rot_left}deg)`;
            const albueRotLeft = skulderRotLeft.querySelector('.albue_rotate_left');
            if (albueRotLeft) {
                albueRotLeft.style.transform = `rotate(${poseData.albue_rot_left}deg)`;
            }
        }
    }
    
    if (skulderRight) {
        skulderRight.style.transform = `translate(${poseData.translate_x}px, ${poseData.translate_y}px)`;
        const skulderRotRight = skulderRight.querySelector('.skulder_rotate_right');
        if (skulderRotRight) {
            skulderRotRight.style.transform = `rotate(${poseData.skulder_rot}deg)`;
            const albueRotRight = skulderRotRight.querySelector('.albue_rotate_right');
            if (albueRotRight) {
                albueRotRight.style.transform = `rotate(${poseData.albue_rot}deg)`;
            }
        }
    }
    
    if (hofteLeft) {
        hofteLeft.style.transform = `translate(${poseData.translate_x_left_leg}px, ${poseData.translate_y_left_leg}px)`;
        const hofteRotLeft = hofteLeft.querySelector('.hofte_rotate_left');
        if (hofteRotLeft) {
            hofteRotLeft.style.transform = `rotate(${poseData.hofte_rot_left}deg)`;
            const knaeRotLeft = hofteRotLeft.querySelector('.knae_rotate_left');
            if (knaeRotLeft) {
                knaeRotLeft.style.transform = `rotate(${poseData.knae_rot_left}deg)`;
            }
        }
    }
    
    if (hofteRight) {
        hofteRight.style.transform = `translate(${poseData.translate_x_right_leg}px, ${poseData.translate_y_right_leg}px)`;
        const hofteRotRight = hofteRight.querySelector('.hofte_rotate_right');
        if (hofteRotRight) {
            hofteRotRight.style.transform = `rotate(${poseData.hofte_rot_right}deg)`;
            const knaeRotRight = hofteRotRight.querySelector('.knae_rotate_right');
            if (knaeRotRight) {
                knaeRotRight.style.transform = `rotate(${poseData.knae_rot_right}deg)`;
            }
        }
    }
    
    // Reset arm layering
    skulderLeft?.classList.remove('front-arm');
    skulderRight?.classList.remove('front-arm');
}
		
		

        function updateButtonStates() {
            // Random button is enabled on steps 1 and 2 - participants are always present (Venstre/Højre)
            document.getElementById('randomBtn').disabled = (currentStep !== 1 && currentStep !== 2);
        }

        function setStatus(text) {
            document.getElementById('status').textContent = text;
        }

        function openColorPicker(btn, side) {
            currentColorTarget = btn;
            currentColorSide = side;
            
            const modal = document.getElementById('colorPickerModal');
            const picker = modal.querySelector('.picker');
            const btnRect = btn.getBoundingClientRect();
            
            modal.classList.add('show');
            picker.style.position = 'absolute';
            picker.style.left = (btnRect.right + 10) + 'px';
            picker.style.top = (btnRect.top - 20) + 'px';

            const pickerRect = picker.getBoundingClientRect();
            if (pickerRect.right > window.innerWidth) {
                picker.style.left = (btnRect.left - pickerRect.width - 10) + 'px';
            }
            if (pickerRect.bottom > window.innerHeight) {
                picker.style.top = (btnRect.bottom - pickerRect.height - 10) + 'px';
            }
        }
        
        async function closeColorPicker() {
            // Save color when overlay closes
            await syncCurrentWorkspaceToActiveComparison();
            document.getElementById('colorPickerModal').classList.remove('show');
            currentColorTarget = null;
            currentColorSide = null;
        }
        
        let currentNotePart = null;
        
        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            const scrollHeight = textarea.scrollHeight;
            const lineHeight = parseFloat(getComputedStyle(textarea).lineHeight) || 22.4;
            const minHeight = lineHeight + 12;
            textarea.style.height = Math.max(scrollHeight, minHeight) + 'px';
        }
        
        function openNoteOverlay(btn) {
            const participantCircle = btn.closest('.participant-circle');
            const side = participantCircle.id === 'leftCircle' ? 'left' : 'right';
            currentNotePart = { side, circle: participantCircle };
            
            const overlay = document.getElementById('noteOverlay');
            const textarea = document.getElementById('noteTextarea');
            const nameElement = document.getElementById(side + 'Name');
            
            // Load existing name
            const existingName = nameElement ? nameElement.textContent.trim() : '';
            textarea.value = existingName;
            
            // Auto-resize textarea to fit content
            autoResizeTextarea(textarea);
            
            // Position overlay near the button or over the participant circle
            const btnRect = btn.getBoundingClientRect();
            const circleRect = participantCircle.getBoundingClientRect();
            
            let overlayLeft = btnRect.right + 10;
            let overlayTop = btnRect.top;
            
            overlay.classList.add('show');
            const overlayRect = overlay.getBoundingClientRect();
            
            if (overlayLeft + overlayRect.width > window.innerWidth) {
                overlayLeft = circleRect.left + (circleRect.width / 2) - (overlayRect.width / 2);
                overlayTop = circleRect.top + (circleRect.height / 2) - (overlayRect.height / 2);
            }
            
            if (overlayLeft < 10) overlayLeft = 10;
            if (overlayLeft + overlayRect.width > window.innerWidth) overlayLeft = window.innerWidth - overlayRect.width - 10;
            if (overlayTop < 10) overlayTop = 10;
            if (overlayTop + overlayRect.height > window.innerHeight) overlayTop = window.innerHeight - overlayRect.height - 10;
            
            overlay.style.left = overlayLeft + 'px';
            overlay.style.top = overlayTop + 'px';
            
            // Remove previous input listener and add new one
            const newTextarea = textarea.cloneNode(true);
            newTextarea.value = textarea.value;
            textarea.parentNode.replaceChild(newTextarea, textarea);
            newTextarea.addEventListener('input', function() {
                autoResizeTextarea(newTextarea);
            });
            
            // Close overlay on Enter key
            newTextarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    closeNoteOverlay();
                }
            });
            
            setTimeout(() => {
                newTextarea.focus();
                newTextarea.select();
            }, 50);
        }
        
        async function closeNoteOverlay() {
            const overlay = document.getElementById('noteOverlay');
            const textarea = document.getElementById('noteTextarea');
            
            if (currentNotePart && currentNotePart.side) {
                const nameText = textarea.value.trim();
                const nameElement = document.getElementById(currentNotePart.side + 'Name');
                if (nameElement) {
                    nameElement.textContent = nameText;
                    
                    // Save name when overlay closes
                    await syncCurrentWorkspaceToActiveComparison();
                }
            }
            
            overlay.classList.remove('show');
            currentNotePart = null;
        }
        
        async function selectColor(hex) {
            if (currentColorSide) {
                if (currentColorSide === 'left') {
                    leftColor = hex;
                    leftLightColor = lightenColor(hex, 0.6);
                } else {
                    rightColor = hex;
                    rightLightColor = lightenColor(hex, 0.6);
                }
                
                const circle = document.getElementById(currentColorSide + 'Circle');
				const head = circle.querySelector('.head');
				if (head) {
					head.style.background = `linear-gradient(135deg, ${hex}, ${hex}dd)`;
					
				}
                
                updateBodyColors(currentColorSide, hex);
                
                const dropdown = document.getElementById(currentColorSide + 'Dropdown');
                if (dropdown.value === 'lav_ny_' + currentColorSide) {
                    partsData['lav_ny_' + currentColorSide].color = hex;
                }
                
                updateSliderColors();
            }
        }

        function updateComparisonView() {
            const content = document.getElementById('comparisonContent');
            
            // Always ensure we have active traits - participants are always present (Venstre/Højre)
            ensureActiveTraits();
            
            // Always show sliders - Venstre and Højre are always available
            const leftName = document.getElementById('leftName').textContent || 'Venstre';
            const rightName = document.getElementById('rightName').textContent || 'Højre';
            const activeTraits = getActiveTraits();
            
            content.innerHTML = `
                <div class="step-container">
                    <div class="progress-indicators">
                        <div class="progress-dot ${currentStep === 1 ? 'active' : (currentStep > 1 ? 'completed' : '')}"></div>
                        <div class="progress-dot ${currentStep === 2 ? 'active' : (currentStep > 2 ? 'completed' : '')}"></div>
                        <div class="progress-dot ${currentStep === 3 ? 'active' : ''}"></div>
                    </div>
                    
                    <div class="step-header">
                        <div class="step-title" id="stepTitle">Trin 1: Udfyld for ${leftName}</div>
                        <div class="step-nav">
                            <button class="step-btn ${currentStep === 1 ? 'active' : ''}" onclick="switchToStep(1)">1. ${leftName}</button>
                            <button class="step-btn ${currentStep === 2 ? 'active' : ''}" onclick="switchToStep(2)">2. ${rightName}</button>
                            <button class="step-btn ${currentStep === 3 ? 'active' : ''}" onclick="switchToStep(3)">3. Sammenlign</button>
                        </div>
                    </div>
                    
                    <div class="step-content ${currentStep === 1 ? 'active' : ''}" id="step1">
                        <p style="margin-bottom: 20px; color: #6b7280; font-style: italic;">Vurder hvor meget ${leftName} har af hver egenskab. Fokuser kun på denne del.</p>
                        <div class="single-side-traits" id="leftTraits">
                            ${activeTraits.map(({ trait, index }) => createSingleTraitHTML(trait, index, 'left', leftName)).join('')}
                        </div>
                    </div>
                    
                    <div class="step-content ${currentStep === 2 ? 'active' : ''}" id="step2">
                        <p style="margin-bottom: 20px; color: #6b7280; font-style: italic;">Vurder hvor meget ${rightName} har af hver egenskab. Fokuser kun på denne del.</p>
                        <div class="single-side-traits" id="rightTraits">
                            ${activeTraits.map(({ trait, index }) => createSingleTraitHTML(trait, index, 'right', rightName)).join('')}
                        </div>
                    </div>
                    
                    <div class="step-content ${currentStep === 3 ? 'active' : ''}" id="step3">
                        <p style="margin-bottom: 20px; color: #6b7280; font-style: italic;">Se ligheder og forskelle mellem dine to dele.</p>
                        <div id="comparisonResults">
                            ${createComparisonResultsHTML(leftName, rightName)}
                        </div>
                        <div class="speedometer-section">
                            <div class="speedometer-container speedometer-similarity">
                                <div class="speedometer-label">Ligheder</div>
                                <div class="speedometer">
                                    <svg viewBox="0 0 100 100">
                                        <circle cx="50" cy="50" r="40" class="speedometer-bg"/>
                                        <circle cx="50" cy="50" r="40" class="speedometer-fill" id="similarityFill" stroke-dasharray="251.2" stroke-dashoffset="251.2"/>
                                    </svg>
                                </div>
                                <div class="speedometer-value" id="similarityValue">0%</div>
                                <div style="font-size: 12px; color: #6b7280;">Hvor ens er de?</div>
                            </div>
                            
                            <div class="speedometer-container speedometer-difference">
                                <div class="speedometer-label">Forskelle</div>
                                <div class="speedometer">
                                    <svg viewBox="0 0 100 100">
                                        <circle cx="50" cy="50" r="40" class="speedometer-bg"/>
                                        <circle cx="50" cy="50" r="40" class="speedometer-fill" id="differenceFill" stroke-dasharray="251.2" stroke-dashoffset="251.2"/>
                                    </svg>
                                </div>
                                <div class="speedometer-value" id="differenceValue">0%</div>
                                <div style="font-size: 12px; color: #6b7280;">Hvor forskellige er de?</div>
                            </div>
                        </div>
                        <div style="margin-top: 30px;">
                            <label for="comparisonNotes" style="display: block; margin-bottom: 10px; font-weight: 600; color: #374151; font-size: 16px;">Noter</label>
                            <textarea id="comparisonNotes" placeholder="Tilføj noter til sammenligningen..." style="width: 100%; min-height: 150px; padding: 12px; border-radius: 10px; border: 2px solid #e2e8f0; font-size: 16px; font-family: inherit; resize: vertical; outline: none;" oninput="updateComparisonNotes(this.value)"></textarea>
                        </div>
                    </div>
                </div>
            `;

            // Update slider colors from participant colors
            updateSliderColors();
            if (currentStep === 3) {
                calculateAndDisplayScores();
            }
            setStatus(`Sammenligner ${leftName} og ${rightName} - Trin ${currentStep} af 3`);
        }

        function createSingleTraitHTML(trait, index, side, name) {
			const isLeft = side === 'left';
			const currentScore = (isLeft ? leftScores : rightScores)[index] || 0; // Ændret fra 50 til 0
			
			return `
				<div class="single-trait-item">
					<div class="single-slider-container">
                        <div class="single-slider-labels">
						    <span class="trait-left-label">${trait.left}</span>
						    <span class="trait-right-label">${trait.right}</span>
                        </div>
						<input type="range" min="-50" max="50" value="${currentScore}" 
							   class="single-slider ${side}-color" 
							   data-trait-id="${index}" 
							   data-side="${side}"
							   oninput="setSingleTraitScore(${index}, '${side}', this.value)"
							   onmouseup="saveSliderScoreOnRelease(${index}, '${side}')"
							   ontouchend="saveSliderScoreOnRelease(${index}, '${side}')">
					</div>
				</div>
			`;
		}

       function createComparisonResultsHTML(leftName, rightName) {
				const traitsWithSimilarity = [];
				const activeTraits = getActiveTraits();
				
				activeTraits.forEach(({ trait, index }) => {
					const leftScore = leftScores[index] || 0;
					const rightScore = rightScores[index] || 0;
					const similarity = 100 - Math.abs(leftScore - rightScore);
					
					traitsWithSimilarity.push({
						index,
						trait,
						leftScore,
						rightScore,
						similarity
					});
				});
				
				let html = '<div style="display: flex; flex-direction: column; gap: 8px;">';
				
				traitsWithSimilarity.forEach(item => {
					const { trait, leftScore, rightScore, similarity } = item;
					
					let percentColor;
					if (similarity >= 80) {
						percentColor = '#10b981';
					} else if (similarity >= 60) {
						percentColor = '#f59e0b';
					} else {
						percentColor = '#ef4444';
					}
					
					// Behold værdierne i -50:50 range
					let displayLeft = trait.left;
					let displayRight = trait.right;
					let leftPosition = leftScore;
					let rightPosition = rightScore;
					
					if (leftScore > rightScore) {
						displayLeft = trait.right;
						displayRight = trait.left;
						leftPosition = -leftScore;
						rightPosition = -rightScore;
					}
					
                    html += `
                        <div style="display: flex; align-items: flex-end; padding: 12px; background: #f8fafc; border-radius: 6px; gap: 10px;">
                            <div class="comparison-slider-group">
                                <div class="comparison-labels">
                                    <span class="comparison-left-label">${displayLeft}</span>
                                    <span class="comparison-right-label">${displayRight}</span>
                                </div>
                                <div class="comparison-slider-container">
                                    <input type="range" min="-50" max="50" value="${leftPosition}" class="comparison-slider left-color" disabled>
                                    <input type="range" min="-50" max="50" value="${rightPosition}" class="comparison-slider right-color" disabled>
                                </div>
                            </div>
                            <div style="flex: 0 0 60px; text-align: right; font-weight: bold; color: ${percentColor};">
                                ${Math.round(similarity)}%
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; margin-left: 6px;">
                                <button class="compare-color-btn" style="background: ${leftColor || '#3b82f6'}" onclick="writeComparisonDataLeft(${item.index})">C</button>
                                <button class="compare-color-btn" style="background: ${rightColor || '#ef4444'}" onclick="writeComparisonDataRight(${item.index})">C</button>
                            </div>
                        </div>
                    `;
				});
				
				html += '</div>';
				return html;
			}

        function writeComparisonDataLeft(traitIndex) {
            try {
                var leftNameEl = document.getElementById('leftName');
                var rightNameEl = document.getElementById('rightName');
                var youName = leftNameEl ? leftNameEl.textContent : '';
                var otherName = rightNameEl ? rightNameEl.textContent : '';

                var leftVal = (typeof leftScores[traitIndex] === 'number') ? leftScores[traitIndex] : 0;
                var rightVal = (typeof rightScores[traitIndex] === 'number') ? rightScores[traitIndex] : 0;

                // Determine labels for this trait in current display orientation
                var trait = defaultTraits[traitIndex];
                var leftLabel = trait.left;
                var rightLabel = trait.right;
                if ((leftScores[traitIndex] || 0) > (rightScores[traitIndex] || 0)) {
                    // We flipped labels in the UI for visualization; reflect that here too
                    leftLabel = trait.right;
                    rightLabel = trait.left;
                }
                
                // Convert to all lowercase
                leftLabel = leftLabel.toLowerCase();
                rightLabel = rightLabel.toLowerCase();

                // Get left participant's color, pose and flip status
                var leftColorValue = leftColor || '#3b82f6';
                var leftPoseIndex = 0; // Default to standard pose
                var leftPoseFlipped = false;
                
                // Read pose from data-pose attribute on participant element (more reliable than dropdown)
                var leftCircle = document.getElementById('leftCircle');
                if (leftCircle) {
                    var leftParticipant = leftCircle.parentElement;
                    if (leftParticipant) {
                        var dataPose = leftParticipant.getAttribute('data-pose');
                        if (dataPose !== null && dataPose !== '') {
                            leftPoseIndex = Number(dataPose);
                        }
                        var dataMirror = leftParticipant.getAttribute('data-mirror');
                        leftPoseFlipped = dataMirror === 'true';
                    }
                }

                var payload = {
                    "You": youName,
                    "Other": otherName,
                    "You_slider": String(leftVal),
                    "Other_slider": String(rightVal),
                    "left_label": leftLabel,
                    "right_label": rightLabel,
                    "You_color": leftColorValue,
                    "You_pose": leftPoseIndex,
                    "You_pose_flipped": leftPoseFlipped
                };

                localStorage.setItem('compareCoachingData', JSON.stringify(payload));
                console.log('Gemmer compareCoachingData:', payload);
                setStatus('Skrev compareCoachingData for trait #' + traitIndex);
                
                // Open coaching overlay with compare_coaching.json
                console.log('Kalder openCoachingOverlayFromFile med:', 'coaching_templates/compare_coaching.json');
                console.log('openCoachingOverlayFromFile type:', typeof openCoachingOverlayFromFile);
                console.log('window.openCoachingOverlayFromFile type:', typeof window.openCoachingOverlayFromFile);
                
                if (typeof openCoachingOverlayFromFile === 'function') {
                    console.log('Bruger openCoachingOverlayFromFile direkte');
                    openCoachingOverlayFromFile('coaching_templates/compare_coaching.json');
                } else if (typeof window.openCoachingOverlayFromFile === 'function') {
                    console.log('Bruger window.openCoachingOverlayFromFile');
                    window.openCoachingOverlayFromFile('coaching_templates/compare_coaching.json');
                } else if (typeof openCoachingOverlay === 'function') {
                    console.log('Bruger openCoachingOverlay som fallback');
                    openCoachingOverlay('coaching_templates/compare_coaching.json');
                } else {
                    console.error('Ingen coaching overlay funktion fundet!');
                    alert('Coaching overlay funktion ikke tilgængelig. Sørg for at coaching_overlay_complete.js er indlæst.');
                }
            } catch (e) {
                console.error('writeComparisonDataLeft error:', e);
            }
        }

        function writeComparisonDataRight(traitIndex) {
            try {
                var leftNameEl = document.getElementById('leftName');
                var rightNameEl = document.getElementById('rightName');
                var youName = rightNameEl ? rightNameEl.textContent : '';
                var otherName = leftNameEl ? leftNameEl.textContent : '';

                var leftVal = (typeof leftScores[traitIndex] === 'number') ? leftScores[traitIndex] : 0;
                var rightVal = (typeof rightScores[traitIndex] === 'number') ? rightScores[traitIndex] : 0;

                // use same label orientation as left click
                var trait = defaultTraits[traitIndex];
                var leftLabel = trait.left;
                var rightLabel = trait.right;
                if ((leftScores[traitIndex] || 0) > (rightScores[traitIndex] || 0)) {
                    leftLabel = trait.right;
                    rightLabel = trait.left;
                }
                
                // Convert to all lowercase
                leftLabel = leftLabel.toLowerCase();
                rightLabel = rightLabel.toLowerCase();

                // Get right participant's color, pose and flip status
                var rightColorValue = rightColor || '#ef4444';
                var rightPoseIndex = 0; // Default to standard pose
                var rightPoseFlipped = false;
                
                // Read pose from data-pose attribute on participant element (more reliable than dropdown)
                var rightCircle = document.getElementById('rightCircle');
                if (rightCircle) {
                    var rightParticipant = rightCircle.parentElement;
                    if (rightParticipant) {
                        var dataPose = rightParticipant.getAttribute('data-pose');
                        if (dataPose !== null && dataPose !== '') {
                            rightPoseIndex = Number(dataPose);
                        }
                        var dataMirror = rightParticipant.getAttribute('data-mirror');
                        rightPoseFlipped = dataMirror === 'true';
                    }
                }

                var payload = {
                    "You": youName,
                    "Other": otherName,
                    "You_slider": String(rightVal),
                    "Other_slider": String(leftVal),
                    "left_label": leftLabel,
                    "right_label": rightLabel,
                    "You_color": rightColorValue,
                    "You_pose": rightPoseIndex,
                    "You_pose_flipped": rightPoseFlipped
                };

                localStorage.setItem('compareCoachingData', JSON.stringify(payload));
                console.log('Gemmer compareCoachingData:', payload);
                setStatus('Skrev compareCoachingData (højre) for trait #' + traitIndex);
                
                // Open coaching overlay with compare_coaching.json
                console.log('Kalder openCoachingOverlayFromFile med:', 'coaching_templates/compare_coaching.json');
                console.log('openCoachingOverlayFromFile type:', typeof openCoachingOverlayFromFile);
                console.log('window.openCoachingOverlayFromFile type:', typeof window.openCoachingOverlayFromFile);
                
                if (typeof openCoachingOverlayFromFile === 'function') {
                    console.log('Bruger openCoachingOverlayFromFile direkte');
                    openCoachingOverlayFromFile('coaching_templates/compare_coaching.json');
                } else if (typeof window.openCoachingOverlayFromFile === 'function') {
                    console.log('Bruger window.openCoachingOverlayFromFile');
                    window.openCoachingOverlayFromFile('coaching_templates/compare_coaching.json');
                } else if (typeof openCoachingOverlay === 'function') {
                    console.log('Bruger openCoachingOverlay som fallback');
                    openCoachingOverlay('coaching_templates/compare_coaching.json');
                } else {
                    console.error('Ingen coaching overlay funktion fundet!');
                    alert('Coaching overlay funktion ikke tilgængelig. Sørg for at coaching_overlay_complete.js er indlæst.');
                }
            } catch (e) {
                console.error('writeComparisonDataRight error:', e);
            }
        }


        function setSingleTraitScore(traitId, side, value) {
            if (side === 'left') {
                leftScores[traitId] = parseInt(value);
            } else {
                rightScores[traitId] = parseInt(value);
            }
            
            if (currentStep === 3) {
                updateComparisonResults();
                calculateAndDisplayScores();
            }
        }
        
        // Save slider score when slider is released (mouseup/touchend)
        async function saveSliderScoreOnRelease(traitId, side) {
            await syncCurrentWorkspaceToActiveComparison();
        }

        function switchToStep(step) {
            currentStep = step;
            
            // Update step content visibility
            document.querySelectorAll('.step-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`step${step}`).classList.add('active');
            
            // Update step buttons
            document.querySelectorAll('.step-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelectorAll('.step-btn')[step - 1].classList.add('active');
            
            // Update progress dots
            document.querySelectorAll('.progress-dot').forEach((dot, index) => {
                dot.classList.remove('active', 'completed');
                if (index + 1 === step) {
                    dot.classList.add('active');
                } else if (index + 1 < step) {
                    dot.classList.add('completed');
                }
            });
            
            // Update title
            const leftName = document.getElementById('leftName').textContent || 'Venstre del';
            const rightName = document.getElementById('rightName').textContent || 'Højre del';
            const titles = [
                `Trin 1: Udfyld for ${leftName}`,
                `Trin 2: Udfyld for ${rightName}`,
                `Trin 3: Sammenlign resultaterne`
            ];
            document.getElementById('stepTitle').textContent = titles[step - 1];
            
            if (step === 3) {
                updateComparisonResults();
                calculateAndDisplayScores();
            }
            
            // Update button states when switching steps
            updateButtonStates();
        }

        function updateComparisonResults() {
            const leftName = document.getElementById('leftName').textContent || 'Venstre del';
            const rightName = document.getElementById('rightName').textContent || 'Højre del';
            const resultsContainer = document.getElementById('comparisonResults');
            if (resultsContainer) {
                resultsContainer.innerHTML = createComparisonResultsHTML(leftName, rightName);
            }
        }

        function calculateAndDisplayScores() {
            let totalSimilarity = 0;
            let totalDifference = 0;
            let count = 0;
            
            const activeTraits = getActiveTraits();
            activeTraits.forEach(({ index }) => {
                const leftScore = leftScores[index];
                const rightScore = rightScores[index];
                
                if (leftScore !== undefined && rightScore !== undefined) {
                    const difference = Math.abs(leftScore - rightScore);
                    const similarity = 100 - difference;
                    
                    totalSimilarity += similarity;
                    totalDifference += difference;
                    count++;
                }
            });
            
            if (count > 0) {
                const avgSimilarity = totalSimilarity / count;
                const avgDifference = totalDifference / count;
                
                updateSpeedometer('similarity', avgSimilarity);
                updateSpeedometer('difference', avgDifference);
            } else {
                updateSpeedometer('similarity', 0);
                updateSpeedometer('difference', 0);
            }
        }

        function updateSpeedometer(type, percentage) {
            const circumference = 2 * Math.PI * 40; // radius = 40
            const offset = circumference - (percentage / 100) * circumference;
            
            const fillElement = document.getElementById(`${type}Fill`);
            const valueElement = document.getElementById(`${type}Value`);
            
            if (fillElement && valueElement) {
                fillElement.style.strokeDashoffset = offset;
                valueElement.textContent = Math.round(percentage) + '%';
            }
        }

        function randomizeCurrentStep() {
            // Only work on steps 1 and 2
            if (currentStep !== 1 && currentStep !== 2) return;
            
            const side = currentStep === 1 ? 'left' : 'right';
            
            // Generate random values for all traits (-50 to 50)
            const activeTraits = getActiveTraits();
            if (activeTraits.length === 0) {
                return;
            }
            activeTraits.forEach(({ index }) => {
                const randomValue = Math.floor(Math.random() * 101) - 50;
                
                if (side === 'left') {
                    leftScores[index] = randomValue;
                } else {
                    rightScores[index] = randomValue;
                }
                
                const slider = document.querySelector(`input[data-trait-id="${index}"][data-side="${side}"]`);
                if (slider) {
                    slider.value = randomValue;
                }
            });
            
            // Update comparison view if we're on step 3
            if (currentStep === 3) {
                updateComparisonResults();
                calculateAndDisplayScores();
            }
            
            // Show feedback
            const sideName = side === 'left' ? 'venstre' : 'højre';
            setStatus(`Tilfældige værdier sat for ${sideName} del`);
        }

        // CSV import/export functions removed - no longer needed

        async function clearAll() {
			// Reset all sliders to 0
			leftScores = {};
			rightScores = {};
			
			// Select 6 new random traits
			const indices = Array.from({ length: defaultTraits.length }, (_, idx) => idx);
			for (let i = indices.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[indices[i], indices[j]] = [indices[j], indices[i]];
			}
			activeTraitIndices = indices.slice(0, ACTIVE_TRAIT_COUNT).sort((a, b) => a - b);
			currentTraitSelectionKey = null;
		
			// Set participants to "Venstre" and "Højre"
			const leftNameEl = document.getElementById('leftName');
			const rightNameEl = document.getElementById('rightName');
			if (leftNameEl) leftNameEl.textContent = 'Venstre';
			if (rightNameEl) rightNameEl.textContent = 'Højre';
			
			// Reset colors
			leftColor = '#3b82f6';
			rightColor = '#ef4444';
			leftLightColor = lightenColor(leftColor, 0.6);
			rightLightColor = lightenColor(rightColor, 0.6);
			
			// Reset step
			currentStep = 1;
			
			// Clear notes
			comparisonNotes = '';
			const notesTextarea = document.getElementById('comparisonNotes');
			if (notesTextarea) notesTextarea.value = '';
			
			// Clear dropdowns
            document.getElementById('leftDropdown').value = '';
            document.getElementById('rightDropdown').value = '';
			
			// Show circles with default participants
            const leftCircle = document.getElementById('leftCircle');
            const rightCircle = document.getElementById('rightCircle');
			if (leftCircle && !isInitialLoad) {
            leftCircle.style.display = 'flex';
				const head = leftCircle.querySelector('.head');
				if (head) {
					head.style.background = `linear-gradient(135deg, ${leftColor}, ${leftColor})`;
				}
				updateBodyColors('left', leftColor);
			}
			if (rightCircle && !isInitialLoad) {
            rightCircle.style.display = 'flex';
				const head = rightCircle.querySelector('.head');
				if (head) {
					head.style.background = `linear-gradient(135deg, ${rightColor}, ${rightColor})`;
				}
				updateBodyColors('right', rightColor);
			}
			
			// Update slider colors
            updateSliderColors();
            
			// Reset pose and mirror to standard
    const leftPose = document.getElementById('leftPose');
    const rightPose = document.getElementById('rightPose');
    const leftMirror = document.getElementById('leftMirror');
    const rightMirror = document.getElementById('rightMirror');
    
			// Reset to standard pose
			resetPose('left');
			resetPose('right');
			
			// Clear mirror checkboxes
    if (leftMirror) leftMirror.checked = false;
    if (rightMirror) rightMirror.checked = false;
    
			// Update data-mirror attributes
			const leftParticipant = leftCircle ? leftCircle.closest('.participant') : null;
			const rightParticipant = rightCircle ? rightCircle.closest('.participant') : null;
			if (leftParticipant) {
				leftParticipant.setAttribute('data-mirror', 'false');
			}
			if (rightParticipant) {
				rightParticipant.setAttribute('data-mirror', 'false');
			}
    
			// Update UI
    updateComparisonView();
    updateButtonStates();
			
			// Sync to active comparison (this will save the cleared state to the active history item)
			await syncCurrentWorkspaceToActiveComparison();
}

        // CSV data persistence functions removed - no longer needed

// adjustDistance function removed - distance functionality no longer needed



        function confirmBackToOpstilling() {
            if (confirm('Brug "Gem Sammenligning" hvis du vil beholde dit arbejde.\n\nVil du fortsætte til Relations Opstilling?')) {
                window.location.href = 'opstilling_01.html';
            }
        }

        // Wait for Firebase auth state to be ready
        if (auth) {
            auth.onAuthStateChanged(user => {
                currentUser = user;
                
                // Mark auth as ready and resolve promise
                if (!authStateReady) {
                    authStateReady = true;
                    if (authStateResolver) {
                        authStateResolver();
                        authStateResolver = null;
                    }
                }
            });
        }

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', async function() {
            // GUARD 1: Extend initial load period - wait for ALL
            
            // 1. Wait for auth state (max 3 seconds)
            try {
                await Promise.race([
                    authStatePromise,
                    new Promise(resolve => setTimeout(resolve, 3000))
                ]);
            } catch (e) {
                console.warn('Auth state wait error:', e);
            }
            
            // Resolve manually if not resolved yet
            if (!authStateReady && authStateResolver) {
                authStateResolver();
                authStateResolver = null;
            }
            
            // 2. Check if user is logged in - require login
            if (!currentUser) {
                alert('Du skal være logget ind for at bruge denne side. Redirecter til login...');
                window.location.href = 'index.html';
                return;
            }
            
            // 3. Load data ÉN gang
            const data = await loadCompareData();
            if (data) {
                CompareData = data;
            } else {
                // No data in Firestore, create defaults
                CompareData = null;
                await ensureDefaultCompareData();
            }
            console.log('[INIT] Loaded compare data, collections:', CompareData?.collections?.length || 0);
            
            // 5. Wait for DOM to be fully rendered
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // 6. Mark initial load complete (for UI updates only, not for blocking saves)
            isInitialLoad = false;
            console.log('[INIT] Initial load complete');
            
            // Load pose library first
            await loadPoseLibrary();
            // Load animations
            await loadAnimations();
            // Initialize color picker grid
            const grid = document.getElementById('colorGrid');
            
            for(let row = 0; row < 14; row++) {
                for(let col = 0; col < 12; col++) {
                    let hex;
                    
                    if(row === 0) {
                        const hue = Math.round(col * 360/12);
                        hex = hslToHex(hue, 95, 50);
                    } else if(row === 1) {
                        const light = Math.round(100 - (col * (100/11)));
                        hex = hslToHex(0, 0, light);
                    } else {
                        const gridRow = row - 2;
                        const hue = Math.round(col * 360/12);
                        const light = Math.round(92 - (gridRow * (84/11)));
                        const satBase = 86;
                        const sat = Math.round(satBase - Math.abs((col - 6)/ 6) * 20);
                        hex = hslToHex(hue, sat, light);
                    }
                    
                    const swatch = document.createElement('button');
                    swatch.className = 'swatch';
                    swatch.style.background = hex;
                    swatch.dataset.hex = hex;
                    swatch.title = hex;
                    swatch.setAttribute('aria-label', `Farve ${hex}`);
                    swatch.tabIndex = 0;
                    
                    swatch.addEventListener('click', () => selectColor(hex));
                    
                    grid.appendChild(swatch);
                }
            }
            
            // Event listeners
            document.getElementById('colorPickerModal').addEventListener('click', function(e) {
                if (e.target === this) closeColorPicker();
            });

            // Load shared characters first (inject into partsData), then build dropdowns
            initializeDropdowns();
			initializePoseDropdowns();  
            
            // Listen for localStorage changes (cross-tab synchronization)
            window.addEventListener('storage', function(e) {
                if (e.key === 'relationsSetupData') {
                    (window.__APP_DEBUG__ && console.log('localStorage relationsSetupData updated, refreshing comparison dropdowns...'));
                    handleStorageUpdate();
                }
            });
            
            document.getElementById('leftDropdown').addEventListener('change', () => updateParticipant('left'));
            document.getElementById('rightDropdown').addEventListener('change', () => updateParticipant('right'));
            
            // Name is only editable via the "N" button
            const leftNameEl = document.getElementById('leftName');
            const rightNameEl = document.getElementById('rightName');
            if (leftNameEl) {
                leftNameEl.contentEditable = 'false';
                leftNameEl.style.cursor = 'default';
            }
            if (rightNameEl) {
                rightNameEl.contentEditable = 'false';
                rightNameEl.style.cursor = 'default';
            }
            
            document.getElementById('leftColorBtn').addEventListener('click', function(e) {
                e.stopPropagation();
                openColorPicker(this, 'left');
            });
            document.getElementById('rightColorBtn').addEventListener('click', function(e) {
                e.stopPropagation();
                openColorPicker(this, 'right');
            });
			
			// Pose picker modal close on outside click
			document.getElementById('posePickerModal').addEventListener('click', function(e) {
				if (e.target === this) {
					closePosePicker();
				}
			});

			// Pose buttons
			document.getElementById('leftPoseBtn').addEventListener('click', function(e) {
				e.stopPropagation();
				openPosePicker(this);
			});
			document.getElementById('rightPoseBtn').addEventListener('click', function(e) {
				e.stopPropagation();
				openPosePicker(this);
			});
			
			document.getElementById('leftNoteBtn').addEventListener('click', function(e) {
				e.stopPropagation();
				openNoteOverlay(this);
			});
			document.getElementById('rightNoteBtn').addEventListener('click', function(e) {
				e.stopPropagation();
				openNoteOverlay(this);
			});
			
			// Note overlay - close when clicking outside
			document.addEventListener('click', function(e) {
				const noteOverlay = document.getElementById('noteOverlay');
				if (noteOverlay && noteOverlay.classList.contains('show')) {
					if (!noteOverlay.contains(e.target)) {
						closeNoteOverlay();
					}
				}
			});
			
			// Prevent clicks inside note overlay from closing it
			const noteOverlay = document.getElementById('noteOverlay');
			if (noteOverlay) {
				noteOverlay.addEventListener('click', function(e) {
					e.stopPropagation();
				});
			}
            
			// Save when pose changes via dropdown
			const leftPoseDropdown = document.getElementById('leftPose');
			const rightPoseDropdown = document.getElementById('rightPose');
			if (leftPoseDropdown) {
				leftPoseDropdown.addEventListener('change', async function() {
					const poseIndex = this.value;
					if (poseIndex) {
						applyPose('left', poseIndex);
					} else {
						resetPose('left');
					}
					await syncCurrentWorkspaceToActiveComparison();
				});
			}
			if (rightPoseDropdown) {
				rightPoseDropdown.addEventListener('change', async function() {
					const poseIndex = this.value;
					if (poseIndex) {
						applyPose('right', poseIndex);
					} else {
						resetPose('right');
					}
					await syncCurrentWorkspaceToActiveComparison();
				});
			}
			
			// Save when mirror changes
			const leftMirror = document.getElementById('leftMirror');
			const rightMirror = document.getElementById('rightMirror');
			if (leftMirror) {
				leftMirror.addEventListener('change', function() {
					toggleMirror('left');
				});
			}
			if (rightMirror) {
				rightMirror.addEventListener('change', function() {
					toggleMirror('right');
				});
			}
            
            document.querySelector('.clear-btn').addEventListener('click', clearAll);
            document.getElementById('randomBtn').addEventListener('click', randomizeCurrentStep);
            
            // CompareData is already loaded above in GUARD 1
            
            // Initialize history sidebar
            // Default to collapsed (true) unless explicitly set to false in localStorage
            const savedCollapsed = localStorage.getItem('compare_historySidebarCollapsed');
            historySidebarCollapsed = savedCollapsed === null || savedCollapsed === 'true';
            const sidebar = document.getElementById('historySidebar');
            if (sidebar) {
                if (historySidebarCollapsed) {
                    sidebar.classList.add('collapsed');
                } else {
                    sidebar.classList.remove('collapsed');
                }
            }
            
            // Initialize samling manager elements
            samlingManagerOverlayEl = document.getElementById('samlingManagerOverlay');
            samlingManagerListEl = document.getElementById('samlingManagerList');
            newSamlingNameInputEl = document.getElementById('newSamlingName');
            newSamlingColorBtnEl = document.getElementById('newSamlingColorBtn');
            samlingColorPickerModalEl = document.getElementById('samlingColorPickerModal');
            samlingColorGridEl = document.getElementById('samlingColorGrid');
            
            // Build color grid
            if (samlingColorGridEl) {
                buildSamlingColorGrid();
            }
            
            // Load active comparison
            const activeComparison = getActiveComparison();
            if (activeComparison) {
                loadComparisonFromCompareData(activeComparison);
            } else {
                // If no active comparison, ensure default participants (Venstre/Højre) are visible
                const leftCircle = document.getElementById('leftCircle');
                const rightCircle = document.getElementById('rightCircle');
                const leftNameEl = document.getElementById('leftName');
                const rightNameEl = document.getElementById('rightName');
                
                // Set default colors
                if (!leftColor) leftColor = '#3b82f6';
                if (!rightColor) rightColor = '#ef4444';
                leftLightColor = lightenColor(leftColor, 0.6);
                rightLightColor = lightenColor(rightColor, 0.6);
                
                // Ensure circles are visible with default names (only after initial load)
                if (leftCircle && !isInitialLoad) {
                    leftCircle.style.display = 'flex';
                    const head = leftCircle.querySelector('.head');
                    if (head) {
                        head.style.background = `linear-gradient(135deg, ${leftColor}, ${leftColor})`;
                    }
                    updateBodyColors('left', leftColor);
                }
                if (rightCircle && !isInitialLoad) {
                    rightCircle.style.display = 'flex';
                    const head = rightCircle.querySelector('.head');
                    if (head) {
                        head.style.background = `linear-gradient(135deg, ${rightColor}, ${rightColor})`;
                    }
                    updateBodyColors('right', rightColor);
                }
                
                // Set default names
                if (leftNameEl) leftNameEl.textContent = 'Venstre';
                if (rightNameEl) rightNameEl.textContent = 'Højre';
                
                // Ensure we have active traits
                ensureActiveTraits();
                
                updateSliderColors();
                updateComparisonView();
            }
            
            // Render history
            renderHistory();
            
            // Setup history color picker event listeners
            const historyRemoveColorBtn = document.getElementById('historyRemoveColorBtn');
            if (historyRemoveColorBtn) {
                historyRemoveColorBtn.addEventListener('click', removeHistoryColor);
            }
            
            // Modal backdrop click to close history color picker
            const historyColorPickerModalEl = document.getElementById('historyColorPickerModal');
            if (historyColorPickerModalEl) {
                historyColorPickerModalEl.addEventListener('click', (e) => {
                    if (e.target === historyColorPickerModalEl) {
                        closeHistoryColorPicker();
                    }
                });
            }
            
            // Setup event listeners
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (historyColorPickerModalEl && historyColorPickerModalEl.classList.contains('show')) {
                        closeHistoryColorPicker();
                    }
                }
            });
            
            updateButtonStates();
            
            // Navigation overlay functionality - optimized with event delegation
            const navBox = document.getElementById('navBox');
            const navToggleBtn = document.querySelector('.nav-toggle-btn');
            
            if (navBox) {
                // Mark current page as active
                const currentPage = 'compare_01.html';
                const navButtons = document.querySelectorAll('.nav-button');
                navButtons.forEach(btn => {
                    if (btn.getAttribute('href') === currentPage || btn.textContent.trim() === 'Ligheder') {
                        btn.classList.add('active');
                    }
                });
                
                // Use event delegation for nav button clicks (only one listener instead of multiple)
                navBox.addEventListener('click', function(e) {
                    const navButton = e.target.closest('.nav-button');
                    if (navButton) {
                        e.stopPropagation();
                        navBox.classList.remove('show');
                        const href = navButton.getAttribute('href');
                        if (href) {
                            window.location.href = href;
                        }
                    }
                });
            }
            
            // Close nav box when clicking outside - single listener
            document.addEventListener('click', function(e) {
                if (navBox && navBox.classList.contains('show')) {
                    if (!navBox.contains(e.target) && e.target !== navToggleBtn && !navToggleBtn?.contains(e.target)) {
                        navBox.classList.remove('show');
                    }
                }
            });
        });
        
        // Navigation overlay toggle function
        function toggleNavBox() {
            const navBox = document.getElementById('navBox');
            const navToggleBtn = document.querySelector('.nav-toggle-btn');
            
            if (navBox && navToggleBtn) {
                const isShowing = navBox.classList.contains('show');
                if (isShowing) {
                    navBox.classList.remove('show');
                } else {
                    // Position nav-box at top-left corner of toggle button
                    const rect = navToggleBtn.getBoundingClientRect();
                    navBox.style.top = rect.top + 'px';
                    navBox.style.left = rect.left + 'px';
                    navBox.classList.add('show');
                }
            }
        }
    </script>
    
    <!-- Navigation overlay -->
    <div class="nav-overlay" id="navOverlay"></div>
</body>
</html>