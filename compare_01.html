<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="imagefiles/apple-touch-icon.png">
    <title>Forskelle og Ligheder</title>
    <!-- Firebase SDK v8.10.1 -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 0px;
            overflow-x: hidden;
        }
        
        .comparison-container {
            width: 100%;
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 0px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow: visible;
        }
        
        .header {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            padding: 16px 24px;
            text-align: center;
            border-radius: 0px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .header h1 {
            font-size: 2.0em;
            margin-bottom: 0px;
            font-weight: 300;
            width: 100%;
            text-align: center;
        }

        .header .nav-controls {
            position: absolute;
            top: 16px;
            left: 24px;
            display: inline-flex;
            flex-direction: column;
            gap: 0;
            align-items: flex-start;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .controls-bar {
            background: #f8fafc;
            padding: 12px 20px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .dropdown-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .dropdown-label {
            font-size: 14px;
            font-weight: 500;
            color: #374151;
            white-space: nowrap;
        }
        
        .participant-dropdown {
            padding: 8px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 15px;
            font-family: inherit;
            background: white;
            min-width: 160px;
            color: #374151;
            transition: all 0.3s ease;
        }
        
        .participant-dropdown:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        .controls-divider {
            width: 1px;
            height: 30px;
            background: #e2e8f0;
            margin: 0 8px;
            flex-shrink: 0;
        }
        
        /* Navigation overlay */
        .nav-toggle-btn {
            width: 35px;
            height: 35px;
            padding: 5px 8px;
            border: none;
            border-radius: 12px;
            background: #e5e7eb;
            color: #374151;
            box-shadow: 0 12px 26px rgba(15, 23, 42, 0.16);
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            cursor: pointer;
            transition: all 0.25s ease;
        }
        
        .nav-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(107, 114, 128, 0.3);
        }

        .nav-toggle-btn span {
            width: 16px;
            height: 2px;
            border-radius: 999px;
            background: #374151;
        }
        
        .nav-overlay {
            display: none !important;
        }
        
        .nav-box {
            position: fixed;
            top: 0;
            left: 0;
            background: white;
            border-radius: 20px;
            padding: 20px 25px;
            z-index: 9999;
            display: none;
            flex-direction: column;
            gap: 10px;
            min-width: 200px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        
        .nav-box.show {
            display: flex;
        }
        
        .nav-button {
            padding: 8px 16px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            text-align: center;
            display: block;
            min-width: auto;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
        }
        
        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }
        
        .nav-button.active {
            background: #9ca3af !important;
            cursor: default;
            pointer-events: none;
        }
        .nav-button.nav-checkin {
            background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);
        }
        .nav-button.nav-checkin:hover:not(.active) {
            background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
            box-shadow: 0 5px 15px rgba(124, 58, 237, 0.3);
        }
        
        .nav-button:nth-child(1) {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        
        .nav-button:nth-child(1):hover:not(.active) {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }
        
        .nav-button:nth-child(2) {
            background: linear-gradient(135deg, #E6B94F 0%, #d97706 100%);
        }
        
        .nav-button:nth-child(2):hover:not(.active) {
            background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
            box-shadow: 0 5px 15px rgba(245, 158, 11, 0.3);
        }
        
        .nav-button:nth-child(3) {
            background: linear-gradient(135deg, #3368AE 0%, #1e40af 100%);
        }
        
        .nav-button:nth-child(3):hover:not(.active) {
            background: linear-gradient(135deg, #1e40af 0%, #1e3a8a 100%);
            box-shadow: 0 5px 15px rgba(37, 99, 235, 0.3);
        }
        
        .nav-button:nth-child(4) {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
        }
        
        .nav-button:nth-child(4):hover:not(.active) {
            background: linear-gradient(135deg, #db2777 0%, #be185d 100%);
            box-shadow: 0 5px 15px rgba(236, 72, 153, 0.3);
        }
        
        .nav-button:nth-child(5) {
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
        }
        
        .nav-button:nth-child(5):hover:not(.active) {
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
            box-shadow: 0 5px 15px rgba(71, 85, 105, 0.3);
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .clear-btn { background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; }
        .save-btn { background: linear-gradient(135deg, #059669 0%, #047857 100%); color: white; }
        .random-btn { background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white; }
        .back-btn { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; }
        
        .btn:disabled { 
            background: #9ca3af !important; 
            cursor: not-allowed; 
        }
        .btn:hover:not(:disabled) { transform: translateY(-1px); }
        
        .participants-section {
            background: #f8fafc;
            padding: 0;
            border-bottom: 2px solid #e2e8f0;
            height: 250px;
            flex-shrink: 0;
            overflow: visible;
            position: relative;
        }
        
        .participants-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
            max-width: 700px;
            margin: 0 auto;
            gap: 75px;
            height: 100%;
            overflow: visible;
            position: relative;
        }

        
        
        .participant {
            flex: 0 0 200px;
            margin-top: -160px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            position: relative;
            overflow: visible;
            transform-origin: center center;
            min-width: 200px;
        }
        
        .participant-circle {
		width: 72px;
		height: 72px;
		border-radius: 50%;
		background: transparent;
		border: none;
		display: flex;
		align-items: center;
		justify-content: center;
		color: white;
		font-weight: bold;
		font-size: 10px;
		text-align: center;
		position: relative;
		padding: 5px;
		line-height: 1.1;
		z-index: 10;
		pointer-events: none;
	}
	.head {
		position: absolute;
		top: -74px;
		left: 50%;
		transform: translateX(-50%);
		width: 72px;
		height: 72px;
		border-radius: 50%;
		background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
		display: flex;
		align-items: center;
		justify-content: center;
		color: white;
		font-weight: bold;
		font-size: 10px;
		text-align: center;
		box-shadow: 0 8px 25px rgba(0,0,0,0.15);
		padding: 10px;
		line-height: 1.2;
		z-index: 5;
		pointer-events: auto;
		opacity: 1;
	}

.head span {
    font-size: 12px;
}


        /* New Advanced Figure Structure */
	.participant-body {
		position: absolute;
		top: 76px;
		
		transform-origin: 50px -40px;
		z-index: 5;
		pointer-events: none;
		width: 100px;
		height: 200px;
	}

	/* Torso */
	/* Torso */
.participant-torso {
    position: absolute;
    width: 54px;
    height: 72px;
    background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
    border-radius: 22px 22px 15px 15px;
    box-shadow: 0 3px 12px rgba(0,0,0,0.15);
    top: -2px;
	

    z-index: 8;
}

	/* Højre arm hierarki */
.skulder_translate_right {
    position: absolute;
    top: 0px;
    left: 62px;
    width: 15px;
    height: 15px;
    background: rgba(59, 130, 246, 0.0);
    z-index: 3;
}

.skulder_translate_right.front-arm {
    z-index: 15;
}

.skulder_rotate_right {
    width: 100%;
    height: 100%;
    background: rgba(239, 68, 68, 0.0);
    transform-origin: center center;
}

.arm_geo_right {
    width: 50px;
    height: 18px;
    background: #f59e0b;
    border-radius: 9px;
    position: relative;
    top: -1px;
    left: -1px;
}

.albue_rotate_right {
    position: relative;
    top: 1px;
    left: 34px;
    width: 15px;
    height: 15px;
    background: rgba(16, 185, 129, 0.0);
    transform-origin: center center;
}

.albue_geo_right {
    position: relative;
    top: -1px;
    left: 1px;
    width: 50px;
    height: 18px;
    background: #f59e0b;
    border-radius: 9px;
    z-index: 4;
}

.albue_geo_right.front {
    z-index: 20 !important;
    position: relative;
}

	/* Venstre arm hierarki */
.skulder_translate_left {
    position: absolute;
    top: 0px;
    left: 22px;
    width: 15px;
    height: 15px;
    background: rgba(59, 130, 246, 0.0);
    z-index: 3;
}

.skulder_translate_left.front-arm {
    z-index: 15;
}

.skulder_rotate_left {
    width: 100%;
    height: 100%;
    background: rgba(239, 68, 68, 0.0);
    transform-origin: center center;
}

.arm_geo_left {
    width: 50px;
    height: 18px;
    background: #f59e0b;
    border-radius: 9px;
    position: relative;
    top: -1px;
    left: -34px;
}

.albue_rotate_left {
    position: relative;
    top: 1px;
    left: 0px;
    width: 15px;
    height: 15px;
    background: rgba(16, 185, 129, 0.0);
    transform-origin: center center;
}

.albue_geo_left {
    position: relative;
    top: -1px;
    left: -33px;
    width: 50px;
    height: 18px;
    background: #f59e0b;
    border-radius: 9px;
    z-index: 4;
}

.albue_geo_left.front {
    z-index: 20 !important;
    position: relative;
}

	/* Højre ben hierarki */
.hofte_translate_right {
    position: absolute;
    top: 68px;
    left: 58px;
    width: 15px;
    height: 15px;
    background: rgba(59, 130, 246, 0.0);
}

.hofte_rotate_right {
    width: 100%;
    height: 100%;
    background: rgba(239, 68, 68, 0.0);
    transform-origin: center center;
}

.laar_geo_right {
    width: 18px;
    height: 55px;
    background: #f59e0b;
    border-radius: 9px;
    position: relative;
    top: -1px;
    left: -1px;
}

.knae_rotate_right {
    position: relative;
    top: 38px;
    left: 1px;
    width: 15px;
    height: 15px;
    background: rgba(16, 185, 129, 0.0);
    transform-origin: center center;
}

.skinneben_geo_right {
    position: relative;
    top: -1px;
    left: -1px;
    width: 18px;
    height: 50px;
    background: #f59e0b;
    border-radius: 9px;
}

/* Venstre ben hierarki */
.hofte_translate_left {
    position: absolute;
    top: 68px;
    left: 26px;
    width: 15px;
    height: 15px;
    background: rgba(59, 130, 246, 0.0);
}

.hofte_rotate_left {
    width: 100%;
    height: 100%;
    background: rgba(239, 68, 68, 0.0);
    transform-origin: center center;
}

.laar_geo_left {
    width: 18px;
    height: 55px;
    background: #f59e0b;
    border-radius: 9px;
    position: relative;
    top: -1px;
    left: -1px;
}

.knae_rotate_left {
    position: relative;
    top: 38px;
    left: 1px;
    width: 15px;
    height: 15px;
    background: rgba(16, 185, 129, 0.0);
    transform-origin: center center;
}

.skinneben_geo_left {
    position: relative;
    top: -1px;
    left: -1px;
    width: 18px;
    height: 50px;
    background: #f59e0b;
    border-radius: 9px;
}

	

        .participant-torso {
            width: 55px;
            height: 80px;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            margin: 0 auto;
            border-radius: 30px 30px 20px 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            position: relative;
            z-index: 5;
        }

        .participant-arms {
            position: absolute;
            top: 0px;
            left: 50%;
            transform: translateX(-50%);
            width: 140px;
            height: 30px;
            z-index: 0;
        }

        .participant-arm-left, .participant-arm-right {
            position: absolute;
            width: 75px;
            height: 20px;
            background: #f59e0b;
            border-radius: 10px;
            transform-origin: right center;
        }

        .participant-arm-left {
            left: -22px;
            top: -5px;
            transform: rotate(-50deg);
        }

        .participant-arm-right {
            right: -22px;
            top: -5px;
            transform: rotate(55deg);
            transform-origin: left center;
        }

        .participant-legs {
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 35px;
            z-index: 0;
        }

        .participant-leg-left, .participant-leg-right {
            position: absolute;
            width: 20px;
            height: 100px;
            background: #f59e0b;
            border-radius: 10px;
            transform-origin: top center;
        }

        .participant-leg-left {
            left: 27px;
            transform: rotate(-10deg);
        }

        .participant-leg-right {
            right: 27px;
            transform: rotate(10deg);
        }
        
        .participant-circle span[contenteditable] {
            outline: none;
            border-radius: 4px;
            padding: 2px;
            transition: all 0.2s ease;
            cursor: default;
        }
        
        .participant-circle span[contenteditable]:focus {
            background-color: white;
            color: black;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.5);
        }

        .color-circle-btn {
            position: absolute;
            bottom: 0px;
            right: 0px;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #a855f7;
            border: 2px solid white;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: bold;
            color: white;
            transition: all 0.3s ease;
            z-index: 150;
            opacity: 0;
			pointer-events: auto;
        }
        
        .color-circle-btn:hover {
            transform: scale(1.1);
            background: #9333ea;
        }
        
		
		#leftPoseBtn, #rightPoseBtn {
    position: absolute;
    bottom: 0px;
    right: 0px;
    width: 25px;
    height: 25px;
    border-radius: 50%;
    background: #06b6d4;
    border: 2px solid white;
    cursor: pointer;
    display: none;
    align-items: center;
    justify-content: center;
    font-size: 9px;
    font-weight: bold;
    color: white;
    transition: all 0.3s ease;
    z-index: 150;
    opacity: 0;
    transform: translate(0px, -25px);
	pointer-events: auto;  
}

#leftPoseBtn:hover, #rightPoseBtn:hover {
    transform: translate(0px, -25px) scale(1.1);
    background: #0891b2;
}

.participant-circle:hover #leftPoseBtn,
.participant-circle:hover #rightPoseBtn {
    display: flex !important;
    opacity: 1;
}
		
		
		
		
        .participant-circle:hover .color-circle-btn {
            display: flex;
            opacity: 1;
        }
        
        .note-circle-btn {
            position: absolute;
            bottom: 0px;
            left: 0px;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #f97316;
            border: 2px solid white;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: bold;
            color: white;
            transition: all 0.3s ease;
            z-index: 150;
            opacity: 0;
			pointer-events: auto;
        }
        
        .note-circle-btn:hover {
            transform: scale(1.1);
            background: #ea580c;
        }
        
        .participant-circle:hover .note-circle-btn {
            display: flex;
            opacity: 1;
        }
        
        /* Name Editor Overlay Styles */
        .note-overlay {
            position: fixed;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            border: 3px solid rgba(226, 232, 240, 0.5);
            z-index: 10000;
            width: 105px;
            display: none;
        }
        
        .note-overlay.show {
            display: block;
        }
        
        .note-overlay textarea {
            width: 100%;
            height: auto;
            min-height: auto;
            max-height: 110px;
            padding: 6px 10px;
            border: 3px solid rgba(226, 232, 240, 0.8);
            border-radius: 6px;
            font-size: 16px;
            font-family: 'Arial', sans-serif;
            resize: none;
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.9);
            color: #374151;
            line-height: 1.4;
            overflow-y: auto;
            word-break: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        
        .note-overlay textarea:focus {
            outline: none;
            border-color: #f97316;
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.1);
        }
        
        #leftName, #rightName {
            pointer-events: auto;
            font-size: 12px;
            display: inline-block;
            min-width: 20px;
            min-height: 16px;
            padding: 2px 4px;
            word-break: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        
        .status {
            text-align: center;
            color: #6b7280;
            font-size: 12px;
            padding: 5px;
        }

        /* Color Picker Styles */
        .color-picker-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }
        
        .color-picker-modal.show {
            display: flex;
        }
        
        .picker {
            width: 224px;
            background: #ffffff;
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border: 1px solid #e2e8f0;
        }
        
        .swatch {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            border: 1px solid rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .swatch:hover {
            transform: scale(1.2);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 10;
        }
        
        .color-grid {
            display: grid;
            grid-template-columns: repeat(12, 15px);
            grid-template-rows: repeat(14, 15px);
            gap: 2px;
            background: transparent;
        }
		
		
		/* Pose Picker Styles */
.pose-picker-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: transparent;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 3000;
}

.pose-picker-modal.show {
    display: flex;
}

.pose-picker {
    width: 280px;
    background: #ffffff;
    padding: 15px;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    border: 1px solid #e2e8f0;
}

.pose-mirror-section {
    text-align: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #e2e8f0;
}

.pose-mirror-label {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    font-size: 14px;
    font-weight: 500;
    color: #374151;
    cursor: pointer;
}

.pose-mirror-label input[type="checkbox"] {
    width: 16px;
    height: 16px;
    transform: scale(1.2);
}

.pose-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
}

.pose-button {
    padding: 8px 12px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    background: white;
    color: #374151;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
}

.pose-button:hover {
    border-color: #3b82f6;
    background: #f0f9ff;
    color: #1d4ed8;
}

.pose-button.active {
    border-color: #3b82f6;
    background: #3b82f6;
    color: white;
}
		
		
		
		
		
        
        /* Comparison Section Styles */
        .comparison-section {
            flex: 1;
            background: white;
            display: flex;
            flex-direction: column;
        }
        
        .comparison-header {
            background: #f1f5f9;
            padding: 15px 20px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .comparison-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #fafafa;
            min-height: 400px;
        }
        
        .step-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            margin-bottom: 20px;
        }
        
        .step-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .step-title {
            font-size: 18px;
            font-weight: bold;
            color: #374151;
        }
        
        .step-nav {
            display: flex;
            gap: 10px;
        }
        
        .step-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .step-btn.active {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
        }
        
        .step-btn:not(.active) {
            background: #e5e7eb;
            color: #6b7280;
        }
        
        .step-btn:hover:not(.active) {
            background: #d1d5db;
        }
        
        .step-content {
            display: none;
        }
        
        .step-content.active {
            display: block;
        }
        
        .single-side-traits {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .single-trait-item {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: 12px;
    padding: 15px;
    background: #f8fafc;
    border-radius: 8px;
    border: 1px solid #e2e8f0;
    width: 100%;
    max-width: 430px;
    margin: 0 auto;
}

#step1 .single-trait-item {
    margin-left: 0;
    margin-right: auto;
}

#step2 .single-trait-item {
    margin-left: auto;
    margin-right: 0;
}
        
  #leftTraits .single-trait-item {
    justify-content: flex-start;
}

#leftTraits .single-slider-container {
    flex: 0 0 auto;
}

#rightTraits .single-trait-item {
    justify-content: flex-end;
}

#rightTraits .single-slider-container {
    flex: 0 0 auto;
}

#comparisonResults > div {
    justify-content: center;
}

#leftTraits .single-trait-item {
    justify-content: flex-start;
}

#leftTraits .single-slider-container {
    flex: 0 0 auto;
}

#rightTraits .single-trait-item {
    justify-content: flex-end;
}

#rightTraits .single-slider-container {
    flex: 0 0 auto;
}

#comparisonResults > div > div {
    justify-content: center;
    margin: 0 auto;
    width: fit-content;
}

.comparison-slider-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
    width: 100%;
}

.comparison-labels {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 15px;
    width: 100%;
}    
        
.single-slider-container {
    display: flex;
    flex-direction: column;
    gap: 6px;
    width: 100%;
}

.single-slider-labels {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

.trait-left-label {
    min-width: 120px;
    text-align: left;
    font-size: 16px;
    color: #4b5563;
    font-weight: 500;
}

.trait-right-label {
    min-width: 120px;
    text-align: right;
    font-size: 16px;
    color: #4b5563;
    font-weight: 500;
}
        
        .single-slider {
    width: 100%;
    max-width: 400px;
    height: 6px;
    border-radius: 3px;
    background: #e2e8f0;
    outline: none;
    cursor: pointer;
    -webkit-appearance: none;
    appearance: none;
}
        
        .single-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }
        
        .single-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        
        .single-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }
        
        .single-slider.left-color::-webkit-slider-thumb {
            background: var(--left-color, #3b82f6);
        }
        
        .single-slider.right-color::-webkit-slider-thumb {
            background: var(--right-color, #3b82f6);
        }
        
        .single-slider.left-color::-moz-range-thumb {
            background: var(--left-color, #3b82f6);
        }
        
        .single-slider.right-color::-moz-range-thumb {
            background: var(--right-color, #3b82f6);
        }
        
        .slider-value {
            min-width: 60px;
            text-align: center;
            font-weight: 500;
            color: #4b5563;
        }
        
        .speedometer-section {
            display: flex;
            justify-content: space-around;
            margin-top: 30px;
            gap: 30px;
        }
        
        .speedometer-container {
            text-align: center;
        }
        
        .speedometer {
            width: 150px;
            height: 150px;
            position: relative;
            margin: 0 auto 10px;
        }
        
        .speedometer svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }
        
        .speedometer-bg {
            fill: none;
            stroke: #e5e7eb;
            stroke-width: 12;
        }
        
        .speedometer-fill {
            fill: none;
            stroke-width: 12;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s ease;
        }
        
        .speedometer-similarity .speedometer-fill {
            stroke: #10b981;
        }
        
        .speedometer-difference .speedometer-fill {
            stroke: #ef4444;
        }
        
        .speedometer-label {
            font-size: 16px;
            font-weight: bold;
            color: #374151;
            margin-bottom: 5px;
        }
        
        .speedometer-value {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .speedometer-similarity .speedometer-value {
            color: #10b981;
        }
        
        .speedometer-difference .speedometer-value {
            color: #ef4444;
        }
        
.comparison-slider-container {
    position: relative;
    width: 100%;
    max-width: 400px;
    height: 20px;
}

.compare-color-btn {
    min-width: 32px;
    height: 32px;
    border-radius: 6px;
    border: 2px solid white;
    color: white;
    font-size: 12px;
    font-weight: bold;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    transition: all 0.2s ease;
}

.compare-color-btn:hover {
    transform: translateY(-1px);
    filter: brightness(1.05);
}

.comparison-labels {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 15px;
}

.comparison-left-label {
    min-width: 120px;
    text-align: left;
    font-size: 16px;
    color: #4b5563;
    font-weight: 500;
}

.comparison-right-label {
    min-width: 120px;
    text-align: right;
    font-size: 16px;
    color: #4b5563;
    font-weight: 500;
}
        
        .comparison-slider {
            position: absolute;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            cursor: default;
            -webkit-appearance: none;
            pointer-events: none;
            appearance: none;
        }
        
        .comparison-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3b82f6;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            pointer-events: none;
            position: relative;
            z-index: 2;
        }
        
        .comparison-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3b82f6;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            pointer-events: none;
        }
        
        .comparison-slider.left-color::-webkit-slider-thumb {
            background: var(--left-color, #3b82f6);
        }
        
        .comparison-slider.right-color::-webkit-slider-thumb {
            background: var(--right-color, #ef4444);
        }
        
        .comparison-slider.left-color::-moz-range-thumb {
            background: var(--left-color, #3b82f6);
        }
        
        .comparison-slider.right-color::-moz-range-thumb {
            background: var(--right-color, #ef4444);
        }
        
        .progress-indicators {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #d1d5db;
            transition: all 0.2s ease;
        }
        
        .progress-dot.active {
            background: #3b82f6;
            transform: scale(1.2);
        }
        
        .progress-dot.completed {
            background: #10b981;
        }
        
        .empty-state {
            text-align: center;
            color: #9ca3af;
            font-style: italic;
            padding: 40px;
        }
		
		
/* distance knapper */
.distance-controls-wrapper {
    position: relative;
    height: 0;
    z-index: 200;
	
	
}

.distance-controls {
    position: absolute;
	top: -26px; 
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 12px;
    opacity: 1;
    transition: opacity 0.3s ease;
}

.distance-controls-wrapper:hover .distance-controls,
.participants-section:hover ~ .distance-controls-wrapper .distance-controls {
    opacity: 1;
}


.distance-label {
    font-size: 10px;
    color: #6b7280;
    font-weight: 500;
    white-space: nowrap;
}


.distance-btn {
    width: 30px;
    height: 15px;
    border-radius: 25%;
	background: linear-gradient(135deg, #d1d5db 0%, #9ca3af 100%);
    border: 1px solid white;
    color: white;
    font-size: 12px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    transition: all 0.2s ease;
}

.distance-btn:hover {
    transform: scale(1.1);
    background: linear-gradient(135deg, #9ca3af 0%, #6b7280 100%);  
    box-shadow: 0 4px 12px rgba(0,0,0,0.25);
}

.distance-btn:active {
    transform: scale(0.95);
}
		
		
		
		/* History Sidebar (from opstilling_01.html) */
        .history-sidebar {
            width: 250px;
            background: #f8fafc;
            border-left: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            transform: translateX(0);
            transition: transform 0.3s ease;
            z-index: 4000;
        }
        
        .history-sidebar.collapsed {
            transform: translateX(212px);
        }
        
        .history-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            height: 100%;
        }
        
        .history-sidebar.collapsed .history-content {
            display: none;
        }
        
        .history-sidebar.collapsed .history-header {
            justify-content: center;
            font-size: 0;
            padding-left: 16px;
        }
        
        .history-header {
            background: #e2e8f0;
            padding: 10px 12px 10px 40px;
            text-align: center;
            font-weight: bold;
            color: #374151;
            border-bottom: 2px solid #d1d5db;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
            height: 50px;
            min-height: 50px;
            max-height: 50px;
            box-sizing: border-box;
            position: relative;
        }
        
        .history-filter {
            flex: 1;
            min-width: 180px;
            padding: 6px 14px 6px 16px;
            border-radius: 8px;
            border: 1px solid #cbd5f5;
            background: #ffffff;
            color: #1f2937;
            font-size: 16px;
            font-weight: 600;
            outline: none;
            appearance: none;
            margin: 0 8px 0 0;
            position: relative;
            background-image: linear-gradient(45deg, transparent 50%, #6b7280 50%), linear-gradient(135deg, #6b7280 50%, transparent 50%);
            background-position: calc(100% - 16px) 50%, calc(100% - 9px) 50%;
            background-size: 7px 7px, 7px 7px;
            background-repeat: no-repeat;
        }
        
        .history-filter:focus {
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }
        
        .collapse-toggle {
            position: absolute;
            left: 2px;
            top: 12px;
            background: #4f46e5;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s ease;
            z-index: 100;
            padding: 0;
        }
        
        .collapse-toggle:hover {
            background: #4338ca;
            transform: scale(1.1);
        }
        
        .collapse-toggle-bottom {
            top: auto;
            bottom: 8px;
        }
        
        .history-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: #e2e8f0;
            border-bottom: 1px solid #d1d5db;
            flex-shrink: 0;
        }
        
        .nav-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: white !important;
            cursor: pointer;
            font-size: 0;
            color: black;
            transition: all 0.2s;
            position: relative;
            padding: 0;
        }
        
        .nav-btn::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .nav-btn#navUp::before {
            border-bottom: 12px solid black;
            border-top: none;
        }
        
        .nav-btn#navDown::before {
            border-top: 12px solid black;
            border-bottom: none;
        }
        
        .nav-btn:hover {
            background: #f3f4f6;
        }
        
        .nav-btn:hover::before {
            opacity: 0.7;
        }
        
        .nav-btn:disabled {
            background: #d1d5db;
            color: #9ca3af;
            cursor: not-allowed;
        }
        
        .nav-btn:disabled::before {
            opacity: 0.4;
        }
        
        .history-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px;
            min-height: 0;
        }
        
        .history-item {
            padding: 10px;
            margin-bottom: 6px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            border: 2px solid transparent;
            position: relative;
        }
        
        .history-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 18px rgba(15, 23, 42, 0.15);
        }
        
        .history-item.active {
            box-shadow: 0 10px 24px rgba(15, 23, 42, 0.25);
        }
        
        .history-item-collection {
            display: inline-flex;
            align-items: center;
            padding: 2px 10px;
            border-radius: 999px;
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 6px;
        }
        
        .history-item-title {
            margin-bottom: 6px;
        }
        
        .history-item-date {
            font-weight: bold;
            font-size: 16px;
            border: none;
            background: transparent;
            outline: none;
            width: 100%;
            padding: 0;
            margin: 0;
            color: inherit;
        }
        
        .history-item.active .history-item-date {
            background: rgba(255, 255, 255, 0.35);
            border-radius: 6px;
            padding: 2px 6px;
            cursor: text;
            transition: background 0.15s ease, box-shadow 0.15s ease;
        }
        
        .history-item.active .history-item-date:hover,
        .history-item.active .history-item-date:focus {
            background: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.25);
        }
        
        .history-item .history-item-date[readonly] {
            cursor: default;
            opacity: 0.95;
        }
        
        .history-item-meta {
            display: flex;
            flex-direction: column;
            font-size: 16px;
            opacity: 0.85;
            gap: 4px;
        }
        
        .history-item-meta-line {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        
        .history-item-time,
        .history-item-participants {
            white-space: nowrap;
        }
        
        .history-item-delete {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: none;
            background: #ef4444;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            line-height: 1;
        }
        
        .history-item:hover .history-item-delete {
            opacity: 1;
        }
        
        .history-item-delete:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        .nav-btn-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Samling Manager Overlay */
        .samling-manager-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 5000;
        }
        
        .samling-manager-overlay.show {
            display: flex;
        }
        
        .samling-manager-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.45);
            backdrop-filter: blur(4px);
        }
        
        .samling-manager-panel {
            position: relative;
            width: min(520px, 90vw);
            max-height: 80vh;
            background: #ffffff;
            border-radius: 18px;
            box-shadow: 0 25px 60px rgba(15, 23, 42, 0.25);
            padding: 24px 28px;
            display: flex;
            flex-direction: column;
            gap: 18px;
            z-index: 1;
        }
        
        .samling-manager-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        
        .samling-manager-header h2 {
            font-size: 1.25rem;
            color: #111827;
        }
        
        .samling-manager-close {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 10px;
            background: #e2e8f0;
            color: #1f2937;
            font-size: 18px;
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s ease;
        }
        
        .samling-manager-close:hover {
            background: #cbd5f5;
            transform: scale(1.05);
        }
        
        .samling-manager-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            padding-right: 6px;
        }
        
        .samling-manager-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 12px;
            border: none;
            background: #f8fafc;
        }
        
        .samling-name-btn {
            flex: 1;
            border: none;
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 16px;
            font-weight: 600;
            text-align: left;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            color: #1f2937;
        }
        
        .samling-name-input {
            flex: 1;
            border: 2px solid #6366f1;
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 16px;
            font-weight: 600;
            outline: none;
            color: #1f2937;
        }
        
        .samling-color-select {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-weight: 700;
            color: white;
            font-size: 16px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        .samling-color-select:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        }
        
        .samling-delete-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 8px;
            background: #ef4444;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s ease;
        }
        
        .samling-delete-btn:hover {
            background: #dc2626;
            transform: scale(1.05);
        }
        
        .samling-manager-divider {
            height: 1px;
            background: #e2e8f0;
            margin: 8px 0;
        }
        
        .samling-manager-new {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 12px;
            border: none;
            background: #f8fafc;
        }
        
        .samling-manager-new input {
            flex: 1;
            border: none;
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 16px;
            outline: none;
            background: white;
            border: 2px solid #e2e8f0;
        }
        
        .samling-manager-new input:focus {
            outline: none;
            border-color: #e2e8f0;
            box-shadow: none;
        }
        
        .samling-manager-actions {
            display: flex;
            gap: 8px;
        }
        
        .samling-create-btn {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            border: none;
            background: #10b981;
            color: white;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s ease;
        }
        
        .samling-create-btn:hover {
            background: #059669;
            transform: scale(1.05);
        }
        
        .samling-color-picker-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 5001;
        }
        
        .samling-color-picker-modal.show {
            display: flex;
        }
        
        .samling-color-picker {
            background: white;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 25px 60px rgba(15, 23, 42, 0.3);
            max-width: 400px;
            width: 90vw;
        }
        
        .samling-color-picker-header {
            margin-bottom: 16px;
        }
        
        .samling-color-picker-header h3 {
            font-size: 1.1rem;
            color: #111827;
            margin: 0;
        }
        
        .samling-color-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
        }
        
        .samling-color-swatch {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 10px;
            border: 3px solid transparent;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .samling-color-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .samling-color-swatch.selected {
            border-color: #1f2937;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
        }
        
        /* Comparison section needs to be relative for history sidebar positioning */
        .comparison-section {
            position: relative;
        }
    
    /* Touch devices adjustments */
    @media (hover: none) and (pointer: coarse) {
        body { padding: 0px; }
        .header { padding: 5px; }
        .header h1 { font-size: 2.0em; margin-bottom: 0; }
        .comparison-container { border-radius: 20px; }
        .controls-bar { padding: 8px 12px; gap: 10px; }
        .participant-dropdown { font-size: 13px; padding: 6px 10px; border-radius: 8px; }
        .btn { padding: 6px 12px; font-size: 13px; border-radius: 8px; }
    }
    </style>
</head>
<body>
    <div class="comparison-container">
        <div class="header">
            <div class="nav-controls">
                <button class="nav-toggle-btn" onclick="toggleNavBox()" title="Navigation">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <div class="nav-box" id="navBox">
                    <a href="opstilling_01.html" class="nav-button">Opstilling</a>
                    <a href="dialog_01.html" class="nav-button">Dialog</a>
                    <a href="compare_01.html" class="nav-button">Ligheder</a>
                    <a href="bodymap_01.html" class="nav-button">BodyMap</a>
                    <a href="logbog_01.html" class="nav-button">Logbog</a>
                    <a href="checkin.html" class="nav-button nav-checkin">Check in</a>
                </div>
            </div>
            <h1>Forskelle og ligheder</h1>
        </div>
        
        <div class="controls-bar">
            <div class="dropdown-group">
                <select class="participant-dropdown" id="leftDropdown"></select>
            </div>
            
            <div class="dropdown-group">
                <select class="participant-dropdown" id="rightDropdown"></select>
            </div>
            
            <div class="controls-divider"></div>
            
            <button class="btn" onclick="openSamlingManager()" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white;">Ny Samling</button>
            <button class="btn" onclick="createNewComparison()" style="background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%); color: white;">Ny Sammenligning</button>
            <button class="btn random-btn" id="randomBtn" disabled>Random</button>
            <button class="btn clear-btn">Ryd Alt</button>
        </div>
        
        <div class="status" id="status">Vælg to dele for at begynde sammenligning</div>
        
        <div class="participants-section">
            <div class="participants-container" id="compareParticipants">
               
			   <div class="participant">
					<div class="participant-circle" id="leftCircle" style="display: flex;">
						<button class="color-circle-btn" id="leftPoseBtn" title="Skift pose">P</button>
						<button class="color-circle-btn" id="leftColorBtn" title="Skift farve">C</button>
						<button class="note-circle-btn" id="leftNoteBtn" title="Rediger navn">N</button>
						
						<div class="participant-body">
							<div class="head">
								<span id="leftName"></span>
							</div>
							
							<div class="participant-torso"></div>
							
							<!-- Venstre arm hierarki -->
							<div class="skulder_translate_left">
								<div class="skulder_rotate_left">
									<div class="arm_geo_left">
										<div class="albue_rotate_left">
											<div class="albue_geo_left"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Højre arm hierarki -->
							<div class="skulder_translate_right">
								<div class="skulder_rotate_right">
									<div class="arm_geo_right">
										<div class="albue_rotate_right">
											<div class="albue_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Venstre ben hierarki -->
							<div class="hofte_translate_left">
								<div class="hofte_rotate_left">
									<div class="laar_geo_left">
										<div class="knae_rotate_left">
											<div class="skinneben_geo_left"></div>
										</div>
									</div>
								</div>
							</div>

							<!-- Højre ben hierarki -->
							<div class="hofte_translate_right">
								<div class="hofte_rotate_right">
									<div class="laar_geo_right">
										<div class="knae_rotate_right">
											<div class="skinneben_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
                
                <div class="participant">
					<div class="participant-circle" id="rightCircle" style="display: flex;">
						<button class="color-circle-btn" id="rightColorBtn" title="Skift farve">C</button>
						<button class="color-circle-btn" id="rightPoseBtn" title="Skift pose">P</button>
						<button class="note-circle-btn" id="rightNoteBtn" title="Rediger navn">N</button>
						
						<div class="participant-body">
							<div class="head">
								<span id="rightName"></span>
							</div>
							
							<div class="participant-torso"></div>
							
							<!-- Venstre arm hierarki -->
							<div class="skulder_translate_left">
								<div class="skulder_rotate_left">
									<div class="arm_geo_left">
										<div class="albue_rotate_left">
											<div class="albue_geo_left"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Højre arm hierarki -->
							<div class="skulder_translate_right">
								<div class="skulder_rotate_right">
									<div class="arm_geo_right">
										<div class="albue_rotate_right">
											<div class="albue_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Venstre ben hierarki -->
							<div class="hofte_translate_left">
								<div class="hofte_rotate_left">
									<div class="laar_geo_left">
										<div class="knae_rotate_left">
											<div class="skinneben_geo_left"></div>
										</div>
									</div>
								</div>
							</div>

							<!-- Højre ben hierarki -->
							<div class="hofte_translate_right">
								<div class="hofte_rotate_right">
									<div class="laar_geo_right">
										<div class="knae_rotate_right">
											<div class="skinneben_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
						</div>
						
						
                    </div>
                </div>
				
				
				
				
            </div>
        </div>
        
        <div class="comparison-section">
            <div class="comparison-header">
                <h3 style="color: #475569; font-size: 16px;">Sammenligning og Analyse</h3>
            </div>
            <div class="comparison-content" id="comparisonContent">
                <div class="empty-state">
                    <h4 style="margin-bottom: 15px; color: #374151;">Sådan bruger du Sammenlignings-værktøjet:</h4>
                    <p style="margin-bottom: 12px; text-align: left;"><strong>1. Vælg dele:</strong> Brug dropdown-menuerne til at vælge to indre dele du vil sammenligne.</p>
                    <p style="margin-bottom: 12px; text-align: left;"><strong>2. Udfyld fakta:</strong> Indtast grundlæggende information om hver del.</p>
                    <p style="margin-bottom: 12px; text-align: left;"><strong>3. Score egenskaber:</strong> Vurder hvor hver del placerer sig på forskellige skalaer.</p>
                    <p style="margin-bottom: 12px; text-align: left;"><strong>4. Fokuser på ligheder:</strong> Se hvor delene minder om hinanden i stedet for kun at fokusere på forskelle.</p>
                    <p style="margin-top: 15px; font-style: italic; color: #6b7280;">Dette værktøj hjælper med at reducere indre konflikt ved at se nuancer og ligheder mellem dele af dig selv.</p>
                </div>
            </div>
            
            <!-- History Sidebar -->
            <div class="history-sidebar" id="historySidebar">
                <div class="history-header">
                    <button class="collapse-toggle" onclick="toggleHistorySidebar()" title="Kollaps/udvid historie">></button>
                    <select id="historyFilter" class="history-filter" onchange="setHistoryFilter(this.value)"></select>
                </div>
                <div class="history-content">
                    <div class="history-navigation">
                        <div class="nav-btn-group">
                            <button class="nav-btn" id="navUp" onclick="navigateHistory(-1)" title="Gå ned"></button>
                            <button class="nav-btn" id="navDown" onclick="navigateHistory(1)" title="Gå op"></button>
                        </div>
                    </div>
                    <div class="history-list" id="historyList"></div>
                </div>
                <button class="collapse-toggle collapse-toggle-bottom" onclick="toggleHistorySidebar()" title="Kollaps/udvid historie">></button>
            </div>
        </div>
    </div>

    <!-- Color Picker Modal -->
    <div class="color-picker-modal" id="colorPickerModal">
        <div class="picker">
            <div class="color-grid" id="colorGrid"></div>
        </div>
    </div>
	
	
	
	<!-- Pose Picker Modal -->
<div class="pose-picker-modal" id="posePickerModal">
    <div class="pose-picker">
        <div class="pose-mirror-section">
            <label class="pose-mirror-label">
                <input type="checkbox" id="posePickerMirror" onchange="togglePosePickerMirror()">
                <span>Spejl</span>
            </label>
        </div>
        <div class="pose-grid" id="poseGrid"></div>
    </div>
</div>

	<!-- Note Overlay -->
	<div class="note-overlay" id="noteOverlay">
		<textarea id="noteTextarea" placeholder="Navn..." maxlength="24"></textarea>
	</div>

    <script src="coaching_engine.js"></script>
    <script src="coaching_overlay_complete.js"></script>
    <script>
        // Wait for script to load and then check
        window.addEventListener('load', function() {
            (window.__APP_DEBUG__ && console.log('Page loaded, checking coaching functions...'));
            (window.__APP_DEBUG__ && console.log('openCoachingOverlayFromFile type:', typeof window.openCoachingOverlayFromFile));
            (window.__APP_DEBUG__ && console.log('CoachEngine type:', typeof window.CoachEngine));
            (window.__APP_DEBUG__ && console.log('CoachEngine class:', typeof CoachEngine));
            
            if (typeof openCoachingOverlayFromFile === 'undefined') {
                (window.__APP_DEBUG__ && console.log('Coaching functions not loaded, adding fallback...'));
                // Simple fallback function
                window.openCoachingOverlayFromFile = function(filename) {
                    (window.__APP_DEBUG__ && console.log('Fallback: Opening coaching overlay from file:', filename));
                    if (typeof openCoachingOverlay !== 'undefined') {
                        openCoachingOverlay('myCoachingProject');
                    } else {
                        alert('Coaching overlay system ikke tilgængeligt');
                    }
                };
            } else {
                (window.__APP_DEBUG__ && console.log('Coaching functions loaded successfully!'));
            }
        });
    </script>
    <script>
        // Firebase Configuration (same as other pages)
        const firebaseConfig = {
            apiKey: "AIzaSyCl6ZYtkfYx3kFF9329eGpeazsmJAPMKzA",
            authDomain: "relationer-fe5fe.firebaseapp.com",
            projectId: "relationer-fe5fe",
            storageBucket: "relationer-fe5fe.firebasestorage.app",
            messagingSenderId: "156720560629",
            appId: "1:156720560629:web:1a138e4e89f02a131f88bc",
            measurementId: "G-K5W7J8ZHZG"
        };

        // Initialize Firebase
        let auth, db, currentUser;
        
        // Flags for race condition protection
        let isInitialLoad = true;
        
        // Auto-save timeout
        let autoSaveTimeout = null;
        
        // Schedule auto-save after changes
        function scheduleAutoSave() {
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }
            
            autoSaveTimeout = setTimeout(async () => {
                await saveCompareDataToFirestore();
                autoSaveTimeout = null;
            }, 2000);
        }

        try {
            firebase.initializeApp(firebaseConfig);
            auth = firebase.auth();
            db = firebase.firestore();
        } catch (error) {
            // If Firebase is already initialized, just get auth and db
            if (error.code === 'app/duplicate-app') {
                auth = firebase.auth();
                db = firebase.firestore();
            } else {
                console.error('Firebase initialization error:', error);
            }
        }

        // Check auth state - create a promise that resolves when auth state is determined
        let authStateReady = false;
        let authStateResolver = null;
        const authStatePromise = new Promise(resolve => {
            authStateResolver = resolve;
        });

        // Load compareData from Firestore
        // Load data from Firestore (simple, no cache)
        async function loadCompareDataFromFirestore() {
            if (!currentUser || !db) return null;
            
            try {
                const userDocRef = db.collection('users').doc(currentUser.uid);
                const doc = await userDocRef.get();
                
                if (!doc.exists) return null;
                return doc.data()?.compareData || null;
            } catch (error) {
                console.error('[LOAD] Error:', error);
                return null;
            }
        }

        // Save compareData to Firestore
        async function saveCompareDataToFirestore() {
            if (!currentUser || !db) return false;
            if (!CompareData) return false;
            
            CompareData.updated = new Date().toISOString();
            
            try {
                await db.collection('users').doc(currentUser.uid).set({
                    compareData: CompareData,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
                
                console.log('[SAVE] Success');
                return true;
            } catch (error) {
                console.error('[SAVE] Error:', error);
                return false;
            }
        }

        let leftColor = null;
        let rightColor = null;
        let leftLightColor = null;
        let rightLightColor = null;
        let currentColorTarget = null;
        let currentColorSide = null;
        let currentStep = 1;
        let leftScores = {};
        let rightScores = {};
		let currentPosePart = null;
		let comparisonNotes = ''; // Text field content
		
		// CompareData structure
		const COMPARE_STORAGE_KEY = 'compareData';
		let CompareData = null;
		let collectionCounter = 1;
		let comparisonCounter = 1;
		let historyFilterCollectionId = null;
		
		// Color presets for collections
		const COMPARE_COLLECTION_COLOR_PRESETS = [
			'#ef4444', '#f97316', '#fbbf24', '#10b981', '#14b8a6', '#0ea5e9',
			'#3b82f6', '#6366f1', '#a855f7', '#ec4899', '#f472b6', '#94a3b8'
		];
		
		// Samling manager state
		let samlingManagerOverlayEl = null;
		let samlingManagerListEl = null;
		let newSamlingNameInputEl = null;
		let newSamlingColorBtnEl = null;
		let samlingColorPickerModalEl = null;
		let samlingColorGridEl = null;
		let samlingColorPickerTarget = null;
		let newSamlingDraftColor = COMPARE_COLLECTION_COLOR_PRESETS[0];
		let newSamlingDraftName = '';
		let newSamlingColorDirty = false;
		
		// History sidebar state
		let historySidebarCollapsed = true; // Default to collapsed
		
		// Helper functions for colors
		function hexToRgba(hex, alpha) {
			if (!hex) {
				return `rgba(232, 220, 198, ${alpha})`;
			}
			const normalized = hex.replace('#', '');
			if (normalized.length === 3) {
				const r = parseInt(normalized[0] + normalized[0], 16);
				const g = parseInt(normalized[1] + normalized[1], 16);
				const b = parseInt(normalized[2] + normalized[2], 16);
				return `rgba(${r}, ${g}, ${b}, ${alpha})`;
			}
			if (normalized.length === 6) {
				const r = parseInt(normalized.substring(0, 2), 16);
				const g = parseInt(normalized.substring(2, 4), 16);
				const b = parseInt(normalized.substring(4, 6), 16);
				return `rgba(${r}, ${g}, ${b}, ${alpha})`;
			}
			return hex;
		}
		
		function lightenHex(hex, amount = 0.5) {
			if (!hex) return '#f2e7d2';
			const normalized = hex.replace('#', '');
			const expand = normalized.length === 3
				? normalized.split('').map(ch => ch + ch).join('')
				: normalized.padEnd(6, '0');
			const r = parseInt(expand.substring(0, 2), 16);
			const g = parseInt(expand.substring(2, 4), 16);
			const b = parseInt(expand.substring(4, 6), 16);
			const clampAmount = Math.max(0, Math.min(1, amount));
			const newR = Math.round(r + (255 - r) * clampAmount);
			const newG = Math.round(g + (255 - g) * clampAmount);
			const newB = Math.round(b + (255 - b) * clampAmount);
			return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
		}
		
		function formatDkDate(dateStr) {
			// Convert ISO date to DD-MM-YYYY for display
			if (typeof dateStr === 'string' && /^\d{4}-\d{2}-\d{2}/.test(dateStr)) {
				const datePart = dateStr.split('T')[0];
				const [y, m, d] = datePart.split('-');
				return `${d}-${m}-${y}`;
			}
			return dateStr || '';
		}
		
		function truncateName(name) {
			if (!name || typeof name !== 'string') return '';
			if (name.length > 10) {
				return name.substring(0, 10) + '..';
			}
			return name;
		}
		
		// CompareData functions
		async function loadCompareData() {
			if (!currentUser || !db) {
				console.error('[LOAD] User not logged in - cannot load data');
				return null;
			}
			
			const firestoreData = await loadCompareDataFromFirestore();
			return firestoreData;
		}
		
		async function saveCompareDataToLocalStorage() {
			// Never save during initial load
			if (isInitialLoad) {
				console.log('[SAVE] Blocked: initial load in progress');
				return false;
			}
			
			if (!currentUser || !db) {
				console.error('[SAVE] User not logged in - cannot save data');
				return false;
			}
			
			try {
				if (!CompareData) return false;
				await saveCompareDataToFirestore();
				return true;
			} catch (error) {
				console.error('Error in saveCompareDataToLocalStorage:', error);
				return false;
			}
		}
		
		async function ensureDefaultCompareData() {
			let dataWasCreated = false;
			
			if (!CompareData || !Array.isArray(CompareData.collections)) {
				CompareData = {
					version: '1.0',
					updated: new Date().toISOString(),
					activeCollectionId: 1,
					activeComparisonId: 1,
					collections: []
				};
				dataWasCreated = true;
			}
			if (!Array.isArray(CompareData.collections) || CompareData.collections.length === 0) {
				CompareData.collections = [{
					id: 1,
					name: 'Samling 1',
					color: COMPARE_COLLECTION_COLOR_PRESETS[0],
					comparisons: []
				}];
				CompareData.activeCollectionId = 1;
				dataWasCreated = true;
			}
			// Ensure all collections have colors
			CompareData.collections.forEach((collection, idx) => {
				if (!collection.color) {
					collection.color = COMPARE_COLLECTION_COLOR_PRESETS[idx % COMPARE_COLLECTION_COLOR_PRESETS.length];
				}
			});
			const collection = CompareData.collections.find(c => c.id === CompareData.activeCollectionId) || CompareData.collections[0];
			if (!collection.comparisons || collection.comparisons.length === 0) {
				const now = new Date().toISOString();
				const initialComparison = {
					id: 1,
					name: 'Sammenligning 1',
					timestamp: now,
					updated: now,
					leftParticipant: {
						name: 'Venstre',
						color: '#3b82f6',
						pose: '',
						flipped: false
					},
					rightParticipant: {
						name: 'Højre',
						color: '#ef4444',
						pose: '',
						flipped: false
					},
					traitNames: [],
					leftScores: {},
					rightScores: {},
					notes: ''
				};
				collection.comparisons = [initialComparison];
				CompareData.activeComparisonId = 1;
				dataWasCreated = true;
			}
			// Ensure all comparisons have timestamps
			CompareData.collections.forEach(collection => {
				if (Array.isArray(collection.comparisons)) {
					collection.comparisons.forEach(comparison => {
						if (!comparison.timestamp) {
							comparison.timestamp = comparison.updated || new Date().toISOString();
						}
						if (!comparison.updated) {
							comparison.updated = comparison.timestamp || new Date().toISOString();
						}
					});
				}
			});
			// Only save if we actually created new data structure
			// This prevents overwriting existing Firestore data with empty data on page load
			if (dataWasCreated) {
				await saveCompareDataToLocalStorage();
			}
		}
		
		function getActiveCollection() {
			if (!CompareData || !Array.isArray(CompareData.collections)) return null;
			return CompareData.collections.find(c => c.id === CompareData.activeCollectionId) || CompareData.collections[0] || null;
		}
		
		function getActiveComparison() {
			const col = getActiveCollection();
			if (!col || !Array.isArray(col.comparisons)) return null;
			return col.comparisons.find(c => c.id === CompareData.activeComparisonId) || col.comparisons[0] || null;
		}
		
		// Debounce timeout for comparison notes
		let comparisonNotesDebounceTimeout = null;

		async function updateComparisonNotes(value) {
			comparisonNotes = value || '';
			
			// Clear previous timeout
			if (comparisonNotesDebounceTimeout) {
				clearTimeout(comparisonNotesDebounceTimeout);
			}
			
			// Debounce: wait 2 seconds after last input
			comparisonNotesDebounceTimeout = setTimeout(async () => {
				await syncCurrentWorkspaceToActiveComparison();
				comparisonNotesDebounceTimeout = null;
			}, 2000);
		}
		
		async function syncCurrentWorkspaceToActiveComparison() {
			// GUARD 2: Never save during initial load or loading
			if (isInitialLoad) {
				console.log('[SYNC] Blocked: initial load in progress');
				return;
			}
			
			
			if (!CompareData) return;
			const comparison = getActiveComparison();
			if (!comparison) return;
			
			// Get active trait names (not indices)
			const activeTraits = getActiveTraits();
			comparison.traitNames = activeTraits.map(({ trait }) => trait);
			
			// Get participant data
			const leftNameEl = document.getElementById('leftName');
			const rightNameEl = document.getElementById('rightName');
			const leftDropdown = document.getElementById('leftDropdown');
			const rightDropdown = document.getElementById('rightDropdown');
			const leftPoseDropdown = document.getElementById('leftPose');
			const rightPoseDropdown = document.getElementById('rightPose');
			const leftMirror = document.getElementById('leftMirror');
			const rightMirror = document.getElementById('rightMirror');
			
			// Get pose from data-pose attribute (most reliable) or fallback to dropdown
			const leftParticipant = document.querySelector('#leftCircle')?.closest('.participant');
			const rightParticipant = document.querySelector('#rightCircle')?.closest('.participant');
			
			// Get pose index from data-pose or dropdown, then convert to pose name
			let leftPoseIndex = leftParticipant?.getAttribute('data-pose') || (leftPoseDropdown ? leftPoseDropdown.value : '');
			let rightPoseIndex = rightParticipant?.getAttribute('data-pose') || (rightPoseDropdown ? rightPoseDropdown.value : '');
			
			// Convert pose index to pose name (like dialog does)
			let leftPoseName = '';
			if (leftPoseIndex !== '' && leftPoseIndex !== null) {
				const poseIdx = parseInt(leftPoseIndex, 10);
				if (!Number.isNaN(poseIdx) && poseLibrary[poseIdx]) {
					leftPoseName = poseLibrary[poseIdx].name;
				}
			}
			
			let rightPoseName = '';
			if (rightPoseIndex !== '' && rightPoseIndex !== null) {
				const poseIdx = parseInt(rightPoseIndex, 10);
				if (!Number.isNaN(poseIdx) && poseLibrary[poseIdx]) {
					rightPoseName = poseLibrary[poseIdx].name;
				}
			}
			
			// Get flipped state from checkbox or data-mirror attribute (checkbox is most reliable)
			const leftFlipped = leftMirror ? leftMirror.checked : (leftParticipant?.getAttribute('data-mirror') === 'true');
			const rightFlipped = rightMirror ? rightMirror.checked : (rightParticipant?.getAttribute('data-mirror') === 'true');
			
			comparison.leftParticipant = {
				name: leftNameEl ? leftNameEl.textContent.trim() : 'Venstre',
				color: leftColor || '#3b82f6',
				pose: leftPoseName || '',
				flipped: leftFlipped
			};
			
			comparison.rightParticipant = {
				name: rightNameEl ? rightNameEl.textContent.trim() : 'Højre',
				color: rightColor || '#ef4444',
				pose: rightPoseName || '',
				flipped: rightFlipped
			};
			
			// Get scores
			comparison.leftScores = { ...leftScores };
			comparison.rightScores = { ...rightScores };
			
			// Get notes
			comparison.notes = comparisonNotes || '';
			
			const now = new Date().toISOString();
			comparison.updated = now;
			if (!comparison.timestamp) {
				comparison.timestamp = now;
			}
			await saveCompareDataToLocalStorage();
		}
		
		async function loadComparisonFromCompareData(comparison) {
			if (!comparison) return;
			
			try {
				
				// Load participants
			const leftCircle = document.getElementById('leftCircle');
			const rightCircle = document.getElementById('rightCircle');
			
			if (comparison.leftParticipant) {
				const leftNameEl = document.getElementById('leftName');
				if (leftNameEl) leftNameEl.textContent = comparison.leftParticipant.name || 'Venstre';
				leftColor = comparison.leftParticipant.color || '#3b82f6';
				leftLightColor = lightenColor(leftColor, 0.6);
				if (leftCircle) {
					leftCircle.style.display = 'flex';
					const head = leftCircle.querySelector('.head');
					if (head) {
						head.style.background = `linear-gradient(135deg, ${leftColor}, ${leftColor})`;
					}
					updateBodyColors('left', leftColor);
				}
				const leftMirror = document.getElementById('leftMirror');
				if (leftMirror) {
					leftMirror.checked = comparison.leftParticipant.flipped || false;
				}
				const leftParticipant = document.querySelector('#leftCircle').closest('.participant');
				if (leftParticipant) {
					leftParticipant.setAttribute('data-mirror', String(comparison.leftParticipant.flipped || false));
				}
				// Apply pose using pose name (like dialog does)
				if (comparison.leftParticipant.pose) {
					applyParticipantPose('left', comparison.leftParticipant.pose, comparison.leftParticipant.flipped || false);
				} else {
					// Reset to default pose if no pose is set
					if (leftParticipant) {
						leftParticipant.removeAttribute('data-pose');
					}
					resetPose('left');
				}
			} else {
				// Default left participant
				const leftNameEl = document.getElementById('leftName');
				if (leftNameEl) leftNameEl.textContent = 'Venstre';
				leftColor = '#3b82f6';
				leftLightColor = lightenColor(leftColor, 0.6);
				if (leftCircle) {
					leftCircle.style.display = 'flex';
					const head = leftCircle.querySelector('.head');
					if (head) {
						head.style.background = `linear-gradient(135deg, ${leftColor}, ${leftColor})`;
					}
					updateBodyColors('left', leftColor);
				}
			}
			
			if (comparison.rightParticipant) {
				const rightNameEl = document.getElementById('rightName');
				if (rightNameEl) rightNameEl.textContent = comparison.rightParticipant.name || 'Højre';
				rightColor = comparison.rightParticipant.color || '#ef4444';
				rightLightColor = lightenColor(rightColor, 0.6);
				if (rightCircle) {
					rightCircle.style.display = 'flex';
					const head = rightCircle.querySelector('.head');
					if (head) {
						head.style.background = `linear-gradient(135deg, ${rightColor}, ${rightColor})`;
					}
					updateBodyColors('right', rightColor);
				}
				const rightMirror = document.getElementById('rightMirror');
				if (rightMirror) {
					rightMirror.checked = comparison.rightParticipant.flipped || false;
				}
				const rightParticipant = document.querySelector('#rightCircle').closest('.participant');
				if (rightParticipant) {
					rightParticipant.setAttribute('data-mirror', String(comparison.rightParticipant.flipped || false));
				}
				// Apply pose using pose name (like dialog does)
				if (comparison.rightParticipant.pose) {
					applyParticipantPose('right', comparison.rightParticipant.pose, comparison.rightParticipant.flipped || false);
				} else {
					// Reset to default pose if no pose is set
					if (rightParticipant) {
						rightParticipant.removeAttribute('data-pose');
					}
					resetPose('right');
				}
			} else {
				// Default right participant
				const rightNameEl = document.getElementById('rightName');
				if (rightNameEl) rightNameEl.textContent = 'Højre';
				rightColor = '#ef4444';
				rightLightColor = lightenColor(rightColor, 0.6);
				if (rightCircle) {
					rightCircle.style.display = 'flex';
					const head = rightCircle.querySelector('.head');
					if (head) {
						head.style.background = `linear-gradient(135deg, ${rightColor}, ${rightColor})`;
					}
					updateBodyColors('right', rightColor);
				}
			}
			
			// Load trait names and set active traits
			if (Array.isArray(comparison.traitNames) && comparison.traitNames.length > 0) {
				// Find indices for trait names
				const traitIndices = comparison.traitNames.map(traitName => {
					return defaultTraits.findIndex(t => 
						(t.left === traitName.left && t.right === traitName.right) ||
						JSON.stringify(t) === JSON.stringify(traitName)
					);
				}).filter(idx => idx >= 0);
				
				if (traitIndices.length > 0) {
					activeTraitIndices = traitIndices.slice(0, ACTIVE_TRAIT_COUNT);
				}
			}
			
			// Load scores
			leftScores = comparison.leftScores ? { ...comparison.leftScores } : {};
			rightScores = comparison.rightScores ? { ...comparison.rightScores } : {};
			
			// Load notes
			comparisonNotes = comparison.notes || '';
			const notesTextarea = document.getElementById('comparisonNotes');
			if (notesTextarea) {
				notesTextarea.value = comparisonNotes;
			}
			
			// Update slider colors
			updateSliderColors();
			
			// Update UI
			updateComparisonView();
			
			return true;
		} catch (err) {
			console.error('[LOAD] Load failed:', err);
			return false;
		}
	}
		
		// ===== SAMLING MANAGER FUNCTIONS =====
		
		async function openSamlingManager() {
			if (!samlingManagerOverlayEl) {
				samlingManagerOverlayEl = document.getElementById('samlingManagerOverlay');
				samlingManagerListEl = document.getElementById('samlingManagerList');
				newSamlingNameInputEl = document.getElementById('newSamlingName');
				newSamlingColorBtnEl = document.getElementById('newSamlingColorBtn');
			}
			if (!samlingColorPickerModalEl) {
				samlingColorPickerModalEl = document.getElementById('samlingColorPickerModal');
			}
			if (!samlingColorGridEl) {
				samlingColorGridEl = document.getElementById('samlingColorGrid');
			}
			if (newSamlingNameInputEl) {
				newSamlingDraftName = newSamlingNameInputEl.value;
			}
			if (samlingColorGridEl && samlingColorGridEl.childElementCount === 0) {
				buildSamlingColorGrid();
			}
			if (!samlingManagerOverlayEl) return;
			resetNewSamlingDraft();
			renderSamlingManagerList();
			samlingManagerOverlayEl.classList.add('show');
			setTimeout(() => {
				if (newSamlingNameInputEl) {
					newSamlingNameInputEl.focus();
				}
			}, 80);
		}
		
		function closeSamlingManager() {
			if (samlingManagerOverlayEl) {
				samlingManagerOverlayEl.classList.remove('show');
			}
			closeSamlingColorPicker();
		}
		
		function resetNewSamlingDraft() {
			newSamlingDraftColor = COMPARE_COLLECTION_COLOR_PRESETS[0];
			newSamlingDraftName = '';
			newSamlingColorDirty = false;
			if (newSamlingNameInputEl) {
				newSamlingNameInputEl.value = '';
			}
			updateNewSamlingColorButton();
		}
		
		function updateNewSamlingColorButton() {
			if (!newSamlingColorBtnEl) return;
			if (newSamlingColorDirty) {
				const baseColor = newSamlingDraftColor || COMPARE_COLLECTION_COLOR_PRESETS[0];
				newSamlingColorBtnEl.style.background = baseColor;
				newSamlingColorBtnEl.style.color = '#ffffff';
				if (newSamlingNameInputEl) {
					newSamlingNameInputEl.style.background = lightenHex(baseColor, 0.85);
					newSamlingNameInputEl.style.boxShadow = `0 0 0 2px ${hexToRgba(baseColor, 0.35)}`;
				}
			} else {
				const baseColor = COMPARE_COLLECTION_COLOR_PRESETS[0] || '#ef4444';
				newSamlingColorBtnEl.style.background = baseColor;
				newSamlingColorBtnEl.style.color = '#ffffff';
				if (newSamlingNameInputEl) {
					newSamlingNameInputEl.style.background = lightenHex(baseColor, 0.85);
					newSamlingNameInputEl.style.boxShadow = `0 0 0 2px ${hexToRgba(baseColor, 0.35)}`;
				}
			}
		}
		
		async function renderSamlingManagerList() {
			if (!samlingManagerListEl) return;
			samlingManagerListEl.innerHTML = '';
			
			if (!CompareData || !Array.isArray(CompareData.collections)) {
				await ensureDefaultCompareData();
			}
			
			CompareData.collections.forEach(collection => {
				const item = document.createElement('div');
				item.className = 'samling-manager-item';
				
				const nameBtn = document.createElement('button');
				nameBtn.className = 'samling-name-btn';
				nameBtn.textContent = collection.name || 'Samling';
				const baseColor = collection.color || COMPARE_COLLECTION_COLOR_PRESETS[0];
				nameBtn.style.background = lightenHex(baseColor, 0.7);
				nameBtn.style.border = `1px solid ${baseColor}`;
				nameBtn.addEventListener('click', () => beginSamlingNameInlineEdit(collection, nameBtn));
				
				const actions = document.createElement('div');
				actions.className = 'samling-manager-actions';
				
				const colorBtn = document.createElement('button');
				colorBtn.className = 'samling-color-select';
				colorBtn.textContent = 'C';
				colorBtn.style.background = collection.color || COMPARE_COLLECTION_COLOR_PRESETS[0];
				colorBtn.onclick = () => openSamlingColorPicker({ type: 'samling', collectionId: collection.id });
				
				const deleteBtn = document.createElement('button');
				deleteBtn.className = 'samling-delete-btn';
				deleteBtn.textContent = '✕';
				deleteBtn.onclick = () => deleteSamling(collection.id);
				
				actions.appendChild(colorBtn);
				actions.appendChild(deleteBtn);
				
				item.appendChild(nameBtn);
				item.appendChild(actions);
				samlingManagerListEl.appendChild(item);
			});
			
			newSamlingNameInputEl = document.getElementById('newSamlingName');
			newSamlingColorBtnEl = document.getElementById('newSamlingColorBtn');
			if (newSamlingNameInputEl) {
				newSamlingNameInputEl.value = newSamlingDraftName;
				newSamlingNameInputEl.addEventListener('input', (e) => {
					newSamlingDraftName = e.target.value;
				});
			}
			updateNewSamlingColorButton();
		}
		
		async function beginSamlingNameInlineEdit(collection, buttonEl) {
			if (!collection || !buttonEl) return;
			const baseColor = collection.color || COMPARE_COLLECTION_COLOR_PRESETS[0];
			const input = document.createElement('input');
			input.type = 'text';
			input.className = 'samling-name-input';
			input.value = collection.name || 'Samling';
			input.style.background = lightenHex(baseColor, 0.7);
			input.style.borderColor = baseColor;
			
			let finished = false;
			const commit = async (shouldSave) => {
				if (finished) return;
				finished = true;
				const newName = input.value.trim();
				if (shouldSave && newName && newName !== collection.name) {
					collection.name = newName;
					renderHistoryFilterOptions();
					await renderHistory();
					await saveCompareDataToLocalStorage();
				}
				await renderSamlingManagerList();
			};
			
			input.addEventListener('keydown', (event) => {
				if (event.key === 'Enter') {
					commit(true);
				} else if (event.key === 'Escape') {
					commit(false);
				}
			});
			
			input.addEventListener('blur', () => commit(true));
			
			buttonEl.replaceWith(input);
			input.focus();
			input.select();
		}
		
		function openSamlingColorPicker(target) {
			if (!samlingColorPickerModalEl) {
				samlingColorPickerModalEl = document.getElementById('samlingColorPickerModal');
				samlingColorGridEl = document.getElementById('samlingColorGrid');
			}
			if (!samlingColorPickerModalEl || !samlingColorGridEl) return;
			samlingColorPickerTarget = target;
			samlingColorPickerModalEl.classList.add('show');
		}
		
		function closeSamlingColorPicker() {
			samlingColorPickerTarget = null;
			if (samlingColorPickerModalEl) {
				samlingColorPickerModalEl.classList.remove('show');
			}
		}
		
		function backdropCloseSamlingHandler(event) {
			if (event.target === samlingColorPickerModalEl) {
				closeSamlingColorPicker();
			}
		}
		
		async function handleSamlingColorSelected(color) {
			if (!samlingColorPickerTarget) return;
			if (samlingColorPickerTarget.type === 'samling') {
				await applySamlingColor(samlingColorPickerTarget.collectionId, color);
				await renderHistory();
				await saveCompareDataToLocalStorage();
			} else if (samlingColorPickerTarget.type === 'new') {
				newSamlingDraftColor = color;
				newSamlingColorDirty = true;
				updateNewSamlingColorButton();
			}
			closeSamlingColorPicker();
		}
		
		async function applySamlingColor(collectionId, color) {
			const collection = CompareData.collections.find(c => c.id === collectionId);
			if (!collection) return;
			collection.color = color;
			renderHistory();
			renderSamlingManagerList();
			renderHistoryFilterOptions();
			await saveCompareDataToLocalStorage();
		}
		
		async function confirmCreateSamling() {
			if (!newSamlingNameInputEl) return;
			const name = newSamlingNameInputEl.value.trim();
			if (!name) {
				newSamlingNameInputEl.focus();
				return;
			}
			const color = newSamlingDraftColor || COMPARE_COLLECTION_COLOR_PRESETS[0];
			
			// Save current workspace before switching
			await syncCurrentWorkspaceToActiveComparison();
			
			// Find highest collection ID
			let maxId = 0;
			if (Array.isArray(CompareData.collections)) {
				CompareData.collections.forEach(c => {
					if (c.id > maxId) maxId = c.id;
				});
			}
			const newId = maxId + 1;
			
			const now = new Date().toISOString();
			const newCollection = {
				id: newId,
				name,
				color,
				comparisons: [{
					id: 1,
					name: 'Sammenligning 1',
					timestamp: now,
					updated: now,
					leftParticipant: {
						name: 'Venstre',
						color: '#3b82f6',
						pose: '',
						flipped: false
					},
					rightParticipant: {
						name: 'Højre',
						color: '#ef4444',
						pose: '',
						flipped: false
					},
					traitNames: [],
					leftScores: {},
					rightScores: {},
					notes: ''
				}]
			};
			
			if (!Array.isArray(CompareData.collections)) {
				CompareData.collections = [];
			}
			CompareData.collections.push(newCollection);
			CompareData.activeCollectionId = newId;
			CompareData.activeComparisonId = 1;
			
			await saveCompareDataToLocalStorage();
			
			// Load the new empty comparison
			loadComparisonFromCompareData(newCollection.comparisons[0]);
			renderHistory();
			closeSamlingManager();
			
			// Make the new history item's name editable
			requestAnimationFrame(() => {
				const newHistoryItem = document.querySelector(`.history-item.active input[data-comparison-id="1"]`);
				if (newHistoryItem) {
					newHistoryItem.readOnly = false;
					newHistoryItem.focus();
					newHistoryItem.select();
				}
			});
		}
		
		async function deleteSamling(collectionId) {
			if (!CompareData || !Array.isArray(CompareData.collections)) return;
			
			if (CompareData.collections.length <= 1) {
				alert('Du kan ikke slette den sidste samling.');
				return;
			}
			
			if (!confirm('Er du sikker på du vil slette denne samling og alle dens sammenligninger?')) {
				return;
			}
			
			CompareData.collections = CompareData.collections.filter(c => c.id !== collectionId);
			
			if (CompareData.activeCollectionId === collectionId) {
				const otherCollection = CompareData.collections.find(c => 
					c.id !== collectionId && Array.isArray(c.comparisons) && c.comparisons.length > 0
				);
				if (otherCollection) {
					CompareData.activeCollectionId = otherCollection.id;
					CompareData.activeComparisonId = otherCollection.comparisons[0].id;
				} else if (CompareData.collections.length > 0) {
					CompareData.activeCollectionId = CompareData.collections[0].id;
					if (CompareData.collections[0].comparisons && CompareData.collections[0].comparisons.length > 0) {
						CompareData.activeComparisonId = CompareData.collections[0].comparisons[0].id;
					}
				}
			}
			
			await saveCompareDataToLocalStorage();
			const activeComparison = getActiveComparison();
			if (activeComparison) {
				loadComparisonFromCompareData(activeComparison);
			}
			renderHistory();
			renderHistoryFilterOptions();
			renderSamlingManagerList();
		}
		
		function buildSamlingColorGrid() {
			if (!samlingColorGridEl) return;
			samlingColorGridEl.innerHTML = '';
			COMPARE_COLLECTION_COLOR_PRESETS.forEach(color => {
				const swatch = document.createElement('div');
				swatch.className = 'samling-color-swatch';
				swatch.style.background = color;
				swatch.onclick = () => handleSamlingColorSelected(color);
				samlingColorGridEl.appendChild(swatch);
			});
		}
		
		// ===== HISTORY SIDEBAR FUNCTIONS =====
		
		function getAllComparisonsSorted() {
			if (!CompareData || !Array.isArray(CompareData.collections)) return [];
			const allComparisons = [];
			CompareData.collections.forEach(collection => {
				if (Array.isArray(collection.comparisons)) {
					collection.comparisons.forEach(comparison => {
						if (!comparison.timestamp && comparison.updated) {
							comparison.timestamp = comparison.updated;
						} else if (!comparison.timestamp) {
							comparison.timestamp = new Date().toISOString();
						}
						allComparisons.push({
							comparison,
							collection
						});
					});
				}
			});
			return allComparisons.sort((a, b) => {
				const tsA = a.comparison.timestamp || '';
				const tsB = b.comparison.timestamp || '';
				return tsB.localeCompare(tsA);
			});
		}
		
		function getFilteredSortedComparisons() {
			const all = getAllComparisonsSorted();
			if (!historyFilterCollectionId || historyFilterCollectionId === 'all') {
				return all;
			}
			const filterId = parseInt(historyFilterCollectionId, 10);
			return all.filter(item => item.collection.id === filterId);
		}
		
		function renderHistoryFilterOptions() {
			const filterEl = document.getElementById('historyFilter');
			if (!filterEl) return;
			filterEl.innerHTML = '';
			
			const allOption = document.createElement('option');
			allOption.value = 'all';
			allOption.textContent = 'Alle samlinger';
			filterEl.appendChild(allOption);
			
			if (CompareData && Array.isArray(CompareData.collections)) {
				CompareData.collections.forEach(collection => {
					const option = document.createElement('option');
					option.value = collection.id;
					option.textContent = collection.name || 'Samling';
					if (collection.id === historyFilterCollectionId) {
						option.selected = true;
					}
					filterEl.appendChild(option);
				});
			}
		}
		
		function setHistoryFilter(value) {
			historyFilterCollectionId = value === 'all' ? null : value;
			renderHistory();
			updateHistoryNavState();
		}
		
		async function renderHistory() {
			const listEl = document.getElementById('historyList');
			if (!listEl) return;
			listEl.innerHTML = '';
			
			const filtered = getFilteredSortedComparisons();
			filtered.forEach(({ comparison, collection }) => {
				const item = document.createElement('div');
				const isActive = comparison.id === CompareData.activeComparisonId && 
				               collection.id === CompareData.activeCollectionId;
				item.className = `history-item ${isActive ? 'active' : ''}`;
				
				const collectionColor = collection.color || COMPARE_COLLECTION_COLOR_PRESETS[0];
				item.style.background = isActive 
					? `linear-gradient(135deg, ${lightenHex(collectionColor, 0.25)} 0%, ${collectionColor} 100%)`
					: `linear-gradient(135deg, ${lightenHex(collectionColor, 0.7)} 0%, ${lightenHex(collectionColor, 0.5)} 100%)`;
				item.style.borderColor = collectionColor;
				
				const collectionBadge = document.createElement('div');
				collectionBadge.className = 'history-item-collection';
				collectionBadge.textContent = collection.name || 'Samling';
				collectionBadge.style.background = collectionColor;
				
				const titleDiv = document.createElement('div');
				titleDiv.className = 'history-item-title';
				
				const dateInput = document.createElement('input');
				dateInput.type = 'text';
				dateInput.className = 'history-item-date';
				dateInput.value = comparison.name || 'Sammenligning';
				dateInput.readOnly = !isActive;
				dateInput.setAttribute('data-comparison-id', comparison.id);
				if (isActive) {
					dateInput.addEventListener('blur', async () => {
						const newName = dateInput.value.trim();
						if (newName && newName !== comparison.name) {
							comparison.name = newName;
							await saveCompareDataToLocalStorage();
						}
					});
					dateInput.addEventListener('keydown', (e) => {
						if (e.key === 'Enter') {
							dateInput.blur();
						}
					});
				}
				
				titleDiv.appendChild(dateInput);
				
				const metaDiv = document.createElement('div');
				metaDiv.className = 'history-item-meta';
				
				const firstLine = document.createElement('div');
				firstLine.className = 'history-item-meta-line';
				
				const dateTime = document.createElement('span');
				dateTime.className = 'history-item-time';
				const timestamp = comparison.timestamp || comparison.updated || '';
				if (timestamp) {
					const date = new Date(timestamp);
					const dateStr = formatDkDate(timestamp);
					const timeStr = date.toLocaleTimeString('da-DK', { hour: '2-digit', minute: '2-digit' });
					dateTime.textContent = `${dateStr} ${timeStr}`;
				}
				firstLine.appendChild(dateTime);
				
				const secondLine = document.createElement('div');
				secondLine.className = 'history-item-meta-line';
				
				const participants = document.createElement('span');
				participants.className = 'history-item-participants';
				const leftName = truncateName(comparison.leftParticipant?.name || 'Venstre');
				const rightName = truncateName(comparison.rightParticipant?.name || 'Højre');
				participants.textContent = `${leftName} & ${rightName}`;
				
				secondLine.appendChild(participants);
				
				metaDiv.appendChild(firstLine);
				metaDiv.appendChild(secondLine);
				
				const deleteBtn = document.createElement('button');
				deleteBtn.className = 'history-item-delete';
				deleteBtn.textContent = '×';
				deleteBtn.onclick = (e) => {
					e.stopPropagation();
					deleteComparison(collection.id, comparison.id);
				};
				
				item.appendChild(collectionBadge);
				item.appendChild(titleDiv);
				item.appendChild(metaDiv);
				item.appendChild(deleteBtn);
				
				item.onclick = async () => {
					await syncCurrentWorkspaceToActiveComparison();
					CompareData.activeCollectionId = collection.id;
					CompareData.activeComparisonId = comparison.id;
					await saveCompareDataToLocalStorage();
					loadComparisonFromCompareData(comparison);
					await renderHistory();
					updateHistoryNavState();
				};
				
				listEl.appendChild(item);
			});
			
			updateHistoryNavState();
		}
		
		function updateHistoryNavState() {
			const filtered = getFilteredSortedComparisons();
			const currentIndex = filtered.findIndex(item => 
				item.comparison.id === CompareData.activeComparisonId && 
				item.collection.id === CompareData.activeCollectionId
			);
			
			const navUp = document.getElementById('navUp');
			const navDown = document.getElementById('navDown');
			
			if (navUp) navUp.disabled = currentIndex <= 0;
			if (navDown) navDown.disabled = currentIndex >= filtered.length - 1;
		}
		
		async function navigateHistory(direction) {
			const filtered = getFilteredSortedComparisons();
			const currentIndex = filtered.findIndex(item => 
				item.comparison.id === CompareData.activeComparisonId && 
				item.collection.id === CompareData.activeCollectionId
			);
			
			if (currentIndex === -1) return;
			
			const newIndex = currentIndex + direction;
			if (newIndex < 0 || newIndex >= filtered.length) return;
			
			const { comparison, collection } = filtered[newIndex];
			await syncCurrentWorkspaceToActiveComparison();
			CompareData.activeCollectionId = collection.id;
			CompareData.activeComparisonId = comparison.id;
			await saveCompareDataToLocalStorage();
			loadComparisonFromCompareData(comparison);
			await renderHistory();
			updateHistoryNavState();
		}
		
		function toggleHistorySidebar() {
			const sidebar = document.getElementById('historySidebar');
			const toggleBtns = sidebar.querySelectorAll('.collapse-toggle');
			if (!sidebar || !toggleBtns.length) return;
			
			sidebar.classList.toggle('collapsed');
			const isCollapsed = sidebar.classList.contains('collapsed');
			localStorage.setItem('compare_historySidebarCollapsed', isCollapsed);
			toggleBtns.forEach(btn => {
				btn.textContent = isCollapsed ? '<' : '>';
			});
		}
		
		async function deleteComparison(collectionId, comparisonId) {
			const collection = CompareData.collections.find(c => c.id === collectionId);
			if (!collection || !Array.isArray(collection.comparisons)) return;
			
			if (collection.comparisons.length <= 1) {
				alert('Du kan ikke slette den sidste sammenligning i en samling. Slet samlingen i stedet.');
				return;
			}
			
			if (!confirm('Er du sikker på du vil slette denne sammenligning?')) {
				return;
			}
			
			collection.comparisons = collection.comparisons.filter(c => c.id !== comparisonId);
			
			if (CompareData.activeComparisonId === comparisonId && CompareData.activeCollectionId === collectionId) {
				if (collection.comparisons.length > 0) {
					CompareData.activeComparisonId = collection.comparisons[collection.comparisons.length - 1].id;
				} else {
					const otherCollection = CompareData.collections.find(c => 
						c.id !== collectionId && Array.isArray(c.comparisons) && c.comparisons.length > 0
					);
					if (otherCollection) {
						CompareData.activeCollectionId = otherCollection.id;
						CompareData.activeComparisonId = otherCollection.comparisons[otherCollection.comparisons.length - 1].id;
					}
				}
			}
			
			await saveCompareDataToLocalStorage();
			const activeComparison = getActiveComparison();
			if (activeComparison) {
				loadComparisonFromCompareData(activeComparison);
			}
			renderHistory();
		}
		
		async function createNewComparison() {
			if (!CompareData) {
				await ensureDefaultCompareData();
			}
			
			let collection = getActiveCollection();
			if (!collection) {
				await ensureDefaultCompareData();
				collection = getActiveCollection();
			}
			
			// Find highest comparison ID in current collection
			let maxId = 0;
			if (Array.isArray(collection.comparisons)) {
				collection.comparisons.forEach(c => {
					if (c.id > maxId) maxId = c.id;
				});
			}
			
			const newId = maxId + 1;
			const comparisonName = `Sammenligning ${newId}`;
			
			// Save current workspace before switching
			await syncCurrentWorkspaceToActiveComparison();
			
			// Create new comparison
			const now = new Date().toISOString();
			const newComparison = {
				id: newId,
				name: comparisonName,
				timestamp: now,
				updated: now,
				leftParticipant: {
					name: 'Venstre',
					color: '#3b82f6',
					pose: '',
					flipped: false
				},
				rightParticipant: {
					name: 'Højre',
					color: '#ef4444',
					pose: '',
					flipped: false
				},
				traitNames: [],
				leftScores: {},
				rightScores: {},
				notes: ''
			};
			
			if (!Array.isArray(collection.comparisons)) {
				collection.comparisons = [];
			}
			collection.comparisons.push(newComparison);
			CompareData.activeComparisonId = newId;
			
			await saveCompareDataToLocalStorage();
			
			// Load the new empty comparison
			loadComparisonFromCompareData(newComparison);
			renderHistory();
			
			// Make the new history item's name editable and focus it
			requestAnimationFrame(() => {
				const newHistoryItem = document.querySelector(`.history-item.active input[data-comparison-id="${newId}"]`);
				if (newHistoryItem) {
					newHistoryItem.readOnly = false;
					newHistoryItem.focus();
					newHistoryItem.select();
				}
			});
		}

        
const partsData = {
    lav_ny_left: { 
        name: "Lav Ny Del", 
        keywords: ["", "", "", "", "", ""], 
        color: "#10b981",
        pose: "",
        mirror: false
    },
    lav_ny_right: { 
        name: "Lav Ny Del", 
        keywords: ["", "", "", "", "", ""], 
        color: "#3b82f6",
        pose: "",
        mirror: false
    },
    beskytter: { 
        name: "Beskytteren", 
        keywords: ["Sikkerhed", "Kontrol", "Forsigtig", "Ansvarlig", "", ""], 
        color: "#fbbf24",
        pose: "stærk",
        mirror: false
    },
    kritiker: { 
        name: "Den Kritiske", 
        keywords: ["Perfektionisme", "Standards", "Aldrig godt nok", "Selvkritik", "", ""], 
        color: "#ef4444",
        pose: "vred",
        mirror: false
    },
    manager: { 
        name: "Manager-delen", 
        keywords: ["Produktivitet", "Mål", "Effektivitet", "Præstation", "", ""], 
        color: "#3b82f6",
        pose: "tænke",
        mirror: false
    },
    perfektionist: { 
        name: "Den Perfektionistiske", 
        keywords: ["Fejlfri", "Detaljer", "Aldrig færdig", "Høje krav", "", ""], 
        color: "#8b5cf6",
        pose: "lukket",
        mirror: false
    },
    barn: { 
        name: "Det Indre Barn", 
        keywords: ["Leg", "Spontanitet", "Nysgerrig", "Kreativ", "", ""], 
        color: "#10b981",
        pose: "Leg",
        mirror: false
    },
    saaret: { 
        name: "Det Sårede Barn", 
        keywords: ["Sorg", "Ensomhed", "Har brug for trøst", "Bange", "", ""], 
        color: "#06b6d4",
        pose: "trist",
        mirror: false
    },
    kreativ: { 
        name: "Den Kreative", 
        keywords: ["Fantasi", "Inspiration", "Fri udtryk", "Innovation", "", ""], 
        color: "#f97316",
        pose: "flyver",
        mirror: false
    },
    glade: { 
        name: "Den Glade", 
        keywords: ["Optimisme", "Humor", "Positivitet", "Smil", "", ""], 
        color: "#84cc16",
        pose: "hej",
        mirror: false
    }
};

        const defaultTraits = [
            { left: "Leder", right: "Følger" },
            { left: "Planlægger", right: "Improviserer" },
            { left: "Struktureret", right: "Kreativ" },
            { left: "Aktiv", right: "Passiv" },
            { left: "Tænkende", right: "Følende" },
            { left: "Kritisk", right: "Accepterende" },
            { left: "Talende", right: "Lyttende" },
            { left: "Hurtig", right: "Langsom" },
            { left: "Ansvarsfuld", right: "Sorgløs" },
            { left: "Alvorlig", right: "Legende" },
            { left: "Konservativ", right: "Revolutionerende" },
            { left: "Empirisk", right: "Intuitiv" },
			{ left: "Dominerende", right: "Vigende" },
			{ left: "Larmende", right: "Stille" },
			{ left: "Indadvendt", right: "Udadvende" },
			{ left: "Gruppe", right: "Individ" },
			{ left: "Forsigtig", right: "Tager chancer" }
			
			
			
        ];
        const ACTIVE_TRAIT_COUNT = 6;
        let activeTraitIndices = [];
        let currentTraitSelectionKey = null;
        function ensureActiveTraits(forceReselect = false) {
            // Always ensure we have active traits - participants are always present (Venstre/Højre)
            // We no longer check for selected participants since Venstre and Højre are always available
            if (forceReselect || activeTraitIndices.length === 0) {
                // Use a fixed key since we always have the same participants
                currentTraitSelectionKey = 'venstre|højre';

                const indices = Array.from({ length: defaultTraits.length }, (_, idx) => idx);
                for (let i = indices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [indices[i], indices[j]] = [indices[j], indices[i]];
                }
                activeTraitIndices = indices
                    .slice(0, Math.min(ACTIVE_TRAIT_COUNT, defaultTraits.length))
                    .sort((a, b) => a - b);
                // Only clear scores if we're forcing a reselect
                if (forceReselect) {
                leftScores = {};
                rightScores = {};
                }
            }
        }

        function getActiveTraits() {
            if (activeTraitIndices.length === 0) {
                return defaultTraits.map((trait, index) => ({ trait, index }));
            }
            return activeTraitIndices.map(index => ({
                index,
                trait: defaultTraits[index]
            }));
        }
		
		
		
		
	///// animations bibliotek
		
		let animationsLibrary = {};
		
		// Load animations from JSON files - dynamically loads from manifest.json
        async function loadAnimations() {
            // Try to load manifest.json first (most reliable method)
            try {
                const manifestResponse = await fetch('Animations/manifest.json');
                if (manifestResponse.ok) {
                    const manifest = await manifestResponse.json();
                    if (manifest.files && Array.isArray(manifest.files)) {
                        for (const fileName of manifest.files) {
                            try {
                                const fileResponse = await fetch(`Animations/${fileName}`);
                                if (fileResponse.ok) {
                                    const animationData = await fileResponse.json();
                                    const animName = fileName.replace('.json', '');
                                    animationsLibrary[animName] = animationData;
                                }
                            } catch (error) {
                                console.error(`Failed to load animation ${fileName}:`, error);
                            }
                        }
                        return; // Successfully loaded from manifest
                    }
                }
            } catch (error) {
                // Manifest not available, try directory listing
            }
            
            // Fallback: Try directory listing
            try {
                const response = await fetch('Animations/');
                if (response.ok) {
                    const html = await response.text();
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const links = doc.querySelectorAll('a[href$=".json"]');
                    const jsonFiles = Array.from(links)
                        .map(link => link.getAttribute('href'))
                        .filter(file => file !== 'manifest.json'); // Exclude manifest itself
                    
                    if (jsonFiles.length > 0) {
                        for (const fileName of jsonFiles) {
                            try {
                                const fileResponse = await fetch(`Animations/${fileName}`);
                                if (fileResponse.ok) {
                                    const animationData = await fileResponse.json();
                                    const animName = fileName.replace('.json', '');
                                    animationsLibrary[animName] = animationData;
                                }
                            } catch (error) {
                                console.error(`Failed to load animation ${fileName}:`, error);
                            }
                        }
                        return; // Successfully loaded from directory listing
                    }
                }
            } catch (error) {
                // Directory listing not available
            }
        }
		
		
		
		
// Pose Library - loaded from external JSON file
let poseLibrary = [];

// Load pose library from external JSON file
async function loadPoseLibrary() {
    try {
        const response = await fetch('Standard_new_poses.json');
        if (response.ok) {
            poseLibrary = await response.json();
            (window.__APP_DEBUG__ && console.log('Loaded pose library with', poseLibrary.length, 'poses'));
        } else {
            console.error('Failed to load pose library');
            // Fallback to basic poses
            poseLibrary = [
                {
                    "name": "standard",
                    "pose": {
                        "translate_x_left": -3,
                        "translate_y_left": 0,
                        "skulder_rot_left": -70,
                        "albue_rot_left": 0,
                        "translate_x": 3,
                        "translate_y": 0,
                        "skulder_rot": 70,
                        "albue_rot": 0,
                        "translate_x_left_leg": 0,
                        "translate_y_left_leg": 0,
                        "hofte_rot_left": 6,
                        "knae_rot_left": 0,
                        "translate_x_right_leg": 0,
                        "translate_y_right_leg": 0,
                        "hofte_rot_right": -6,
                        "knae_rot_right": 0,
                        "left_arm_front": false,
                        "right_arm_front": false,
                        "duration": 0.3
                    }
                }
            ];
        }
    } catch (error) {
        console.error('Error loading pose library:', error);
        // Fallback to basic poses
        poseLibrary = [
            {
                "name": "standard",
                "pose": {
                    "translate_x_left": -3,
                    "translate_y_left": 0,
                    "skulder_rot_left": -70,
                    "albue_rot_left": 0,
                    "translate_x": 3,
                    "translate_y": 0,
                    "skulder_rot": 70,
                    "albue_rot": 0,
                    "translate_x_left_leg": 0,
                    "translate_y_left_leg": 0,
                    "hofte_rot_left": 6,
                    "knae_rot_left": 0,
                    "translate_x_right_leg": 0,
                    "translate_y_right_leg": 0,
                    "hofte_rot_right": -6,
                    "knae_rot_right": 0,
                    "left_arm_front": false,
                    "right_arm_front": false,
                    "duration": 0.3
                }
            }
        ];
    }
}

//// anim funktioner
function runAnimation(side, animName) {
    const animation = animationsLibrary[animName];
    if (!animation || !animation.slides) {
        (window.__APP_DEBUG__ && console.log(`Animation "${animName}" not found`));
        return;
    }
    
    // Add smooth transitions to all animated elements
    const circle = document.getElementById(side + 'Circle');
    const animatedElements = circle.querySelectorAll(
        '.skulder_translate_left, .skulder_rotate_left, .albue_rotate_left, ' +
        '.skulder_translate_right, .skulder_rotate_right, .albue_rotate_right, ' +
        '.hofte_translate_left, .hofte_rotate_left, .knae_rotate_left, ' +
        '.hofte_translate_right, .hofte_rotate_right, .knae_rotate_right'
    );
    
    let slideIndex = 0;
    
    function playNextSlide() {
        if (slideIndex < animation.slides.length) {
            const slide = animation.slides[slideIndex];
            
            // Set transition duration for this slide
            animatedElements.forEach(element => {
                element.style.transition = `transform ${slide.duration}s cubic-bezier(0.25, 0.1, 0.25, 1)`;
            });
            
            applyDirectSlideData(side, slide);
            slideIndex++;
            setTimeout(playNextSlide, slide.duration * 1000);
        } else {
            // Remove transitions when animation is done
            animatedElements.forEach(element => {
                element.style.transition = '';
            });
        }
    }
    
    playNextSlide();
}

function applyDirectSlideData(side, slideData) {
    const circle = document.getElementById(side + 'Circle');
    const skulderLeft = circle.querySelector('.skulder_translate_left');
    const skulderRight = circle.querySelector('.skulder_translate_right');
    const hofteLeft = circle.querySelector('.hofte_translate_left');
    const hofteRight = circle.querySelector('.hofte_translate_right');
    
    if (skulderLeft) {
        skulderLeft.style.transform = `translate(${slideData.translate_x_left || 0}px, ${slideData.translate_y_left || 0}px)`;
        const skulderRotLeft = skulderLeft.querySelector('.skulder_rotate_left');
        if (skulderRotLeft) {
            skulderRotLeft.style.transform = `rotate(${slideData.skulder_rot_left || 0}deg)`;
            const albueRotLeft = skulderRotLeft.querySelector('.albue_rotate_left');
            if (albueRotLeft) {
                albueRotLeft.style.transform = `rotate(${slideData.albue_rot_left || 0}deg)`;
            }
        }
    }
    
    if (skulderRight) {
        skulderRight.style.transform = `translate(${slideData.translate_x || 0}px, ${slideData.translate_y || 0}px)`;
        const skulderRotRight = skulderRight.querySelector('.skulder_rotate_right');
        if (skulderRotRight) {
            skulderRotRight.style.transform = `rotate(${slideData.skulder_rot || 0}deg)`;
            const albueRotRight = skulderRotRight.querySelector('.albue_rotate_right');
            if (albueRotRight) {
                albueRotRight.style.transform = `rotate(${slideData.albue_rot || 0}deg)`;
            }
        }
    }
    
    if (hofteLeft) {
        hofteLeft.style.transform = `translate(${slideData.translate_x_left_leg || 0}px, ${slideData.translate_y_left_leg || 0}px)`;
        const hofteRotLeft = hofteLeft.querySelector('.hofte_rotate_left');
        if (hofteRotLeft) {
            hofteRotLeft.style.transform = `rotate(${slideData.hofte_rot_left || 0}deg)`;
            const knaeRotLeft = hofteRotLeft.querySelector('.knae_rotate_left');
            if (knaeRotLeft) {
                knaeRotLeft.style.transform = `rotate(${slideData.knae_rot_left || 0}deg)`;
            }
        }
    }
    
    if (hofteRight) {
        hofteRight.style.transform = `translate(${slideData.translate_x_right_leg || 0}px, ${slideData.translate_y_right_leg || 0}px)`;
        const hofteRotRight = hofteRight.querySelector('.hofte_rotate_right');
        if (hofteRotRight) {
            hofteRotRight.style.transform = `rotate(${slideData.hofte_rot_right || 0}deg)`;
            const knaeRotRight = hofteRotRight.querySelector('.knae_rotate_right');
            if (knaeRotRight) {
                knaeRotRight.style.transform = `rotate(${slideData.knae_rot_right || 0}deg)`;
            }
        }
    }
    
    // Handle arm layering
    if (slideData.left_arm_front) {
        skulderLeft?.classList.add('front-arm');
    } else {
        skulderLeft?.classList.remove('front-arm');
    }
    
    if (slideData.right_arm_front) {
        skulderRight?.classList.add('front-arm');
    } else {
        skulderRight?.classList.remove('front-arm');
    }
}




/// pose functions
function openPosePicker(btn) {
    // Find the participant container (not just the circle)
    const participantCircle = btn.closest('.participant-circle');
    currentPosePart = participantCircle.parentElement; // This is the .participant div
    
    const modal = document.getElementById('posePickerModal');
    const picker = modal.querySelector('.pose-picker');
    
    // Get current pose and mirror from the participant element
    const currentPose = currentPosePart.getAttribute('data-pose') || '';
    const currentMirror = currentPosePart.getAttribute('data-mirror') === 'true';
    
    // Set mirror checkbox in picker
    document.getElementById('posePickerMirror').checked = currentMirror;
    
    // Populate pose grid (this will highlight the current pose)
    populatePoseGrid();
    
    // Show modal and position it
    const btnRect = btn.getBoundingClientRect();
    modal.classList.add('show');
    
    picker.style.position = 'absolute';
    picker.style.left = (btnRect.right + 10) + 'px';
    picker.style.top = (btnRect.top - 20) + 'px';
    
    // Adjust if goes off screen
    const pickerRect = picker.getBoundingClientRect();
    if (pickerRect.right > window.innerWidth) {
        picker.style.left = (btnRect.left - pickerRect.width - 10) + 'px';
    }
    if (pickerRect.bottom > window.innerHeight) {
        picker.style.top = (btnRect.bottom - pickerRect.height - 10) + 'px';
    }
}

function populatePoseGrid() {
    const grid = document.getElementById('poseGrid');
    grid.innerHTML = '';
    
    // Get current pose from the DOM element
    const currentPose = currentPosePart.getAttribute('data-pose') || '';
    const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
    
    // Add all poses from library (including "standard")
    poseLibrary.forEach((pose, index) => {
        const btn = document.createElement('button');
        btn.className = 'pose-button';
        btn.textContent = pose.name;
        btn.onclick = () => selectPose(index);
        
        if (currentPose === index.toString() || (currentPose === '' && index === standardIndex)) {
            btn.classList.add('active');
        }
        
        grid.appendChild(btn);
    });
}

function selectPose(poseIndex) {
    if (!currentPosePart) return;
    
    const mirror = document.getElementById('posePickerMirror').checked;
    
    // Find out which side by checking if it contains leftCircle or rightCircle
    const hasLeftCircle = currentPosePart.querySelector('#leftCircle');
    const side = hasLeftCircle ? 'left' : 'right';
    
    // Update the regular dropdowns to match
    const poseDropdown = document.getElementById(side + 'Pose');
    const mirrorCheckbox = document.getElementById(side + 'Mirror');
    
    // Map empty selection to standard index if available
    if (poseIndex === '') {
        const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
        if (standardIndex !== -1) {
            poseIndex = standardIndex;
        }
    }

    if (poseDropdown) poseDropdown.value = poseIndex;
    if (mirrorCheckbox) mirrorCheckbox.checked = mirror;
    
    // Use the existing applyPose function with mirror parameter
    applyPose(side, poseIndex, mirror);
    
    // Save to compareData when pose changes
    syncCurrentWorkspaceToActiveComparison();
    
    // Update active button
    populatePoseGrid();
}

function togglePosePickerMirror() {
    if (!currentPosePart) return;
    
    // Find out which side
    const hasLeftCircle = currentPosePart.querySelector('#leftCircle');
    const side = hasLeftCircle ? 'left' : 'right';
    
    // Update the regular mirror checkbox to match
    const regularMirrorCheckbox = document.getElementById(side + 'Mirror');
    const posePickerMirrorCheckbox = document.getElementById('posePickerMirror');
    
    if (regularMirrorCheckbox) {
        regularMirrorCheckbox.checked = posePickerMirrorCheckbox.checked;
    }
    
    // Re-apply current pose with new mirror state
    const currentPoseAttr = currentPosePart.getAttribute('data-pose');
    const poseIndex = currentPoseAttr != null ? currentPoseAttr : '';
    const mirror = posePickerMirrorCheckbox ? posePickerMirrorCheckbox.checked : false;
    applyPose(side, poseIndex, mirror);
    
    // Save to compareData when mirror changes
    syncCurrentWorkspaceToActiveComparison();
}

function closePosePicker() {
    document.getElementById('posePickerModal').classList.remove('show');
    currentPosePart = null;
}



// end pose functions



		
		

        

        function hslToHex(h,s,l){
            s /= 100; l /= 100;
            const k = n => (n + h/30) % 12;
            const a = s * Math.min(l, 1 - l);
            const f = n => {
                const color = l - a * Math.max(Math.min(k(n) - 3, 9 - k(n), 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }

        function lightenColor(color, factor) {
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            
            const newR = Math.round(r + (255 - r) * factor);
            const newG = Math.round(g + (255 - g) * factor);
            const newB = Math.round(b + (255 - b) * factor);
            
            return `rgb(${newR}, ${newG}, ${newB})`;
        }

        function updateBodyColors(side, color) {
    const circle = document.getElementById(side + 'Circle');
    if (!circle) return;
    
    // Convert hex to RGB to darken it
    function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }
    
    function darkenColor(hex, factor = 0.8) {
        const rgb = hexToRgb(hex);
        if (!rgb) return hex;
        
        const r = Math.round(rgb.r * factor);
        const g = Math.round(rgb.g * factor);
        const b = Math.round(rgb.b * factor);
        
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    const darkerColor = darkenColor(color, 0.92); // 15% mørkere
    
    const torso = circle.querySelector('.participant-torso');
    const armParts = circle.querySelectorAll('.arm_geo_left, .arm_geo_right, .albue_geo_left, .albue_geo_right');
    const legParts = circle.querySelectorAll('.laar_geo_left, .laar_geo_right, .skinneben_geo_left, .skinneben_geo_right');
    
    // Torso og hoved beholder original farve
		const head = circle.querySelector('.head');
		if (head) head.style.background = color;
		if (torso) torso.style.background = color;
    
    // Arme og ben får mørkere farve
    armParts.forEach(part => part.style.background = darkerColor);
    legParts.forEach(part => part.style.background = darkerColor);
}

        function updateSliderColors() {
            const root = document.documentElement;
            
            if (leftColor) {
                root.style.setProperty('--left-color', leftColor);
            }
            
            if (rightColor) {
                root.style.setProperty('--right-color', rightColor);
            }
        }

        function updateParticipant(side) {
            const dropdown = document.getElementById(side + 'Dropdown');
            const circle = document.getElementById(side + 'Circle');
            const name = document.getElementById(side + 'Name');
            const colorBtn = document.getElementById(side + 'ColorBtn');
            const selectedValue = dropdown.value;
            
            if (selectedValue && partsData[selectedValue]) {
                const partData = partsData[selectedValue];
                circle.style.display = 'flex';
                
                if (side === 'left') {
                    leftColor = partData.color;
                    leftLightColor = lightenColor(partData.color, 0.6);
                } else {
                    rightColor = partData.color;
                    rightLightColor = lightenColor(partData.color, 0.6);
                }
                
                if (!name.hasAttribute('data-edited')) {
                    name.textContent = partData.name;
                }
                
                name.contentEditable = true;
                name.style.cursor = 'text';
                
                name.onclick = function() { name.focus(); };
                name.onkeydown = function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        name.blur();
                        name.setAttribute('data-edited', 'true');
                    }
                };
                name.onblur = function() {
                    name.setAttribute('data-edited', 'true');
                };
				
				
                
                const head = circle.querySelector('.head');
				if (head) {
					head.style.background = `linear-gradient(135deg, ${partData.color}, ${partData.color}dd)`;
					
				}
                
				colorBtn.style.display = 'flex';
                updateBodyColors(side, partData.color);
				updateSliderColors();
				
				// Populate stikord from parts data (if fields exist)
				if (partData.keywords && Array.isArray(partData.keywords)) {
					for (let i = 1; i <= 6; i++) {
						const stikordField = document.getElementById(side + 'Stikord' + i);
						if (stikordField) {
							stikordField.value = partData.keywords[i-1] || '';
						}
					}
				}

				// Play welcome animation first, then reset to default pose
				// Play welcome animation first, then apply saved pose or reset to default
				setTimeout(() => {
					runAnimation(side, 'vinke');
					
					const animationDuration = animationsLibrary.vinke ? animationsLibrary.vinke.slides.reduce((total, slide) => total + slide.duration, 0) : 0;
					setTimeout(() => {
							// Get partData again inside this scope and re-apply pose after animation
						const dropdown = document.getElementById(side + 'Dropdown');
						const selectedValue = dropdown.value;
						const currentPartData = partsData[selectedValue];
						
						// Apply pose directly from partData (no dropdowns needed)
						if (currentPartData && currentPartData.pose) {
							// Find pose index by name (case-insensitive, trimmed)
							const targetName = (currentPartData.pose || '').toLowerCase().trim();
							const poseIndex = poseLibrary.findIndex(pose => (pose.name || '').toLowerCase().trim() === targetName);
							if (poseIndex !== -1) {
								// Apply pose with mirror if specified
								const circle = document.getElementById(side + 'Circle');
								if (circle) {
									const participant = circle.parentElement;
									if (participant) {
										participant.setAttribute('data-pose', poseIndex.toString());
										participant.setAttribute('data-mirror', (currentPartData.mirror || false).toString());
									}
								}
								applyPose(side, poseIndex);
							} else {
								resetPose(side);
							}
						} else {
							resetPose(side);
						}
					}, animationDuration * 1000 + 100);
				}, 200);
							
            } else {
                // If no dropdown selection, ensure default Venstre/Højre are shown
                // Venstre and Højre are always available, so we should never hide the circles
                const defaultName = side === 'left' ? 'Venstre' : 'Højre';
                const defaultColor = side === 'left' ? '#3b82f6' : '#ef4444';
                
                if (!name.hasAttribute('data-edited')) {
                    name.textContent = defaultName;
                }
                
                if (side === 'left') {
                    leftColor = defaultColor;
                    leftLightColor = lightenColor(defaultColor, 0.6);
                } else {
                    rightColor = defaultColor;
                    rightLightColor = lightenColor(defaultColor, 0.6);
                }
                
                // Ensure circle is visible
                circle.style.display = 'flex';
                const head = circle.querySelector('.head');
                if (head) {
                    head.style.background = `linear-gradient(135deg, ${defaultColor}, ${defaultColor})`;
                }
                updateBodyColors(side, defaultColor);
                updateSliderColors();
            }
            updateButtonStates();
            updateComparisonView();
			
			
			
        }
		
		
		

		
		function updatePartsData(newPartsData) {
            Object.keys(partsData).forEach(key => {
                if (key !== 'lav_ny_left' && key !== 'lav_ny_right') {
                    delete partsData[key];
                }
            });
            
            Object.assign(partsData, newPartsData);
            // Rebuild dropdowns after data update
            buildDropdownMenus();
        }
		
        function buildDropdownMenus() {
            const leftDropdown = document.getElementById('leftDropdown');
            const rightDropdown = document.getElementById('rightDropdown');
            
            const leftSelected = leftDropdown.value;
            const rightSelected = rightDropdown.value;
            
            leftDropdown.innerHTML = '';
            rightDropdown.innerHTML = '';
            
            [leftDropdown, rightDropdown].forEach((dropdown, index) => {
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = index === 0 ? 'Venstre del...' : 'Højre del...';
                dropdown.appendChild(defaultOption);
            });
            
            // partsData already may include shared items injected at init
            Object.keys(partsData).forEach(key => {
                if (key === 'lav_ny_left' || key === 'lav_ny_right') return;
                
                const partData = partsData[key];
                
                [leftDropdown, rightDropdown].forEach(dropdown => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = partData.name;
                    dropdown.appendChild(option);
                });
            });
            
            if (leftSelected && partsData[leftSelected]) {
                leftDropdown.value = leftSelected;
            }
            if (rightSelected && partsData[rightSelected]) {
                rightDropdown.value = rightSelected;
            }
        }
        
        function initializeDropdowns() {
            // Inject shared characters from localStorage into partsData once
            try {
                const raw = localStorage.getItem('relationsSetupData');
                if (raw) {
                    const parsed = JSON.parse(raw);
                    if (parsed && Array.isArray(parsed.characters) && parsed.characters.length > 0) {
                        const sharedParts = {};
                        parsed.characters.forEach((c, idx) => {
                            if (!c || !c.name) return;
                            sharedParts['shared_' + idx] = {
                                name: c.name,
                                keywords: Array.isArray(c.keywords) ? c.keywords.slice(0,6) : ["","","","","",""],
                                color: c.color || '#10b981',
                                pose: c.pose || '',
                                mirror: !!c.mirror
                            };
                        });
                        if (Object.keys(sharedParts).length > 0) {
                            updatePartsData(sharedParts);
                        }
                    }
                }
            } catch(_) {}
            buildDropdownMenus();
        }
        
        function handleStorageUpdate() {
            (window.__APP_DEBUG__ && console.log('Handling storage update in comparison tool...'));
            
            // Store current selections
            const leftDropdown = document.getElementById('leftDropdown');
            const rightDropdown = document.getElementById('rightDropdown');
            const currentLeftSelected = leftDropdown.value;
            const currentRightSelected = rightDropdown.value;
            
            // Reinitialize dropdowns with new data
            initializeDropdowns();
            
            // Check if current selections still exist and are valid
            const leftStillValid = currentLeftSelected && partsData[currentLeftSelected];
            const rightStillValid = currentRightSelected && partsData[currentRightSelected];
            
            // Restore selections if they're still valid, otherwise clear them
            // Note: Venstre and Højre are always available, so circles should never be hidden
            if (leftStillValid) {
                leftDropdown.value = currentLeftSelected;
            } else {
                leftDropdown.value = '';
                // If selection was cleared, ensure default Venstre is shown
                const leftCircle = document.getElementById('leftCircle');
                const leftNameEl = document.getElementById('leftName');
                if (leftCircle) {
                    leftCircle.style.display = 'flex';
                    if (leftNameEl && !leftNameEl.hasAttribute('data-edited')) {
                        leftNameEl.textContent = 'Venstre';
                    }
                    const head = leftCircle.querySelector('.head');
                    if (head) {
                        head.style.background = `linear-gradient(135deg, #3b82f6, #3b82f6)`;
                    }
                    updateBodyColors('left', '#3b82f6');
                }
                leftColor = '#3b82f6';
                leftLightColor = lightenColor(leftColor, 0.6);
                updateSliderColors();
            }
            
            if (rightStillValid) {
                rightDropdown.value = currentRightSelected;
            } else {
                rightDropdown.value = '';
                // If selection was cleared, ensure default Højre is shown
                const rightCircle = document.getElementById('rightCircle');
                const rightNameEl = document.getElementById('rightName');
                if (rightCircle) {
                    rightCircle.style.display = 'flex';
                    if (rightNameEl && !rightNameEl.hasAttribute('data-edited')) {
                        rightNameEl.textContent = 'Højre';
                    }
                    const head = rightCircle.querySelector('.head');
                    if (head) {
                        head.style.background = `linear-gradient(135deg, #ef4444, #ef4444)`;
                    }
                    updateBodyColors('right', '#ef4444');
                }
                rightColor = '#ef4444';
                rightLightColor = lightenColor(rightColor, 0.6);
                updateSliderColors();
            }
            
            // Update participant displays - always update to ensure Venstre/Højre are shown
            updateParticipant('left');
            updateParticipant('right');
            
            // Update button states and comparison view
            updateButtonStates();
            updateComparisonView();
            
            // Show status message
            const updatedCount = Object.keys(partsData).length;
            setStatus(`Dropdowns opdateret - ${updatedCount} karakterer tilgængelige`);
            
            // Log what happened for debugging
            (window.__APP_DEBUG__ && console.log('Comparison storage update handled:', {
                leftWasValid: leftStillValid,
                rightWasValid: rightStillValid,
                leftSelected: leftDropdown.value,
                rightSelected: rightDropdown.value,
                availableCharacters: updatedCount
            }));
        }
		
		
		
		
		
		
		
		function initializePoseDropdowns() {
    const leftDropdown = document.getElementById('leftPose');
    const rightDropdown = document.getElementById('rightPose');
    
    // Return early if dropdowns don't exist (they were removed with info-left/right)
    if (!leftDropdown || !rightDropdown) {
        return;
    }
    
    // Clear existing options; if standard exists, we won't add a placeholder
    const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
    if (standardIndex !== -1) {
        leftDropdown.innerHTML = '';
        rightDropdown.innerHTML = '';
    } else {
        leftDropdown.innerHTML = '<option value="">Standard pose</option>';
        rightDropdown.innerHTML = '<option value="">Standard pose</option>';
    }
    
    // Add poses to dropdowns
    poseLibrary.forEach((pose, index) => {
        const leftOption = document.createElement('option');
        leftOption.value = index;
        leftOption.textContent = pose.name;
        leftDropdown.appendChild(leftOption);
        
        const rightOption = document.createElement('option');
        rightOption.value = index;
        rightOption.textContent = pose.name;
        rightDropdown.appendChild(rightOption);
    });
}

function applyPose(side, poseIndex, mirrorOverride) {
    const circle = document.getElementById(side + 'Circle');
    const mirrorCheckbox = document.getElementById(side + 'Mirror');
    const participantNode = circle ? circle.parentElement : null;
    
    if (!circle) {
        return;
    }
    // Map empty to standard index if available
    if (poseIndex === '') {
        const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
        if (standardIndex !== -1) {
            poseIndex = standardIndex;
        } else {
            resetPose(side);
            return;
        }
    }
    
    // Determine mirror state: use override if provided, otherwise check checkbox or data attribute
    let mirrorActive;
    if (typeof mirrorOverride === 'boolean') {
        mirrorActive = mirrorOverride;
    } else if (mirrorCheckbox) {
        mirrorActive = !!mirrorCheckbox.checked;
    } else if (participantNode && participantNode.hasAttribute('data-mirror')) {
        mirrorActive = participantNode.getAttribute('data-mirror') === 'true';
    } else {
        mirrorActive = false;
    }
    
    // Update checkbox to match mirror state
    if (mirrorCheckbox) {
        mirrorCheckbox.checked = mirrorActive;
    }
    
    // Add smooth transitions to all animated elements
    const animatedElements = circle.querySelectorAll(
        '.skulder_translate_left, .skulder_rotate_left, .albue_rotate_left, ' +
        '.skulder_translate_right, .skulder_rotate_right, .albue_rotate_right, ' +
        '.hofte_translate_left, .hofte_rotate_left, .knae_rotate_left, ' +
        '.hofte_translate_right, .hofte_rotate_right, .knae_rotate_right'
    );
    
    animatedElements.forEach(element => {
        element.style.transition = 'transform 0.8s cubic-bezier(0.25, 0.1, 0.25, 1)';
    });
    
    const pose = poseLibrary[poseIndex];
    if (!pose) return;
    
    let poseData = pose.pose;
    
    // If mirror is active, create mirrored version
    if (mirrorActive) {
        poseData = {
            translate_x_left: -(pose.pose.translate_x || 0),
            translate_x: -(pose.pose.translate_x_left || 0),
            translate_y_left: pose.pose.translate_y || 0,
            translate_y: pose.pose.translate_y_left || 0,
            skulder_rot_left: -(pose.pose.skulder_rot || 0),
            skulder_rot: -(pose.pose.skulder_rot_left || 0),
            albue_rot_left: -(pose.pose.albue_rot || 0),
            albue_rot: -(pose.pose.albue_rot_left || 0),
            translate_x_left_leg: -(pose.pose.translate_x_right_leg || 0),
            translate_x_right_leg: -(pose.pose.translate_x_left_leg || 0),
            translate_y_left_leg: pose.pose.translate_y_right_leg || 0,
            translate_y_right_leg: pose.pose.translate_y_left_leg || 0,
            hofte_rot_left: -(pose.pose.hofte_rot_right || 0),
            hofte_rot_right: -(pose.pose.hofte_rot_left || 0),
            knae_rot_left: -(pose.pose.knae_rot_right || 0),
            knae_rot_right: -(pose.pose.knae_rot_left || 0),
            left_arm_front: pose.pose.right_arm_front || false,
            right_arm_front: pose.pose.left_arm_front || false
        };
    }
    
    // Apply transforms to figure parts
    const skulderLeft = circle.querySelector('.skulder_translate_left');
    const skulderRight = circle.querySelector('.skulder_translate_right');
    const hofteLeft = circle.querySelector('.hofte_translate_left');
    const hofteRight = circle.querySelector('.hofte_translate_right');
    
    if (skulderLeft) {
        skulderLeft.style.transform = `translate(${poseData.translate_x_left || 0}px, ${poseData.translate_y_left || 0}px)`;
        const skulderRotLeft = skulderLeft.querySelector('.skulder_rotate_left');
        if (skulderRotLeft) {
            skulderRotLeft.style.transform = `rotate(${poseData.skulder_rot_left || 0}deg)`;
            const albueRotLeft = skulderRotLeft.querySelector('.albue_rotate_left');
            if (albueRotLeft) {
                albueRotLeft.style.transform = `rotate(${poseData.albue_rot_left || 0}deg)`;
            }
        }
    }
    
    if (skulderRight) {
        skulderRight.style.transform = `translate(${poseData.translate_x || 0}px, ${poseData.translate_y || 0}px)`;
        const skulderRotRight = skulderRight.querySelector('.skulder_rotate_right');
        if (skulderRotRight) {
            skulderRotRight.style.transform = `rotate(${poseData.skulder_rot || 0}deg)`;
            const albueRotRight = skulderRotRight.querySelector('.albue_rotate_right');
            if (albueRotRight) {
                albueRotRight.style.transform = `rotate(${poseData.albue_rot || 0}deg)`;
            }
        }
    }
    
    if (hofteLeft) {
        hofteLeft.style.transform = `translate(${poseData.translate_x_left_leg || 0}px, ${poseData.translate_y_left_leg || 0}px)`;
        const hofteRotLeft = hofteLeft.querySelector('.hofte_rotate_left');
        if (hofteRotLeft) {
            hofteRotLeft.style.transform = `rotate(${poseData.hofte_rot_left || 0}deg)`;
            const knaeRotLeft = hofteRotLeft.querySelector('.knae_rotate_left');
            if (knaeRotLeft) {
                knaeRotLeft.style.transform = `rotate(${poseData.knae_rot_left || 0}deg)`;
            }
        }
    }
    
    if (hofteRight) {
        hofteRight.style.transform = `translate(${poseData.translate_x_right_leg || 0}px, ${poseData.translate_y_right_leg || 0}px)`;
        const hofteRotRight = hofteRight.querySelector('.hofte_rotate_right');
        if (hofteRotRight) {
            hofteRotRight.style.transform = `rotate(${poseData.hofte_rot_right || 0}deg)`;
            const knaeRotRight = hofteRotRight.querySelector('.knae_rotate_right');
            if (knaeRotRight) {
                knaeRotRight.style.transform = `rotate(${poseData.knae_rot_right || 0}deg)`;
            }
        }
    }
    
    // Handle arm layering
    if (poseData.left_arm_front) {
        skulderLeft.classList.add('front-arm');
    } else {
        skulderLeft.classList.remove('front-arm');
    }
    
    if (poseData.right_arm_front) {
        skulderRight.classList.add('front-arm');
    } else {
        skulderRight.classList.remove('front-arm');
    }
	
	// Store pose state on DOM element
    const participant = circle.parentElement;
    if (participant) {
        participant.setAttribute('data-pose', poseIndex);
        participant.setAttribute('data-mirror', String(mirrorActive));
    }
	
	
}

function applyParticipantPose(side, poseName, mirror) {
    if (!poseLibrary || !poseLibrary.length) {
        return;
    }
    const circle = document.getElementById(side + 'Circle');
    const participantNode = circle ? circle.parentElement : null;
    const poseDropdown = document.getElementById(side + 'Pose');
    const defaultIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
    let poseIndex = -1;
    if (poseName) {
        poseIndex = poseLibrary.findIndex(p => p && p.name === poseName);
    }
    if (poseIndex === -1) {
        if (defaultIndex !== -1) {
            if (poseDropdown) poseDropdown.value = defaultIndex;
            applyPose(side, defaultIndex, typeof mirror === 'boolean' ? mirror : false);
        } else {
            if (poseDropdown) poseDropdown.value = '';
            resetPose(side);
        }
        return;
    }
    const mirrorValue = typeof mirror === 'boolean'
        ? mirror
        : !!(participantNode && participantNode.getAttribute('data-mirror') === 'true');
    if (poseDropdown) poseDropdown.value = poseIndex;
    applyPose(side, poseIndex, mirrorValue);
}

function toggleMirror(side) {
    // Get mirror state from participant data attribute if checkbox doesn't exist
    const circle = document.getElementById(side + 'Circle');
    const mirrorCheckbox = document.getElementById(side + 'Mirror');
    const participant = circle ? circle.parentElement : null;
    
    if (participant) {
        const currentMirror = mirrorCheckbox ? mirrorCheckbox.checked : (participant.getAttribute('data-mirror') === 'true');
        const newMirror = !currentMirror;
        
        // Update checkbox to match new mirror state
        if (mirrorCheckbox) {
            mirrorCheckbox.checked = newMirror;
        }
        
        // Update data-mirror attribute
        participant.setAttribute('data-mirror', String(newMirror));
        
        // Re-apply current pose with new mirror state
        const currentPose = participant.getAttribute('data-pose');
        if (currentPose !== null && currentPose !== '') {
            applyPose(side, currentPose, newMirror);
        }
        
        // Save to compareData when mirror changes
        syncCurrentWorkspaceToActiveComparison();
    }
}






function resetPose(side) {
    // Apply the relaxed pose using existing applyPose logic
    const circle = document.getElementById(side + 'Circle');
    if (!circle) return;
    // If standard exists, apply that index and persist state
    const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
    if (standardIndex !== -1) {
        const participant = circle.parentElement;
        if (participant) {
            participant.setAttribute('data-pose', standardIndex.toString());
            participant.setAttribute('data-mirror', 'false');
        }
        applyPose(side, standardIndex);
        return;
    }
    
    // Fallback relaxed default pose
    const relaxedPose = {
        translate_x_left: -3,
        translate_y_left: 0,
        skulder_rot_left: -70,
        albue_rot_left: 0,
        translate_x: 3,
        translate_y: 0,
        skulder_rot: 70,
        albue_rot: 0,
        translate_x_left_leg: 0,
        translate_y_left_leg: 0,
        hofte_rot_left: 6,
        knae_rot_left: 0,
        translate_x_right_leg: 0,
        translate_y_right_leg: 0,
        hofte_rot_right: -6,
        knae_rot_right: 0,
        left_arm_front: false,
        right_arm_front: false
    };
	// Add smooth transitions
		const animatedElements = circle.querySelectorAll(
			'.skulder_translate_left, .skulder_rotate_left, .albue_rotate_left, ' +
			'.skulder_translate_right, .skulder_rotate_right, .albue_rotate_right, ' +
			'.hofte_translate_left, .hofte_rotate_left, .knae_rotate_left, ' +
			'.hofte_translate_right, .hofte_rotate_right, .knae_rotate_right'
		);

		animatedElements.forEach(element => {
			element.style.transition = 'transform 0.8s cubic-bezier(0.25, 0.1, 0.25, 1)';
		});
    
    const poseData = relaxedPose;
    
    // Apply transforms (samme logik som i applyPose)
    const skulderLeft = circle.querySelector('.skulder_translate_left');
    const skulderRight = circle.querySelector('.skulder_translate_right');
    const hofteLeft = circle.querySelector('.hofte_translate_left');
    const hofteRight = circle.querySelector('.hofte_translate_right');
    
    if (skulderLeft) {
        skulderLeft.style.transform = `translate(${poseData.translate_x_left}px, ${poseData.translate_y_left}px)`;
        const skulderRotLeft = skulderLeft.querySelector('.skulder_rotate_left');
        if (skulderRotLeft) {
            skulderRotLeft.style.transform = `rotate(${poseData.skulder_rot_left}deg)`;
            const albueRotLeft = skulderRotLeft.querySelector('.albue_rotate_left');
            if (albueRotLeft) {
                albueRotLeft.style.transform = `rotate(${poseData.albue_rot_left}deg)`;
            }
        }
    }
    
    if (skulderRight) {
        skulderRight.style.transform = `translate(${poseData.translate_x}px, ${poseData.translate_y}px)`;
        const skulderRotRight = skulderRight.querySelector('.skulder_rotate_right');
        if (skulderRotRight) {
            skulderRotRight.style.transform = `rotate(${poseData.skulder_rot}deg)`;
            const albueRotRight = skulderRotRight.querySelector('.albue_rotate_right');
            if (albueRotRight) {
                albueRotRight.style.transform = `rotate(${poseData.albue_rot}deg)`;
            }
        }
    }
    
    if (hofteLeft) {
        hofteLeft.style.transform = `translate(${poseData.translate_x_left_leg}px, ${poseData.translate_y_left_leg}px)`;
        const hofteRotLeft = hofteLeft.querySelector('.hofte_rotate_left');
        if (hofteRotLeft) {
            hofteRotLeft.style.transform = `rotate(${poseData.hofte_rot_left}deg)`;
            const knaeRotLeft = hofteRotLeft.querySelector('.knae_rotate_left');
            if (knaeRotLeft) {
                knaeRotLeft.style.transform = `rotate(${poseData.knae_rot_left}deg)`;
            }
        }
    }
    
    if (hofteRight) {
        hofteRight.style.transform = `translate(${poseData.translate_x_right_leg}px, ${poseData.translate_y_right_leg}px)`;
        const hofteRotRight = hofteRight.querySelector('.hofte_rotate_right');
        if (hofteRotRight) {
            hofteRotRight.style.transform = `rotate(${poseData.hofte_rot_right}deg)`;
            const knaeRotRight = hofteRotRight.querySelector('.knae_rotate_right');
            if (knaeRotRight) {
                knaeRotRight.style.transform = `rotate(${poseData.knae_rot_right}deg)`;
            }
        }
    }
    
    // Reset arm layering
    skulderLeft?.classList.remove('front-arm');
    skulderRight?.classList.remove('front-arm');
}
		
		

        function updateButtonStates() {
            // Random button is enabled on steps 1 and 2 - participants are always present (Venstre/Højre)
            document.getElementById('randomBtn').disabled = (currentStep !== 1 && currentStep !== 2);
        }

        function setStatus(text) {
            document.getElementById('status').textContent = text;
        }

        function openColorPicker(btn, side) {
            currentColorTarget = btn;
            currentColorSide = side;
            
            const modal = document.getElementById('colorPickerModal');
            const picker = modal.querySelector('.picker');
            const btnRect = btn.getBoundingClientRect();
            
            modal.classList.add('show');
            picker.style.position = 'absolute';
            picker.style.left = (btnRect.right + 10) + 'px';
            picker.style.top = (btnRect.top - 20) + 'px';

            const pickerRect = picker.getBoundingClientRect();
            if (pickerRect.right > window.innerWidth) {
                picker.style.left = (btnRect.left - pickerRect.width - 10) + 'px';
            }
            if (pickerRect.bottom > window.innerHeight) {
                picker.style.top = (btnRect.bottom - pickerRect.height - 10) + 'px';
            }
        }
        
        function closeColorPicker() {
            document.getElementById('colorPickerModal').classList.remove('show');
            currentColorTarget = null;
            currentColorSide = null;
        }
        
        let currentNotePart = null;
        
        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            const scrollHeight = textarea.scrollHeight;
            const lineHeight = parseFloat(getComputedStyle(textarea).lineHeight) || 22.4;
            const minHeight = lineHeight + 12;
            textarea.style.height = Math.max(scrollHeight, minHeight) + 'px';
        }
        
        function openNoteOverlay(btn) {
            const participantCircle = btn.closest('.participant-circle');
            const side = participantCircle.id === 'leftCircle' ? 'left' : 'right';
            currentNotePart = { side, circle: participantCircle };
            
            const overlay = document.getElementById('noteOverlay');
            const textarea = document.getElementById('noteTextarea');
            const nameElement = document.getElementById(side + 'Name');
            
            // Load existing name
            const existingName = nameElement ? nameElement.textContent.trim() : '';
            textarea.value = existingName;
            
            // Auto-resize textarea to fit content
            autoResizeTextarea(textarea);
            
            // Position overlay near the button or over the participant circle
            const btnRect = btn.getBoundingClientRect();
            const circleRect = participantCircle.getBoundingClientRect();
            
            let overlayLeft = btnRect.right + 10;
            let overlayTop = btnRect.top;
            
            overlay.classList.add('show');
            const overlayRect = overlay.getBoundingClientRect();
            
            if (overlayLeft + overlayRect.width > window.innerWidth) {
                overlayLeft = circleRect.left + (circleRect.width / 2) - (overlayRect.width / 2);
                overlayTop = circleRect.top + (circleRect.height / 2) - (overlayRect.height / 2);
            }
            
            if (overlayLeft < 10) overlayLeft = 10;
            if (overlayLeft + overlayRect.width > window.innerWidth) overlayLeft = window.innerWidth - overlayRect.width - 10;
            if (overlayTop < 10) overlayTop = 10;
            if (overlayTop + overlayRect.height > window.innerHeight) overlayTop = window.innerHeight - overlayRect.height - 10;
            
            overlay.style.left = overlayLeft + 'px';
            overlay.style.top = overlayTop + 'px';
            
            // Remove previous input listener and add new one
            const newTextarea = textarea.cloneNode(true);
            newTextarea.value = textarea.value;
            textarea.parentNode.replaceChild(newTextarea, textarea);
            newTextarea.addEventListener('input', function() {
                autoResizeTextarea(newTextarea);
            });
            
            // Close overlay on Enter key
            newTextarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    closeNoteOverlay();
                }
            });
            
            setTimeout(() => {
                newTextarea.focus();
                newTextarea.select();
            }, 50);
        }
        
        function closeNoteOverlay() {
            const overlay = document.getElementById('noteOverlay');
            const textarea = document.getElementById('noteTextarea');
            
            if (currentNotePart && currentNotePart.side) {
                const nameText = textarea.value.trim();
                const nameElement = document.getElementById(currentNotePart.side + 'Name');
                if (nameElement) {
                    nameElement.textContent = nameText;
                    
                    // Save
                    syncCurrentWorkspaceToActiveComparison();
                }
            }
            
            overlay.classList.remove('show');
            currentNotePart = null;
        }
        
        function selectColor(hex) {
            if (currentColorSide) {
                if (currentColorSide === 'left') {
                    leftColor = hex;
                    leftLightColor = lightenColor(hex, 0.6);
                } else {
                    rightColor = hex;
                    rightLightColor = lightenColor(hex, 0.6);
                }
                
                const circle = document.getElementById(currentColorSide + 'Circle');
				const head = circle.querySelector('.head');
				if (head) {
					head.style.background = `linear-gradient(135deg, ${hex}, ${hex}dd)`;
					
				}
                
                updateBodyColors(currentColorSide, hex);
                
                const dropdown = document.getElementById(currentColorSide + 'Dropdown');
                if (dropdown.value === 'lav_ny_' + currentColorSide) {
                    partsData['lav_ny_' + currentColorSide].color = hex;
                }
                
                updateSliderColors();
            }
            
            setTimeout(() => closeColorPicker(), 100);
        }

        function updateComparisonView() {
            const content = document.getElementById('comparisonContent');
            
            // Always ensure we have active traits - participants are always present (Venstre/Højre)
            ensureActiveTraits();
            
            // Always show sliders - Venstre and Højre are always available
            const leftName = document.getElementById('leftName').textContent || 'Venstre';
            const rightName = document.getElementById('rightName').textContent || 'Højre';
            const activeTraits = getActiveTraits();
            
            content.innerHTML = `
                <div class="step-container">
                    <div class="progress-indicators">
                        <div class="progress-dot ${currentStep === 1 ? 'active' : (currentStep > 1 ? 'completed' : '')}"></div>
                        <div class="progress-dot ${currentStep === 2 ? 'active' : (currentStep > 2 ? 'completed' : '')}"></div>
                        <div class="progress-dot ${currentStep === 3 ? 'active' : ''}"></div>
                    </div>
                    
                    <div class="step-header">
                        <div class="step-title" id="stepTitle">Trin 1: Udfyld for ${leftName}</div>
                        <div class="step-nav">
                            <button class="step-btn ${currentStep === 1 ? 'active' : ''}" onclick="switchToStep(1)">1. ${leftName}</button>
                            <button class="step-btn ${currentStep === 2 ? 'active' : ''}" onclick="switchToStep(2)">2. ${rightName}</button>
                            <button class="step-btn ${currentStep === 3 ? 'active' : ''}" onclick="switchToStep(3)">3. Sammenlign</button>
                        </div>
                    </div>
                    
                    <div class="step-content ${currentStep === 1 ? 'active' : ''}" id="step1">
                        <p style="margin-bottom: 20px; color: #6b7280; font-style: italic;">Vurder hvor meget ${leftName} har af hver egenskab. Fokuser kun på denne del.</p>
                        <div class="single-side-traits" id="leftTraits">
                            ${activeTraits.map(({ trait, index }) => createSingleTraitHTML(trait, index, 'left', leftName)).join('')}
                        </div>
                    </div>
                    
                    <div class="step-content ${currentStep === 2 ? 'active' : ''}" id="step2">
                        <p style="margin-bottom: 20px; color: #6b7280; font-style: italic;">Vurder hvor meget ${rightName} har af hver egenskab. Fokuser kun på denne del.</p>
                        <div class="single-side-traits" id="rightTraits">
                            ${activeTraits.map(({ trait, index }) => createSingleTraitHTML(trait, index, 'right', rightName)).join('')}
                        </div>
                    </div>
                    
                    <div class="step-content ${currentStep === 3 ? 'active' : ''}" id="step3">
                        <p style="margin-bottom: 20px; color: #6b7280; font-style: italic;">Se ligheder og forskelle mellem dine to dele.</p>
                        <div id="comparisonResults">
                            ${createComparisonResultsHTML(leftName, rightName)}
                        </div>
                        <div class="speedometer-section">
                            <div class="speedometer-container speedometer-similarity">
                                <div class="speedometer-label">Ligheder</div>
                                <div class="speedometer">
                                    <svg viewBox="0 0 100 100">
                                        <circle cx="50" cy="50" r="40" class="speedometer-bg"/>
                                        <circle cx="50" cy="50" r="40" class="speedometer-fill" id="similarityFill" stroke-dasharray="251.2" stroke-dashoffset="251.2"/>
                                    </svg>
                                </div>
                                <div class="speedometer-value" id="similarityValue">0%</div>
                                <div style="font-size: 12px; color: #6b7280;">Hvor ens er de?</div>
                            </div>
                            
                            <div class="speedometer-container speedometer-difference">
                                <div class="speedometer-label">Forskelle</div>
                                <div class="speedometer">
                                    <svg viewBox="0 0 100 100">
                                        <circle cx="50" cy="50" r="40" class="speedometer-bg"/>
                                        <circle cx="50" cy="50" r="40" class="speedometer-fill" id="differenceFill" stroke-dasharray="251.2" stroke-dashoffset="251.2"/>
                                    </svg>
                                </div>
                                <div class="speedometer-value" id="differenceValue">0%</div>
                                <div style="font-size: 12px; color: #6b7280;">Hvor forskellige er de?</div>
                            </div>
                        </div>
                        <div style="margin-top: 30px;">
                            <label for="comparisonNotes" style="display: block; margin-bottom: 10px; font-weight: 600; color: #374151; font-size: 16px;">Noter</label>
                            <textarea id="comparisonNotes" placeholder="Tilføj noter til sammenligningen..." style="width: 100%; min-height: 150px; padding: 12px; border-radius: 10px; border: 2px solid #e2e8f0; font-size: 16px; font-family: inherit; resize: vertical; outline: none;" oninput="updateComparisonNotes(this.value)"></textarea>
                        </div>
                    </div>
                </div>
            `;

            // Update slider colors from participant colors
            updateSliderColors();
            if (currentStep === 3) {
                calculateAndDisplayScores();
            }
            setStatus(`Sammenligner ${leftName} og ${rightName} - Trin ${currentStep} af 3`);
        }

        function createSingleTraitHTML(trait, index, side, name) {
			const isLeft = side === 'left';
			const currentScore = (isLeft ? leftScores : rightScores)[index] || 0; // Ændret fra 50 til 0
			
			return `
				<div class="single-trait-item">
					<div class="single-slider-container">
                        <div class="single-slider-labels">
						    <span class="trait-left-label">${trait.left}</span>
						    <span class="trait-right-label">${trait.right}</span>
                        </div>
						<input type="range" min="-50" max="50" value="${currentScore}" 
							   class="single-slider ${side}-color" 
							   data-trait-id="${index}" 
							   data-side="${side}"
							   oninput="setSingleTraitScore(${index}, '${side}', this.value)">
					</div>
				</div>
			`;
		}

       function createComparisonResultsHTML(leftName, rightName) {
				const traitsWithSimilarity = [];
				const activeTraits = getActiveTraits();
				
				activeTraits.forEach(({ trait, index }) => {
					const leftScore = leftScores[index] || 0;
					const rightScore = rightScores[index] || 0;
					const similarity = 100 - Math.abs(leftScore - rightScore);
					
					traitsWithSimilarity.push({
						index,
						trait,
						leftScore,
						rightScore,
						similarity
					});
				});
				
				let html = '<div style="display: flex; flex-direction: column; gap: 8px;">';
				
				traitsWithSimilarity.forEach(item => {
					const { trait, leftScore, rightScore, similarity } = item;
					
					let percentColor;
					if (similarity >= 80) {
						percentColor = '#10b981';
					} else if (similarity >= 60) {
						percentColor = '#f59e0b';
					} else {
						percentColor = '#ef4444';
					}
					
					// Behold værdierne i -50:50 range
					let displayLeft = trait.left;
					let displayRight = trait.right;
					let leftPosition = leftScore;
					let rightPosition = rightScore;
					
					if (leftScore > rightScore) {
						displayLeft = trait.right;
						displayRight = trait.left;
						leftPosition = -leftScore;
						rightPosition = -rightScore;
					}
					
                    html += `
                        <div style="display: flex; align-items: flex-end; padding: 12px; background: #f8fafc; border-radius: 6px; gap: 10px;">
                            <div class="comparison-slider-group">
                                <div class="comparison-labels">
                                    <span class="comparison-left-label">${displayLeft}</span>
                                    <span class="comparison-right-label">${displayRight}</span>
                                </div>
                                <div class="comparison-slider-container">
                                    <input type="range" min="-50" max="50" value="${leftPosition}" class="comparison-slider left-color" disabled>
                                    <input type="range" min="-50" max="50" value="${rightPosition}" class="comparison-slider right-color" disabled>
                                </div>
                            </div>
                            <div style="flex: 0 0 60px; text-align: right; font-weight: bold; color: ${percentColor};">
                                ${Math.round(similarity)}%
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; margin-left: 6px;">
                                <button class="compare-color-btn" style="background: ${leftColor || '#3b82f6'}" onclick="writeComparisonDataLeft(${item.index})">C</button>
                                <button class="compare-color-btn" style="background: ${rightColor || '#ef4444'}" onclick="writeComparisonDataRight(${item.index})">C</button>
                            </div>
                        </div>
                    `;
				});
				
				html += '</div>';
				return html;
			}

        function writeComparisonDataLeft(traitIndex) {
            try {
                var leftNameEl = document.getElementById('leftName');
                var rightNameEl = document.getElementById('rightName');
                var youName = leftNameEl ? leftNameEl.textContent : '';
                var otherName = rightNameEl ? rightNameEl.textContent : '';

                var leftVal = (typeof leftScores[traitIndex] === 'number') ? leftScores[traitIndex] : 0;
                var rightVal = (typeof rightScores[traitIndex] === 'number') ? rightScores[traitIndex] : 0;

                // Determine labels for this trait in current display orientation
                var trait = defaultTraits[traitIndex];
                var leftLabel = trait.left;
                var rightLabel = trait.right;
                if ((leftScores[traitIndex] || 0) > (rightScores[traitIndex] || 0)) {
                    // We flipped labels in the UI for visualization; reflect that here too
                    leftLabel = trait.right;
                    rightLabel = trait.left;
                }
                
                // Convert to all lowercase
                leftLabel = leftLabel.toLowerCase();
                rightLabel = rightLabel.toLowerCase();

                // Get left participant's color, pose and flip status
                var leftColorValue = leftColor || '#3b82f6';
                var leftPoseIndex = 0; // Default to standard pose
                var leftPoseFlipped = false;
                
                // Read pose from data-pose attribute on participant element (more reliable than dropdown)
                var leftCircle = document.getElementById('leftCircle');
                if (leftCircle) {
                    var leftParticipant = leftCircle.parentElement;
                    if (leftParticipant) {
                        var dataPose = leftParticipant.getAttribute('data-pose');
                        if (dataPose !== null && dataPose !== '') {
                            leftPoseIndex = Number(dataPose);
                        }
                        var dataMirror = leftParticipant.getAttribute('data-mirror');
                        leftPoseFlipped = dataMirror === 'true';
                    }
                }

                var payload = {
                    "You": youName,
                    "Other": otherName,
                    "You_slider": String(leftVal),
                    "Other_slider": String(rightVal),
                    "left_label": leftLabel,
                    "right_label": rightLabel,
                    "You_color": leftColorValue,
                    "You_pose": leftPoseIndex,
                    "You_pose_flipped": leftPoseFlipped
                };

                localStorage.setItem('compareCoachingData', JSON.stringify(payload));
                console.log('Gemmer compareCoachingData:', payload);
                setStatus('Skrev compareCoachingData for trait #' + traitIndex);
                
                // Open coaching overlay with compare_coaching.json
                console.log('Kalder openCoachingOverlayFromFile med:', 'coaching_templates/compare_coaching.json');
                console.log('openCoachingOverlayFromFile type:', typeof openCoachingOverlayFromFile);
                console.log('window.openCoachingOverlayFromFile type:', typeof window.openCoachingOverlayFromFile);
                
                if (typeof openCoachingOverlayFromFile === 'function') {
                    console.log('Bruger openCoachingOverlayFromFile direkte');
                    openCoachingOverlayFromFile('coaching_templates/compare_coaching.json');
                } else if (typeof window.openCoachingOverlayFromFile === 'function') {
                    console.log('Bruger window.openCoachingOverlayFromFile');
                    window.openCoachingOverlayFromFile('coaching_templates/compare_coaching.json');
                } else if (typeof openCoachingOverlay === 'function') {
                    console.log('Bruger openCoachingOverlay som fallback');
                    openCoachingOverlay('coaching_templates/compare_coaching.json');
                } else {
                    console.error('Ingen coaching overlay funktion fundet!');
                    alert('Coaching overlay funktion ikke tilgængelig. Sørg for at coaching_overlay_complete.js er indlæst.');
                }
            } catch (e) {
                console.error('writeComparisonDataLeft error:', e);
            }
        }

        function writeComparisonDataRight(traitIndex) {
            try {
                var leftNameEl = document.getElementById('leftName');
                var rightNameEl = document.getElementById('rightName');
                var youName = rightNameEl ? rightNameEl.textContent : '';
                var otherName = leftNameEl ? leftNameEl.textContent : '';

                var leftVal = (typeof leftScores[traitIndex] === 'number') ? leftScores[traitIndex] : 0;
                var rightVal = (typeof rightScores[traitIndex] === 'number') ? rightScores[traitIndex] : 0;

                // use same label orientation as left click
                var trait = defaultTraits[traitIndex];
                var leftLabel = trait.left;
                var rightLabel = trait.right;
                if ((leftScores[traitIndex] || 0) > (rightScores[traitIndex] || 0)) {
                    leftLabel = trait.right;
                    rightLabel = trait.left;
                }
                
                // Convert to all lowercase
                leftLabel = leftLabel.toLowerCase();
                rightLabel = rightLabel.toLowerCase();

                // Get right participant's color, pose and flip status
                var rightColorValue = rightColor || '#ef4444';
                var rightPoseIndex = 0; // Default to standard pose
                var rightPoseFlipped = false;
                
                // Read pose from data-pose attribute on participant element (more reliable than dropdown)
                var rightCircle = document.getElementById('rightCircle');
                if (rightCircle) {
                    var rightParticipant = rightCircle.parentElement;
                    if (rightParticipant) {
                        var dataPose = rightParticipant.getAttribute('data-pose');
                        if (dataPose !== null && dataPose !== '') {
                            rightPoseIndex = Number(dataPose);
                        }
                        var dataMirror = rightParticipant.getAttribute('data-mirror');
                        rightPoseFlipped = dataMirror === 'true';
                    }
                }

                var payload = {
                    "You": youName,
                    "Other": otherName,
                    "You_slider": String(rightVal),
                    "Other_slider": String(leftVal),
                    "left_label": leftLabel,
                    "right_label": rightLabel,
                    "You_color": rightColorValue,
                    "You_pose": rightPoseIndex,
                    "You_pose_flipped": rightPoseFlipped
                };

                localStorage.setItem('compareCoachingData', JSON.stringify(payload));
                console.log('Gemmer compareCoachingData:', payload);
                setStatus('Skrev compareCoachingData (højre) for trait #' + traitIndex);
                
                // Open coaching overlay with compare_coaching.json
                console.log('Kalder openCoachingOverlayFromFile med:', 'coaching_templates/compare_coaching.json');
                console.log('openCoachingOverlayFromFile type:', typeof openCoachingOverlayFromFile);
                console.log('window.openCoachingOverlayFromFile type:', typeof window.openCoachingOverlayFromFile);
                
                if (typeof openCoachingOverlayFromFile === 'function') {
                    console.log('Bruger openCoachingOverlayFromFile direkte');
                    openCoachingOverlayFromFile('coaching_templates/compare_coaching.json');
                } else if (typeof window.openCoachingOverlayFromFile === 'function') {
                    console.log('Bruger window.openCoachingOverlayFromFile');
                    window.openCoachingOverlayFromFile('coaching_templates/compare_coaching.json');
                } else if (typeof openCoachingOverlay === 'function') {
                    console.log('Bruger openCoachingOverlay som fallback');
                    openCoachingOverlay('coaching_templates/compare_coaching.json');
                } else {
                    console.error('Ingen coaching overlay funktion fundet!');
                    alert('Coaching overlay funktion ikke tilgængelig. Sørg for at coaching_overlay_complete.js er indlæst.');
                }
            } catch (e) {
                console.error('writeComparisonDataRight error:', e);
            }
        }


        // Debounce timeout for saving slider scores
        let sliderScoreDebounceTimeout = null;
        
        function setSingleTraitScore(traitId, side, value) {
            if (side === 'left') {
                leftScores[traitId] = parseInt(value);
            } else {
                rightScores[traitId] = parseInt(value);
            }
            
            // Clear previous debounce timeout
            if (sliderScoreDebounceTimeout) {
                clearTimeout(sliderScoreDebounceTimeout);
            }
            
            // Save scores to Firestore with debounce (2 seconds)
            sliderScoreDebounceTimeout = setTimeout(async () => {
                await syncCurrentWorkspaceToActiveComparison();
                sliderScoreDebounceTimeout = null;
            }, 2000);
            
            if (currentStep === 3) {
                updateComparisonResults();
                calculateAndDisplayScores();
            }
        }

        function switchToStep(step) {
            currentStep = step;
            
            // Update step content visibility
            document.querySelectorAll('.step-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`step${step}`).classList.add('active');
            
            // Update step buttons
            document.querySelectorAll('.step-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelectorAll('.step-btn')[step - 1].classList.add('active');
            
            // Update progress dots
            document.querySelectorAll('.progress-dot').forEach((dot, index) => {
                dot.classList.remove('active', 'completed');
                if (index + 1 === step) {
                    dot.classList.add('active');
                } else if (index + 1 < step) {
                    dot.classList.add('completed');
                }
            });
            
            // Update title
            const leftName = document.getElementById('leftName').textContent || 'Venstre del';
            const rightName = document.getElementById('rightName').textContent || 'Højre del';
            const titles = [
                `Trin 1: Udfyld for ${leftName}`,
                `Trin 2: Udfyld for ${rightName}`,
                `Trin 3: Sammenlign resultaterne`
            ];
            document.getElementById('stepTitle').textContent = titles[step - 1];
            
            if (step === 3) {
                updateComparisonResults();
                calculateAndDisplayScores();
            }
            
            // Update button states when switching steps
            updateButtonStates();
        }

        function updateComparisonResults() {
            const leftName = document.getElementById('leftName').textContent || 'Venstre del';
            const rightName = document.getElementById('rightName').textContent || 'Højre del';
            const resultsContainer = document.getElementById('comparisonResults');
            if (resultsContainer) {
                resultsContainer.innerHTML = createComparisonResultsHTML(leftName, rightName);
            }
        }

        function calculateAndDisplayScores() {
            let totalSimilarity = 0;
            let totalDifference = 0;
            let count = 0;
            
            const activeTraits = getActiveTraits();
            activeTraits.forEach(({ index }) => {
                const leftScore = leftScores[index];
                const rightScore = rightScores[index];
                
                if (leftScore !== undefined && rightScore !== undefined) {
                    const difference = Math.abs(leftScore - rightScore);
                    const similarity = 100 - difference;
                    
                    totalSimilarity += similarity;
                    totalDifference += difference;
                    count++;
                }
            });
            
            if (count > 0) {
                const avgSimilarity = totalSimilarity / count;
                const avgDifference = totalDifference / count;
                
                updateSpeedometer('similarity', avgSimilarity);
                updateSpeedometer('difference', avgDifference);
            } else {
                updateSpeedometer('similarity', 0);
                updateSpeedometer('difference', 0);
            }
        }

        function updateSpeedometer(type, percentage) {
            const circumference = 2 * Math.PI * 40; // radius = 40
            const offset = circumference - (percentage / 100) * circumference;
            
            const fillElement = document.getElementById(`${type}Fill`);
            const valueElement = document.getElementById(`${type}Value`);
            
            if (fillElement && valueElement) {
                fillElement.style.strokeDashoffset = offset;
                valueElement.textContent = Math.round(percentage) + '%';
            }
        }

        function randomizeCurrentStep() {
            // Only work on steps 1 and 2
            if (currentStep !== 1 && currentStep !== 2) return;
            
            const side = currentStep === 1 ? 'left' : 'right';
            
            // Generate random values for all traits (-50 to 50)
            const activeTraits = getActiveTraits();
            if (activeTraits.length === 0) {
                return;
            }
            activeTraits.forEach(({ index }) => {
                const randomValue = Math.floor(Math.random() * 101) - 50;
                
                if (side === 'left') {
                    leftScores[index] = randomValue;
                } else {
                    rightScores[index] = randomValue;
                }
                
                const slider = document.querySelector(`input[data-trait-id="${index}"][data-side="${side}"]`);
                if (slider) {
                    slider.value = randomValue;
                }
            });
            
            // Update comparison view if we're on step 3
            if (currentStep === 3) {
                updateComparisonResults();
                calculateAndDisplayScores();
            }
            
            // Show feedback
            const sideName = side === 'left' ? 'venstre' : 'højre';
            setStatus(`Tilfældige værdier sat for ${sideName} del`);
        }

        // CSV import/export functions removed - no longer needed

        async function clearAll() {
			// Reset all sliders to 0
			leftScores = {};
			rightScores = {};
			
			// Select 6 new random traits
			const indices = Array.from({ length: defaultTraits.length }, (_, idx) => idx);
			for (let i = indices.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[indices[i], indices[j]] = [indices[j], indices[i]];
			}
			activeTraitIndices = indices.slice(0, ACTIVE_TRAIT_COUNT).sort((a, b) => a - b);
			currentTraitSelectionKey = null;
		
			// Set participants to "Venstre" and "Højre"
			const leftNameEl = document.getElementById('leftName');
			const rightNameEl = document.getElementById('rightName');
			if (leftNameEl) leftNameEl.textContent = 'Venstre';
			if (rightNameEl) rightNameEl.textContent = 'Højre';
			
			// Reset colors
			leftColor = '#3b82f6';
			rightColor = '#ef4444';
			leftLightColor = lightenColor(leftColor, 0.6);
			rightLightColor = lightenColor(rightColor, 0.6);
			
			// Reset step
			currentStep = 1;
			
			// Clear notes
			comparisonNotes = '';
			const notesTextarea = document.getElementById('comparisonNotes');
			if (notesTextarea) notesTextarea.value = '';
			
			// Clear dropdowns
            document.getElementById('leftDropdown').value = '';
            document.getElementById('rightDropdown').value = '';
			
			// Show circles with default participants
            const leftCircle = document.getElementById('leftCircle');
            const rightCircle = document.getElementById('rightCircle');
			if (leftCircle) {
            leftCircle.style.display = 'flex';
				const head = leftCircle.querySelector('.head');
				if (head) {
					head.style.background = `linear-gradient(135deg, ${leftColor}, ${leftColor})`;
				}
				updateBodyColors('left', leftColor);
			}
			if (rightCircle) {
            rightCircle.style.display = 'flex';
				const head = rightCircle.querySelector('.head');
				if (head) {
					head.style.background = `linear-gradient(135deg, ${rightColor}, ${rightColor})`;
				}
				updateBodyColors('right', rightColor);
			}
			
			// Update slider colors
            updateSliderColors();
            
			// Reset pose and mirror to standard
    const leftPose = document.getElementById('leftPose');
    const rightPose = document.getElementById('rightPose');
    const leftMirror = document.getElementById('leftMirror');
    const rightMirror = document.getElementById('rightMirror');
    
			// Reset to standard pose
			resetPose('left');
			resetPose('right');
			
			// Clear mirror checkboxes
    if (leftMirror) leftMirror.checked = false;
    if (rightMirror) rightMirror.checked = false;
    
			// Update data-mirror attributes
			const leftParticipant = leftCircle ? leftCircle.closest('.participant') : null;
			const rightParticipant = rightCircle ? rightCircle.closest('.participant') : null;
			if (leftParticipant) {
				leftParticipant.setAttribute('data-mirror', 'false');
			}
			if (rightParticipant) {
				rightParticipant.setAttribute('data-mirror', 'false');
			}
    
			// Update UI
    updateComparisonView();
    updateButtonStates();
			
			// Sync to active comparison (this will save the cleared state to the active history item)
			await syncCurrentWorkspaceToActiveComparison();
}

        // CSV data persistence functions removed - no longer needed

// adjustDistance function removed - distance functionality no longer needed



        function confirmBackToOpstilling() {
            if (confirm('Brug "Gem Sammenligning" hvis du vil beholde dit arbejde.\n\nVil du fortsætte til Relations Opstilling?')) {
                window.location.href = 'opstilling_01.html';
            }
        }

        // Wait for Firebase auth state to be ready
        if (auth) {
            auth.onAuthStateChanged(user => {
                currentUser = user;
                
                // Mark auth as ready and resolve promise
                if (!authStateReady) {
                    authStateReady = true;
                    if (authStateResolver) {
                        authStateResolver();
                        authStateResolver = null;
                    }
                }
            });
        }

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', async function() {
            // GUARD 1: Extend initial load period - wait for ALL
            
            // 1. Wait for auth state (max 3 seconds)
            try {
                await Promise.race([
                    authStatePromise,
                    new Promise(resolve => setTimeout(resolve, 3000))
                ]);
            } catch (e) {
                console.warn('Auth state wait error:', e);
            }
            
            // Resolve manually if not resolved yet
            if (!authStateReady && authStateResolver) {
                authStateResolver();
                authStateResolver = null;
            }
            
            // 2. Check if user is logged in - require login
            if (!currentUser) {
                alert('Du skal være logget ind for at bruge denne side. Redirecter til login...');
                window.location.href = 'index.html';
                return;
            }
            
            // 3. Load data ÉN gang
            const data = await loadCompareData();
            if (data) {
                CompareData = data;
            } else {
                // No data in Firestore, create defaults
                CompareData = null;
                await ensureDefaultCompareData();
            }
            console.log('[INIT] Loaded compare data, collections:', CompareData?.collections?.length || 0);
            
            // 5. Wait for DOM to be fully rendered
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // 6. NU FØRST: Mark initial load complete
            isInitialLoad = false;
            console.log('[INIT] Initial load complete');
            
            // Load pose library first
            await loadPoseLibrary();
            // Load animations
            await loadAnimations();
            // Initialize color picker grid
            const grid = document.getElementById('colorGrid');
            
            for(let row = 0; row < 14; row++) {
                for(let col = 0; col < 12; col++) {
                    let hex;
                    
                    if(row === 0) {
                        const hue = Math.round(col * 360/12);
                        hex = hslToHex(hue, 95, 50);
                    } else if(row === 1) {
                        const light = Math.round(100 - (col * (100/11)));
                        hex = hslToHex(0, 0, light);
                    } else {
                        const gridRow = row - 2;
                        const hue = Math.round(col * 360/12);
                        const light = Math.round(92 - (gridRow * (84/11)));
                        const satBase = 86;
                        const sat = Math.round(satBase - Math.abs((col - 6)/ 6) * 20);
                        hex = hslToHex(hue, sat, light);
                    }
                    
                    const swatch = document.createElement('button');
                    swatch.className = 'swatch';
                    swatch.style.background = hex;
                    swatch.dataset.hex = hex;
                    swatch.title = hex;
                    swatch.setAttribute('aria-label', `Farve ${hex}`);
                    swatch.tabIndex = 0;
                    
                    swatch.addEventListener('click', () => selectColor(hex));
                    
                    grid.appendChild(swatch);
                }
            }
            
            // Event listeners
            document.getElementById('colorPickerModal').addEventListener('click', function(e) {
                if (e.target === this) closeColorPicker();
            });

            // Load shared characters first (inject into partsData), then build dropdowns
            initializeDropdowns();
			initializePoseDropdowns();  
            
            // Listen for localStorage changes (cross-tab synchronization)
            window.addEventListener('storage', function(e) {
                if (e.key === 'relationsSetupData') {
                    (window.__APP_DEBUG__ && console.log('localStorage relationsSetupData updated, refreshing comparison dropdowns...'));
                    handleStorageUpdate();
                }
            });
            
            document.getElementById('leftDropdown').addEventListener('change', () => updateParticipant('left'));
            document.getElementById('rightDropdown').addEventListener('change', () => updateParticipant('right'));
            
            // Name is only editable via the "N" button
            const leftNameEl = document.getElementById('leftName');
            const rightNameEl = document.getElementById('rightName');
            if (leftNameEl) {
                leftNameEl.contentEditable = 'false';
                leftNameEl.style.cursor = 'default';
            }
            if (rightNameEl) {
                rightNameEl.contentEditable = 'false';
                rightNameEl.style.cursor = 'default';
            }
            
            document.getElementById('leftColorBtn').addEventListener('click', function(e) {
                e.stopPropagation();
                openColorPicker(this, 'left');
            });
            document.getElementById('rightColorBtn').addEventListener('click', function(e) {
                e.stopPropagation();
                openColorPicker(this, 'right');
            });
			
			// Pose picker modal close on outside click
			document.getElementById('posePickerModal').addEventListener('click', function(e) {
				if (e.target === this) {
					closePosePicker();
				}
			});

			// Pose buttons
			document.getElementById('leftPoseBtn').addEventListener('click', function(e) {
				e.stopPropagation();
				openPosePicker(this);
			});
			document.getElementById('rightPoseBtn').addEventListener('click', function(e) {
				e.stopPropagation();
				openPosePicker(this);
			});
			
			document.getElementById('leftNoteBtn').addEventListener('click', function(e) {
				e.stopPropagation();
				openNoteOverlay(this);
			});
			document.getElementById('rightNoteBtn').addEventListener('click', function(e) {
				e.stopPropagation();
				openNoteOverlay(this);
			});
			
			// Note overlay - close when clicking outside
			document.addEventListener('click', function(e) {
				const noteOverlay = document.getElementById('noteOverlay');
				if (noteOverlay && noteOverlay.classList.contains('show')) {
					if (!noteOverlay.contains(e.target)) {
						closeNoteOverlay();
					}
				}
			});
			
			// Prevent clicks inside note overlay from closing it
			const noteOverlay = document.getElementById('noteOverlay');
			if (noteOverlay) {
				noteOverlay.addEventListener('click', function(e) {
					e.stopPropagation();
				});
			}
            
			// Save when pose changes via dropdown
			const leftPoseDropdown = document.getElementById('leftPose');
			const rightPoseDropdown = document.getElementById('rightPose');
			if (leftPoseDropdown) {
				leftPoseDropdown.addEventListener('change', async function() {
					const poseIndex = this.value;
					if (poseIndex) {
						applyPose('left', poseIndex);
					} else {
						resetPose('left');
					}
					await syncCurrentWorkspaceToActiveComparison();
				});
			}
			if (rightPoseDropdown) {
				rightPoseDropdown.addEventListener('change', async function() {
					const poseIndex = this.value;
					if (poseIndex) {
						applyPose('right', poseIndex);
					} else {
						resetPose('right');
					}
					await syncCurrentWorkspaceToActiveComparison();
				});
			}
			
			// Save when mirror changes
			const leftMirror = document.getElementById('leftMirror');
			const rightMirror = document.getElementById('rightMirror');
			if (leftMirror) {
				leftMirror.addEventListener('change', function() {
					toggleMirror('left');
				});
			}
			if (rightMirror) {
				rightMirror.addEventListener('change', function() {
					toggleMirror('right');
				});
			}
            
            document.querySelector('.clear-btn').addEventListener('click', clearAll);
            document.getElementById('randomBtn').addEventListener('click', randomizeCurrentStep);
            
            // CompareData is already loaded above in GUARD 1
            
            // Initialize history sidebar
            // Default to collapsed (true) unless explicitly set to false in localStorage
            const savedCollapsed = localStorage.getItem('compare_historySidebarCollapsed');
            historySidebarCollapsed = savedCollapsed === null || savedCollapsed === 'true';
            const sidebar = document.getElementById('historySidebar');
            if (sidebar) {
                const toggleBtns = sidebar.querySelectorAll('.collapse-toggle');
                if (historySidebarCollapsed) {
                    sidebar.classList.add('collapsed');
                    toggleBtns.forEach(btn => btn.textContent = '<');
                } else {
                    sidebar.classList.remove('collapsed');
                    toggleBtns.forEach(btn => btn.textContent = '>');
                }
            }
            
            // Initialize samling manager elements
            samlingManagerOverlayEl = document.getElementById('samlingManagerOverlay');
            samlingManagerListEl = document.getElementById('samlingManagerList');
            newSamlingNameInputEl = document.getElementById('newSamlingName');
            newSamlingColorBtnEl = document.getElementById('newSamlingColorBtn');
            samlingColorPickerModalEl = document.getElementById('samlingColorPickerModal');
            samlingColorGridEl = document.getElementById('samlingColorGrid');
            
            // Build color grid
            if (samlingColorGridEl) {
                buildSamlingColorGrid();
            }
            
            // Load active comparison
            const activeComparison = getActiveComparison();
            if (activeComparison) {
                loadComparisonFromCompareData(activeComparison);
            } else {
                // If no active comparison, ensure default participants (Venstre/Højre) are visible
                const leftCircle = document.getElementById('leftCircle');
                const rightCircle = document.getElementById('rightCircle');
                const leftNameEl = document.getElementById('leftName');
                const rightNameEl = document.getElementById('rightName');
                
                // Set default colors
                if (!leftColor) leftColor = '#3b82f6';
                if (!rightColor) rightColor = '#ef4444';
                leftLightColor = lightenColor(leftColor, 0.6);
                rightLightColor = lightenColor(rightColor, 0.6);
                
                // Ensure circles are visible with default names
                if (leftCircle) {
                    leftCircle.style.display = 'flex';
                    const head = leftCircle.querySelector('.head');
                    if (head) {
                        head.style.background = `linear-gradient(135deg, ${leftColor}, ${leftColor})`;
                    }
                    updateBodyColors('left', leftColor);
                }
                if (rightCircle) {
                    rightCircle.style.display = 'flex';
                    const head = rightCircle.querySelector('.head');
                    if (head) {
                        head.style.background = `linear-gradient(135deg, ${rightColor}, ${rightColor})`;
                    }
                    updateBodyColors('right', rightColor);
                }
                
                // Set default names
                if (leftNameEl) leftNameEl.textContent = 'Venstre';
                if (rightNameEl) rightNameEl.textContent = 'Højre';
                
                // Ensure we have active traits
                ensureActiveTraits();
                
                updateSliderColors();
                updateComparisonView();
            }
            
            // Render history
            renderHistory();
            renderHistoryFilterOptions();
            
            // Setup event listeners
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (samlingManagerOverlayEl && samlingManagerOverlayEl.classList.contains('show')) {
                        closeSamlingManager();
                    }
                    if (samlingColorPickerModalEl && samlingColorPickerModalEl.classList.contains('show')) {
                        closeSamlingColorPicker();
                    }
                }
            });
            
            updateButtonStates();
            
            // Navigation overlay functionality - optimized with event delegation
            const navBox = document.getElementById('navBox');
            const navToggleBtn = document.querySelector('.nav-toggle-btn');
            
            if (navBox) {
                // Mark current page as active
                const currentPage = 'compare_01.html';
                const navButtons = document.querySelectorAll('.nav-button');
                navButtons.forEach(btn => {
                    if (btn.getAttribute('href') === currentPage || btn.textContent.trim() === 'Ligheder') {
                        btn.classList.add('active');
                    }
                });
                
                // Use event delegation for nav button clicks (only one listener instead of multiple)
                navBox.addEventListener('click', function(e) {
                    const navButton = e.target.closest('.nav-button');
                    if (navButton) {
                        e.stopPropagation();
                        navBox.classList.remove('show');
                        const href = navButton.getAttribute('href');
                        if (href) {
                            window.location.href = href;
                        }
                    }
                });
            }
            
            // Close nav box when clicking outside - single listener
            document.addEventListener('click', function(e) {
                if (navBox && navBox.classList.contains('show')) {
                    if (!navBox.contains(e.target) && e.target !== navToggleBtn && !navToggleBtn?.contains(e.target)) {
                        navBox.classList.remove('show');
                    }
                }
            });
        });
        
        // Navigation overlay toggle function
        function toggleNavBox() {
            const navBox = document.getElementById('navBox');
            const navToggleBtn = document.querySelector('.nav-toggle-btn');
            
            if (navBox && navToggleBtn) {
                const isShowing = navBox.classList.contains('show');
                if (isShowing) {
                    navBox.classList.remove('show');
                } else {
                    // Position nav-box at top-left corner of toggle button
                    const rect = navToggleBtn.getBoundingClientRect();
                    navBox.style.top = rect.top + 'px';
                    navBox.style.left = rect.left + 'px';
                    navBox.classList.add('show');
                }
            }
        }
    </script>
    
    <!-- Samling Manager Overlay -->
    <div class="samling-manager-overlay" id="samlingManagerOverlay">
        <div class="samling-manager-backdrop" onclick="closeSamlingManager()"></div>
        <div class="samling-manager-panel">
            <div class="samling-manager-header">
                <h2>Samlinger</h2>
                <button class="samling-manager-close" onclick="closeSamlingManager()" title="Luk">×</button>
            </div>
            <div class="samling-manager-list" id="samlingManagerList"></div>
            <div class="samling-manager-divider"></div>
            <div class="samling-manager-new" id="samlingManagerNewRow">
                <input type="text" id="newSamlingName" placeholder="Ny samling-navn" autocomplete="off">
                <div class="samling-manager-actions">
                    <button class="samling-color-select" id="newSamlingColorBtn" onclick="openSamlingColorPicker({ type: 'new' })" title="Vælg farve">C</button>
                    <button class="samling-create-btn" onclick="confirmCreateSamling()" title="Opret samling">✓</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Samling Color Picker Modal -->
    <div class="samling-color-picker-modal" id="samlingColorPickerModal" onclick="backdropCloseSamlingHandler(event)">
        <div class="samling-color-picker" onclick="event.stopPropagation()">
            <div class="samling-color-picker-header">
                <h3>Vælg farve</h3>
            </div>
            <div class="samling-color-grid" id="samlingColorGrid"></div>
        </div>
    </div>
    
    <!-- Navigation overlay -->
    <div class="nav-overlay" id="navOverlay"></div>
</body>
</html>