<!DOCTYPE html>
<html lang="da">
<head>
	<script src="https://cdn.jsdelivr.net/npm/modern-screenshot@4.4.39/dist/index.js"></script>
    <!-- Firebase App (the core Firebase SDK) -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <!-- Firebase Authentication -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <!-- Firestore -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="imagefiles/apple-touch-icon.png">
    <title>Relations Opstilling - Multi-Background System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 0px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 0px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 40px);
        }
        
        .header {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            padding: 16px 24px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        
        .header h1 {
            font-size: 2.0em;
            margin-bottom: 0px;
            font-weight: 300;
            width: 100%;
            text-align: center;
        }
        
        .header .nav-controls {
            position: absolute;
            top: 16px;
            left: 24px;
            display: inline-flex;
            flex-direction: column;
            gap: 0;
            align-items: flex-start;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .toolbar {
            background: #f8fafc;
            padding: 12px 20px;

            border-bottom: 1px solid #e2e8f0;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .toolbar select, .toolbar input, .toolbar button:not(.nav-button) {
			padding: 8px 16px;
			border: 2px solid #e2e8f0;
			border-radius: 10px;
			font-size: 16px;
			transition: all 0.3s ease;
		}
        
        .toolbar select {
            background: white;
            min-width: 180px;
            font-family: inherit;
        }
        
        .toolbar input[type="text"] {
            flex: 1;
            min-width: 200px;
            background: white;
        }

        /* Limit part name input width */
        #partName {
            max-width: 250px;
        }
        
        .toolbar input[type="text"]:focus, .toolbar select:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        .toolbar button:not(.nav-button) {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }
        
        .toolbar button:not(.nav-button):hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }
        
        .clear-btn {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important;
        }
        
        .clear-btn:hover {
            box-shadow: 0 5px 15px rgba(239, 68, 68, 0.3) !important;
        }
        
        button[onclick="openSamlingManager()"] {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important;
            color: white !important;
        }
        
        button[onclick="openSamlingManager()"]:hover {
            box-shadow: 0 5px 15px rgba(239, 68, 68, 0.3) !important;
        }
        
        button[onclick="createNewSetup()"] {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%) !important;
            color: white !important;
        }
        
        button[onclick="createNewSetup()"]:hover {
            box-shadow: 0 5px 15px rgba(251, 191, 36, 0.3) !important;
        }
        
        button[onclick="addPart()"] {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important;
            color: white !important;
        }
        
        button[onclick="addPart()"]:hover {
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3) !important;
        }
        
        .save-btn {
			background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%) !important;
		}

		.save-btn:hover {
			box-shadow: 0 5px 15px rgba(139, 92, 246, 0.3) !important;
		}
        
		.export-btn {
			background: linear-gradient(135deg, #f97316 0%, #ea580c 100%) !important;
		}

		.export-btn:hover {
			box-shadow: 0 5px 15px rgba(249, 115, 22, 0.3) !important;
		}
		
		
        .load-btn {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%) !important;
        }
        
        .load-btn:hover {
            box-shadow: 0 5px 15px rgba(6, 182, 212, 0.3) !important;
        }
        
        .nav-btn {
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%) !important;
        }
        
        .nav-btn:hover {
            box-shadow: 0 5px 15px rgba(99, 102, 241, 0.3) !important;
        }
        
        .nav-btn-yellow {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%) !important;
        }
        
        .nav-btn-yellow:hover {
            box-shadow: 0 5px 15px rgba(245, 158, 11, 0.3) !important;
        }
        
        .nav-btn-pink {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%) !important;
        }
        
        .nav-btn-pink:hover {
            box-shadow: 0 5px 15px rgba(236, 72, 153, 0.3) !important;
        }
        
        .toolbar-separator {
            width: 1px;
            height: 30px;
            background: #e2e8f0;
            margin: 0 8px;
            flex-shrink: 0;
        }
        
        /* Navigation overlay */
        .nav-toggle-btn {
            width: 35px;
            height: 35px;
            padding: 5px 8px;
            border: none;
            border-radius: 12px;
            background: #e5e7eb;
            color: #374151;
            box-shadow: 0 12px 26px rgba(15, 23, 42, 0.16);
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            cursor: pointer;
            transition: all 0.25s ease;
        }
        
        .nav-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(107, 114, 128, 0.3);
        }
        
        .nav-toggle-btn span {
            width: 16px;
            height: 2px;
            border-radius: 999px;
            background: #374151;
        }
        
        .nav-overlay {
            display: none !important;
        }
        
        .nav-box {
            position: fixed;
            top: 0;
            left: 0;
            background: white;
            border-radius: 20px;
            padding: 20px 25px;
            z-index: 9999;
            display: none;
            flex-direction: column;
            gap: 10px;
            min-width: 200px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        
        .nav-box.show {
            display: flex;
        }
        
        .nav-button {
            padding: 8px 16px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            text-align: center;
            display: block;
            min-width: auto;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
        }
        
        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }
        
        .nav-button.active {
            background: #9ca3af !important;
            cursor: default;
            pointer-events: none;
        }
        
        .nav-button:nth-child(1) {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        
        .nav-button:nth-child(1):hover:not(.active) {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }
        
        .nav-button:nth-child(2) {
            background: linear-gradient(135deg, #E6B94F 0%, #d97706 100%);
        }
        
        .nav-button:nth-child(2):hover:not(.active) {
            background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
            box-shadow: 0 5px 15px rgba(245, 158, 11, 0.3);
        }
        
        .nav-button:nth-child(3) {
            background: linear-gradient(135deg, #3368AE 0%, #1e40af 100%);
        }
        
        .nav-button:nth-child(3):hover:not(.active) {
            background: linear-gradient(135deg, #1e40af 0%, #1e3a8a 100%);
            box-shadow: 0 5px 15px rgba(37, 99, 235, 0.3);
        }
        
        .nav-button:nth-child(4) {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
        }
        
        .nav-button:nth-child(4):hover:not(.active) {
            background: linear-gradient(135deg, #db2777 0%, #be185d 100%);
            box-shadow: 0 5px 15px rgba(236, 72, 153, 0.3);
        }
        
        .nav-button:nth-child(5) {
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
        }
        
        .nav-button:nth-child(5):hover:not(.active) {
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
            box-shadow: 0 5px 15px rgba(71, 85, 105, 0.3);
        }
        
        .main-content {
            position: relative;
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
            -webkit-overflow-scrolling: touch;
        }
        
        .workspace-container {
            display: flex;
            flex-direction: column;
            min-height: 100%;
            position: relative;
        }
        
        .workspace {
            flex: 1;
            position: relative;
            height: 600px;
            max-height: 600px;
            min-height: 600px;
            width: 100%;
            max-width: 1200px;
            min-width: 0;
            position: relative;
            background: #fafafa;
            overflow: auto;
            cursor: crosshair;
            touch-action: auto;
            -webkit-overflow-scrolling: touch;
            box-sizing: border-box;
            /* Force workspace to respect max-width and not grow with viewport */
            display: block;
        }
        
        /* Create a fixed-size scrollable content area */
        .workspace-content {
            position: relative;
            width: 1200px;
            height: 600px;
            min-width: 1200px;
            min-height: 600px;
        }
        
        .background-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        
        /* History Sidebar (from bodymap_01.html) */
        .history-sidebar {
            width: 250px;
            background: #f8fafc;
            border-left: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            transform: translateX(0);
            transition: transform 0.3s ease;
            z-index: 4000;
        }
        
        .history-sidebar.collapsed {
            transform: translateX(220px);
        }
        
        .history-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            height: 100%;
        }
        
        .history-sidebar.collapsed .history-content {
            display: none;
        }
        
        .history-sidebar.collapsed .history-header {
            justify-content: center;
            font-size: 0;
            padding-left: 16px;
        }
        
        .history-header {
            background: #e2e8f0;
            padding: 10px 12px 10px 40px;
            text-align: center;
            font-weight: bold;
            color: #374151;
            border-bottom: 2px solid #d1d5db;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
            height: 50px;
            min-height: 50px;
            max-height: 50px;
            box-sizing: border-box;
            position: relative;
        }
        
        .history-filter {
            flex: 1;
            min-width: 180px;
            padding: 6px 14px 6px 16px;
            border-radius: 8px;
            border: 1px solid #cbd5f5;
            background: #ffffff;
            color: #1f2937;
            font-size: 16px;
            font-weight: 600;
            outline: none;
            appearance: none;
            margin: 0 8px 0 0;
            position: relative;
            background-image: linear-gradient(45deg, transparent 50%, #6b7280 50%), linear-gradient(135deg, #6b7280 50%, transparent 50%);
            background-position: calc(100% - 16px) 50%, calc(100% - 9px) 50%;
            background-size: 7px 7px, 7px 7px;
            background-repeat: no-repeat;
        }
        
        .history-filter:focus {
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }
        
        .collapse-toggle {
            position: absolute;
            left: 2px;
            top: 12px;
            background: #4f46e5;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s ease;
            z-index: 100;
            padding: 0;
        }
        
        .collapse-toggle:hover {
            background: #4338ca;
            transform: scale(1.1);
        }
        
        .collapse-toggle-bottom {
            top: auto;
            bottom: 8px;
        }
        
        .history-header {
            position: relative;
        }
        
        .history-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: #e2e8f0;
            border-bottom: 1px solid #d1d5db;
            flex-shrink: 0;
        }
        
        .nav-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: white !important;
            cursor: pointer;
            font-size: 0;
            color: black;
            transition: all 0.2s;
            position: relative;
            padding: 0;
        }
        
        .nav-btn::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .nav-btn#navUp::before {
            border-bottom: 12px solid black;
            border-top: none;
        }
        
        .nav-btn#navDown::before {
            border-top: 12px solid black;
            border-bottom: none;
        }
        
        .nav-btn:hover {
            background: #f3f4f6;
        }
        
        .nav-btn:hover::before {
            opacity: 0.7;
        }
        
        .nav-btn:disabled {
            background: #d1d5db;
            color: #9ca3af;
            cursor: not-allowed;
        }
        
        .nav-btn:disabled::before {
            opacity: 0.4;
        }
        
        .history-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px;
            min-height: 0;
        }
        
        .history-item {
            padding: 10px;
            margin-bottom: 6px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            border: 2px solid transparent;
            position: relative;
        }
        
        .history-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 18px rgba(15, 23, 42, 0.15);
        }
        
        .history-item.active {
            box-shadow: 0 10px 24px rgba(15, 23, 42, 0.25);
        }
        
        .history-item-collection {
            display: inline-flex;
            align-items: center;
            padding: 2px 10px;
            border-radius: 999px;
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 6px;
        }
        
        .history-item-title {
            margin-bottom: 6px;
        }
        
        .history-item-date {
            font-weight: bold;
            font-size: 16px;
            border: none;
            background: transparent;
            outline: none;
            width: 100%;
            padding: 0;
            margin: 0;
            color: inherit;
        }
        
        .history-item.active .history-item-date {
            background: rgba(255, 255, 255, 0.35);
            border-radius: 6px;
            padding: 2px 6px;
            cursor: text;
            transition: background 0.15s ease, box-shadow 0.15s ease;
        }
        
        .history-item.active .history-item-date:hover,
        .history-item.active .history-item-date:focus {
            background: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.25);
        }
        
        .history-item .history-item-date[readonly] {
            cursor: default;
            opacity: 0.95;
        }
        
        .history-item-meta {
            display: flex;
            justify-content: space-between;
            font-size: 16px;
            opacity: 0.85;
            gap: 10px;
        }
        
        .history-item-time,
        .history-item-parts {
            white-space: nowrap;
        }
        
        .history-item-delete {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: none;
            background: #ef4444;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            line-height: 1;
        }
        
        .history-item:hover .history-item-delete {
            opacity: 1;
        }
        
        .history-item-delete:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        .nav-btn-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Samling Manager Overlay (from map manager) */
        .samling-manager-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 5000;
        }
        
        .samling-manager-overlay.show {
            display: flex;
        }
        
        .samling-manager-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.45);
            backdrop-filter: blur(4px);
        }
        
        .samling-manager-panel {
            position: relative;
            width: min(520px, 90vw);
            max-height: 80vh;
            background: #ffffff;
            border-radius: 18px;
            box-shadow: 0 25px 60px rgba(15, 23, 42, 0.25);
            padding: 24px 28px;
            display: flex;
            flex-direction: column;
            gap: 18px;
            z-index: 1;
        }
        
        .samling-manager-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        
        .samling-manager-header h2 {
            font-size: 1.25rem;
            color: #111827;
        }
        
        .samling-manager-close {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 10px;
            background: #e2e8f0;
            color: #1f2937;
            font-size: 18px;
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s ease;
        }
        
        .samling-manager-close:hover {
            background: #cbd5f5;
            transform: scale(1.05);
        }
        
        .samling-manager-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            padding-right: 6px;
        }
        
        .samling-manager-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
        }
        
        .samling-name-btn {
            flex: 1;
            border: none;
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 16px;
            font-weight: 600;
            text-align: left;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            color: #1f2937;
        }
        
        .samling-name-input {
            flex: 1;
            border-radius: 10px;
            border: 1px solid #cbd5f5;
            padding: 10px 14px;
            font-size: 16px;
            font-weight: 600;
            transition: box-shadow 0.2s ease;
            color: #1f2937;
            background: #f8fafc;
        }
        
        .samling-name-input:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.18);
        }
        
        .samling-name-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 18px rgba(15, 23, 42, 0.18);
        }
        
        .samling-item-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .samling-action-btn {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            border: none;
            color: #ffffff;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .samling-action-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(15, 23, 42, 0.18);
        }
        
        .samling-action-btn.delete {
            background: linear-gradient(135deg, #f87171 0%, #ef4444 100%);
        }
        
        .samling-action-btn.color {
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
        }
        
        .samling-manager-divider {
            height: 1px;
            background: #e2e8f0;
            margin: 4px 0;
        }
        
        .samling-manager-new {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
        }
        
        .samling-manager-new input {
            flex: 1;
            border: none;
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 16px;
            font-weight: 600;
            color: #1f2937;
            background: #f8fafc;
            box-shadow: 0 0 0 1px rgba(99, 102, 241, 0.18);
            transition: box-shadow 0.2s ease, transform 0.2s ease;
        }
        
        .samling-manager-new input:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.18);
            transform: translateY(-1px);
        }
        
        .samling-manager-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .samling-color-select {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            color: #ffffff;
        }
        
        .samling-color-select:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(99, 102, 241, 0.25);
        }
        
        .samling-color-select span[aria-hidden="true"] {
            color: inherit;
            font-weight: 700;
            font-size: 16px;
        }
        
        .samling-manager-new .samling-create-btn {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
            color: white;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .samling-manager-new .samling-create-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.25);
        }
        
        .samling-color-picker-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(15, 23, 42, 0.35);
            z-index: 5001;
        }
        
        .samling-color-picker-modal.show {
            display: flex;
        }
        
        .samling-color-picker {
            width: calc(32px * 6 + 8px * 5 + 16px * 2);
            background: #ffffff;
            border-radius: 14px;
            padding: 16px;
            box-shadow: 0 18px 45px rgba(15, 23, 42, 0.25);
            border: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .samling-color-grid {
            display: grid;
            grid-template-columns: repeat(6, 32px);
            gap: 8px;
            justify-content: center;
        }
        
        .samling-color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 1px solid rgba(15, 23, 42, 0.08);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .samling-color-swatch:hover {
            transform: scale(1.08);
            box-shadow: 0 6px 14px rgba(15, 23, 42, 0.2);
        }
        
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        .background-labels {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: auto;
        }
        
        .label-input {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 14px;
            font-weight: 500;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 80px;
            transform: translate(-50%, -50%);
        }
        
        .label-input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3);
        }
        
        .part {
			position: absolute;
			width: 80px;
			height: 80px;
			cursor: move;
                transition: transform 0.44s ease-in-out, filter 0.44s ease-in-out;
			user-select: none;
                -webkit-user-select: none;
			touch-action: none;
			z-index: 10;
			will-change: transform;
			backface-visibility: hidden;
		}

        body.loading-opstilling .part {
            transition: none !important;
            filter: none !important;
            animation: none !important;
        }

        .suppress-transitions,
        .suppress-transitions * {
            transition: none !important;
            animation: none !important;
        }

        .suppress-transitions {
            opacity: 0;
        }

/* Disable transitions while dragging to avoid lag/hitches */
.part.dragging {
    transition: none !important;
}

.part:hover {
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.25)) brightness(1.0);
    z-index: 100;
}

			.part.dragging {
                transition: filter 0.44s ease-in-out;
				filter: drop-shadow(0 4px 8px rgba(0,0,0,0.25)) brightness(1.0);
				z-index: 1000;
			}

/* selection styling removed */
        
			/* Global body toggle - skjul kun torso, arme og ben */
			.hide-bodies .torso,
			.hide-bodies .skulder_translate_left,
			.hide-bodies .skulder_translate_right,
			.hide-bodies .hofte_translate_left,
			.hide-bodies .hofte_translate_right {
				display: none !important;
			}
		
		.head {
			position: absolute;
			top: -74px; left: 50%; transform: translateX(-50%);
			width:72px;
			height: 72px;
			border-radius: 50%;
			background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
			display: flex;
			align-items: center;
			justify-content: center;
			color: white;
			font-weight: bold;
			font-size: 12px;
			text-align: center;
			box-shadow: 0 8px 25px rgba(0,0,0,0.15);
			
			padding: 10px;
			line-height: 1.2;
			z-index: 5;
		}
		
			.head {
		pointer-events: auto;
		}

		.part-name {
			pointer-events: auto;
			font-size: 12px;
			display: inline-block;
			min-width: 20px;
			min-height: 16px;
			padding: 2px 4px;
			word-break: break-word;
			overflow-wrap: break-word;
			hyphens: auto;
		}
				
        /* Krop (underkomponent af part) */
        .body {
            position: absolute;
            top: 77px;
            left: 50%;
            transform: translateX(-50%);
            transform-origin: 40px -77px;
            transition: transform 0.2s ease-out;
            z-index: -1;
            pointer-events: none;
            will-change: transform;
            backface-visibility: hidden;
        }
        
        /* Disable transitions during drag to avoid conflicts */
        .part.dragging .body {
            transition: none;
        }
        
        /* Also disable transitions when settling back to neutral */
        .body {
            transition: none !important;
        }
        
        
        /* Torso */
        .torso {
            width: 60px;
            height: 80px;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            margin: 0 auto;
            border-radius: 30px 30px 20px 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            position: relative;
            z-index: 5;
        }
        
       /* Højre arm hierarki */
		.skulder_translate_right {
			position: absolute;
			top: 2px;
			left: 41px;
			width: 15px;
			height: 15px;
			background: rgba(59, 130, 246, 0.0);
			z-index: 3;
		}

		.skulder_translate_right.front-arm {
			z-index: 15;
		}

		.skulder_rotate_right {
			width: 100%;
			height: 100%;
			background: rgba(239, 68, 68, 0.0);
			transform-origin: center center;
		}

		.arm_geo_right {
			width: 50px;
			height: 18px;
			background: #f59e0b;
			border-radius: 9px;
			position: relative;
			top: -1px;
			left: -1px;
		}

		.albue_rotate_right {
			position: relative;
			top: 1px;
			left: 34px;
			width: 15px;
			height: 15px;
			background: rgba(16, 185, 129, 0.0);
			transform-origin: center center;
		}

		.albue_geo_right {
			position: relative;
			top: -1px;
			left: 1px;
			width: 50px;
			height: 18px;
			background: #f59e0b;
			border-radius: 9px;
			z-index: 4;
		}

		.albue_geo_right.front {
			z-index: 20 !important;
			position: relative;
		}

		/* Venstre arm hierarki */
		.skulder_translate_left {
			position: absolute;
			top: 2px;
			left: 4px;
			width: 15px;
			height: 15px;
			background: rgba(59, 130, 246, 0.0);
			z-index: 3;
		}

		.skulder_translate_left.front-arm {
			z-index: 15;
		}

		.skulder_rotate_left {
			width: 100%;
			height: 100%;
			background: rgba(239, 68, 68, 0.0);
			transform-origin: center center;
		}

		.arm_geo_left {
			width: 50px;
			height: 18px;
			background: #f59e0b;
			border-radius: 9px;
			position: relative;
			top: -1px;
			left: -34px;
		}

		.albue_rotate_left {
			position: relative;
			top: 1px;
			left: 0px;
			width: 15px;
			height: 15px;
			background: rgba(16, 185, 129, 0.0);
			transform-origin: center center;
		}

		.albue_geo_left {
			position: relative;
			top: -1px;
			left: -33px;
			width: 50px;
			height: 18px;
			background: #f59e0b;
			border-radius: 9px;
			z-index: 4;
		}

		.albue_geo_left.front {
			z-index: 20 !important;
			position: relative;
		}

		/* Højre ben hierarki */
		.hofte_translate_right {
			position: absolute;
			top: 68px;
			left: 40px;
			width: 15px;
			height: 15px;
			background: rgba(59, 130, 246, 0.0);
		}

		.hofte_rotate_right {
			width: 100%;
			height: 100%;
			background: rgba(239, 68, 68, 0.0);
			transform-origin: center center;
		}

		.laar_geo_right {
			width: 18px;
			height: 55px;
			background: #f59e0b;
			border-radius: 9px;
			position: relative;
			top: -1px;
			left: -1px;
		}

		.knae_rotate_right {
			position: relative;
			top: 38px;
			left: 1px;
			width: 15px;
			height: 15px;
			background: rgba(16, 185, 129, 0.0);
			transform-origin: center center;
		}

		.skinneben_geo_right {
			position: relative;
			top: -1px;
			left: -1px;
			width: 18px;
			height: 50px;
			background: #f59e0b;
			border-radius: 9px;
		}

		/* Venstre ben hierarki */
		.hofte_translate_left {
			position: absolute;
			top: 68px;
			left: 4px;
			width: 15px;
			height: 15px;
			background: rgba(59, 130, 246, 0.0);
		}

		.hofte_rotate_left {
			width: 100%;
			height: 100%;
			background: rgba(239, 68, 68, 0.0);
			transform-origin: center center;
		}

		.laar_geo_left {
			width: 18px;
			height: 55px;
			background: #f59e0b;
			border-radius: 9px;
			position: relative;
			top: -1px;
			left: -1px;
		}

		.knae_rotate_left {
			position: relative;
			top: 38px;
			left: 1px;
			width: 15px;
			height: 15px;
			background: rgba(16, 185, 129, 0.0);
			transform-origin: center center;
		}

		.skinneben_geo_left {
			position: relative;
			top: -1px;
			left: -1px;
			width: 18px;
			height: 50px;
			background: #f59e0b;
			border-radius: 9px;
		}
		
		
		
		
        .part-keywords {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            color: #374151;
            font-size: 12px;
            text-align: center;
            font-weight: normal;
            line-height: 1.1;
            width: 100px;
            white-space: nowrap;
            z-index: 15;
        }
        
        .keywords-above {
            bottom: calc(50% + 15px);
        }
        
        .keywords-below {
            top: calc(50% + 15px);
        }
        
        .control-btn {
            position: absolute;
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            font-size: 14px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            z-index: 1000;
            color: white;
            padding: 0;
            margin: 0;
            top: 50%;
            left: 50%;
            transform-origin: center center;
            pointer-events: none;
        }

        .part:hover .control-btn {
            display: flex !important;
            pointer-events: auto;
        }

        /* On mobile (tap selection), show controls when selected too */
        /* selection-based control visibility removed */
        
        .delete-btn {
            transform: translate(18px, -52px);
            background: #ef4444;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
        }
        
        .layer-up {
            transform: translate(-52px, -52px);
            background: #4f46e5;
            box-shadow: 0 2px 8px rgba(79, 70, 229, 0.3);
        }
        
        .size-plus {
            transform: translate(-17px, -52px);
            background: #059669;
            box-shadow: 0 2px 8px rgba(5, 150, 105, 0.3);
        }
        
        .edit-btn {
            transform: translate(18px, -17px);
            background: #f59e0b;
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
        }
        
        .layer-down {
            transform: translate(-52px, 18px);
            background: #4f46e5;
            box-shadow: 0 2px 8px rgba(79, 70, 229, 0.3);
        }
        
        .size-minus {
            transform: translate(-17px, 18px);
            background: #059669;
            box-shadow: 0 2px 8px rgba(5, 150, 105, 0.3);
        }

        .color-btn {
            transform: translate(18px, 18px);
            background: #a855f7;
            box-shadow: 0 2px 8px rgba(168, 85, 247, 0.3);
        }
		
		.pose-btn {
			transform: translate(18px, -17px);
			background: #06b6d4;
			box-shadow: 0 2px 8px rgba(6, 182, 212, 0.3);
		}
		
		.note-btn {
			transform: translate(-52px, -17px);
			background: #f97316;
			box-shadow: 0 2px 8px rgba(249, 115, 22, 0.3);
		}


        
        .delete-btn:hover {
            transform: translate(18px, -52px) scale(1.1);
            background: #dc2626;
        }
        
        .layer-up:hover {
            transform: translate(-52px, -52px) scale(1.1);
            background: #3730a3;
        }
        
        .size-plus:hover {
            transform: translate(-17px, -52px) scale(1.1);
            background: #047857;
        }
        
        .edit-btn:hover {
            transform: translate(18px, -17px) scale(1.1);
            background: #b8650c;
        }
        
        .layer-down:hover {
            transform: translate(-52px, 18px) scale(1.1);
            background: #3730a3;
        }
        
        .size-minus:hover {
            transform: translate(-17px, 18px) scale(1.1);
            background: #047857;
        }

        .color-btn:hover {
            transform: translate(18px, 18px) scale(1.1);
            background: #9333ea;
        }
		
		.pose-btn:hover {
			transform: translate(18px, -17px) scale(1.1);
			background: #0891b2;
		}
		
		.note-btn:hover {
			transform: translate(-52px, -17px) scale(1.1);
			background: #ea580c;
		}
		
		/* Name Editor Overlay Styles */
		.note-overlay {
			position: fixed;
			background: rgba(255, 255, 255, 0.95);
			border-radius: 8px;
			padding: 8px;
			box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
			border: 3px solid rgba(226, 232, 240, 0.5);
			z-index: 10000;
			width: 105px;
			display: none;
		}
		
		.note-overlay.show {
			display: block;
		}
		
		.note-overlay textarea {
			width: 100%;
			height: auto;
			min-height: auto;
			max-height: 110px;
			padding: 6px 10px;
			border: 3px solid rgba(226, 232, 240, 0.8);
			border-radius: 6px;
			font-size: 16px;
			font-family: 'Arial', sans-serif;
			resize: none;
			box-sizing: border-box;
			background: rgba(255, 255, 255, 0.9);
			color: #374151;
			line-height: 1.4;
			overflow-y: auto;
			word-break: break-word;
			overflow-wrap: break-word;
			hyphens: auto;
		}
		
		.note-overlay textarea:focus {
			outline: none;
			border-color: #f97316;
			box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.1);
		}
				
        /* Color Picker Styles */
        .color-picker-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }
        
        .color-picker-modal.show {
            display: flex;
        }
        
        .picker {
            width: 224px;
            background: rgba(255, 255, 255, 0.6);
            padding: 0;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border: 1px solid rgba(226, 232, 240, 0.5);
            position: relative;
        }
        
        .picker-drag-bar {
            width: 100%;
            height: 32px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px 12px 0 0;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            border-bottom: 1px solid rgba(226, 232, 240, 0.5);
        }
        
        .picker-drag-bar::before {
            content: '';
            width: 40px;
            height: 4px;
            background: rgba(148, 163, 184, 0.5);
            border-radius: 2px;
        }
        
        .picker-content {
            padding: 10px;
            background: rgba(255, 255, 255, 0.5);
        }
        
        .swatch {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            border: 1px solid rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .swatch:hover {
            transform: scale(1.2);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 10;
        }
        
        .color-grid {
            display: grid;
            grid-template-columns: repeat(12, 15px);
            grid-template-rows: repeat(14, 15px);
            gap: 2px;
            background: transparent;
        }
        
        .swatch:focus {
            outline: 2px solid #4f46e5;
            outline-offset: 1px;
        }
		
		
		/* Pose Picker Styles */
		.pose-picker-modal {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: transparent;
			display: none;
			align-items: center;
			justify-content: center;
			z-index: 3000;
		}

		.pose-picker-modal.show {
			display: flex;
		}

		.pose-picker {
			width: 280px;
			background: transparent;
			padding: 15px;
			border-radius: 12px;
			box-shadow: none;
			border: none;
		}

		.pose-mirror-section {
			text-align: center;
			margin-bottom: 15px;
			padding-bottom: 10px;
			border-bottom: 1px solid rgba(226, 232, 240, 0.5);
		}

		.pose-mirror-label {
			display: inline-flex;
			align-items: center;
			justify-content: center;
			gap: 8px;
			font-size: 14px;
			font-weight: 500;
			color: #374151;
			cursor: move;
			background: white;
			padding: 8px 16px;
			border-radius: 8px;
			position: relative;
			user-select: none;
			-webkit-user-select: none;
			touch-action: none;
			pointer-events: auto;
		}
		
		.pose-mirror-label input[type="checkbox"] {
			cursor: pointer;
			pointer-events: auto;
		}
		
		.pose-mirror-label span {
			cursor: move;
			pointer-events: none;
		}

		.pose-mirror-label input[type="checkbox"] {
			width: 16px;
			height: 16px;
			transform: scale(1.2);
		}

		.pose-grid {
			display: grid;
			grid-template-columns: repeat(3, 1fr);
			gap: 8px;
		}

		.pose-button {
			padding: 8px 12px;
			border: 2px solid rgba(226, 232, 240, 0.5);
			border-radius: 8px;
			background: rgba(255, 255, 255, 0.6);
			color: #374151;
			font-size: 12px;
			font-weight: 500;
			cursor: pointer;
			transition: all 0.2s ease;
			text-align: center;
		}

		.pose-button:hover {
			border-color: #3b82f6;
			background: #f0f9ff;
			color: #1d4ed8;
		}

		.pose-button.active {
			border-color: #3b82f6;
			background: #3b82f6;
			color: white;
		}
		
		
		
        
        /* .instructions removed */
        
        /* .notes-title removed */
        
        .notes-section {
            background: #f8fafc;
            padding: 15px 20px 20px 20px;
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: 30px;
        }
        
        .notes-content {
            display: flex;
            gap: 30px;
            width: 100%;
        }
        
        .groups-section {
			flex: 0 0 250px;
			min-width: 250px;
            display: none !important;
		}
        
        .groups-section h4 {
            margin: 0 0 10px 0;
            color: #475569;
            font-size: 16px;
        }
        
        .group-input-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .group-input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            background: white;
        }
        
        .group-color-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: none;
            background: #ef4444;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
            flex-shrink: 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .group-color-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .keywords-section {
            flex: 0 0 auto;
            min-width: 150px;
            max-width: 200px;
            display: none !important;
        }
        
        .keywords-section h4 {
            margin: 0 0 10px 0;
            color: #475569;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .visibility-checkbox {
            margin-right: 8px;
            transform: scale(1.2);
        }
        
        .keyword-input {
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 8px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            background: white;
        }
        
        .group-dropdown {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            background: white;
            margin-bottom: 10px;
            display: none !important;
        }
        
        .group-input:focus, .keyword-input:focus, .group-dropdown:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        .notes-container {
            flex: 1;
            min-width: 300px;
        }
        
        .notes-container h4 {
            margin: 0 0 10px 0;
            color: #475569;
            font-size: 16px;
        }
        
        .notes-section textarea {
            width: 100%;
            min-height: 256px;
            padding: 15px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 16px;
            font-family: inherit;
            background: white;
            resize: vertical;
        }
        
        .notes-section textarea:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        .notes-section p {
            margin: 10px 0 0 0;
            font-size: 14px;
            color: #6b7280;
        }
        
        .name-input {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #4f46e5;
            border-radius: 8px;
            padding: 4px 8px;
            font-size: inherit;
            font-weight: bold;
            text-align: center;
            color: #1f2937;
            width: 90%;
            max-width: 100px;
        }
        
        .name-input:focus {
            outline: none;
            border-color: #7c3aed;
            box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.3);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }
        
        .part {
            animation: fadeIn 0.5s ease-out;
        }
		
		/* Keywords Popup Modal */
.keywords-popup-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: transparent;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 3000;
}

.keywords-popup-modal.show {
    display: flex;
}

.keywords-popup {
    width: 400px;
    background: #ffffff;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    border: 1px solid #e2e8f0;
}

.keywords-popup h3 {
    margin: 0 0 15px 0;
    color: #374151;
    font-size: 18px;
}

.keywords-popup-input {
    width: 100%;
    padding: 8px 12px;
    margin-bottom: 10px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 14px;
    font-family: inherit;
    background: white;
}

.keywords-popup-input:focus {
    outline: none;
    border-color: #4f46e5;
    box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
}

.keywords-popup-button {
    width: 100%;
    padding: 12px;
    background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    margin-top: 10px;
}

.keywords-popup-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(79, 70, 229, 0.3);
}




		
		
		
    	/* Mobile adjustments */
	@media (hover: none) and (pointer: coarse) {
		body {
			padding: 5px;
		}
		.container {
			border-radius: 12px;
		}
    		.header {
			padding: 5px;
    		}
		.header h1 {
			font-size: 2.0em;
			margin-bottom: 0;
		}
		.toolbar {
			padding: 8px 12px;
			gap: 10px;
		}
		.toolbar select, .toolbar input, .toolbar button:not(.nav-button) {
			padding: 6px 10px;
			font-size: 13px;
			border-radius: 8px;
			min-width: auto;
		}
		.workspace {
			height: 65vh;
			max-height: 65vh;
			min-height: 65vh;
			width: 100%;
			max-width: 100%;
			min-width: 0;
			overflow: auto;
			-webkit-overflow-scrolling: touch;
			touch-action: pan-x pan-y;
			box-sizing: border-box;
		}
		/* .notes-title h3 removed */
		.groups-section h4, .keywords-section h4, .notes-container h4 { font-size: 14px; }
		.keyword-input, .group-input, .group-dropdown { font-size: 13px; }
		/* Make notes section horizontally scrollable on touch */
		.notes-section {
			overflow-x: auto;
			-webkit-overflow-scrolling: touch;
		}
		.notes-content {
			min-width: 900px; /* ensure content wider than viewport so it can scroll */
			gap: 20px;
		}
		.groups-section, .keywords-section, .notes-container {
			flex: 0 0 auto; /* prevent shrinking so horizontal scroll works */
		}
    	}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="nav-controls">
                <button class="nav-toggle-btn" onclick="toggleNavBox()" title="Navigation">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <div class="nav-box" id="navBox">
                    <a href="opstilling_01.html" class="nav-button">Opstilling</a>
                    <a href="dialog_01.html" class="nav-button">Dialog</a>
                    <a href="compare_01.html" class="nav-button">Ligheder</a>
                    <a href="bodymap_01.html" class="nav-button">BodyMap</a>
                    <a href="logbog_01.html" class="nav-button">Logbog</a>
                    <a href="checkin.html" class="nav-button nav-checkin">Check in</a>
                </div>
            </div>
            <h1>Opstilling</h1>
        </div>
        
        <div class="toolbar">
            <select id="themeSelect" onchange="changeTheme()" style="display:none;">
				<option value="">Vælg tema...</option>
				<option value="ifs_default">IFS Standard</option>
				<option value="Skygge">Skyggearbejde</option>
			</select>
			
			
            <select id="backgroundSelect" onchange="changeBackground()" style="display:none;">
                <option value="none">Ingen baggrund</option>
                <option value="har_onsker">Har/Ønsker</option>
                <option value="xy_axes">X/Y Akser</option>
                <option value="timeline">Tidslinje</option>
                <option value="for_imod">For/Imod</option>
                <option value="drama_trekant">Drama Trekant</option>
				<option value="mandala">Mandala Cirkel</option>
            </select>
            <button onclick="openSamlingManager()" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important; color: white !important;">Ny Samling</button>
            <button onclick="createNewSetup()">Ny Opstilling</button>
            <input type="text" id="partName" placeholder="Navn på del (f.eks. Beskytteren, Den Kritiske, Det Sårede Barn...)" maxlength="30">
            <button onclick="addPart()">Ny Deltager</button>
            <button onclick="saveSetup()" class="save-btn">Gem Opstilling</button>
            <button onclick="loadSetup()" class="load-btn">Indlæs Opstilling</button>
            <button onclick="exportAsImage()" class="export-btn">Gem Billede</button>
            <label style="display: flex; align-items: center; gap: 5px; font-size: 14px; color: #475569; cursor: pointer;">
                <input type="checkbox" id="transparentBackground" style="width: 16px; height: 16px; cursor: pointer;">
                Trans
            </label>
            <button onclick="clearAll()" class="clear-btn">Ryd Alt</button>
            <div class="toolbar-separator"></div>
        </div>
        
        <div class="main-content">
            <div class="workspace-container">
                <div class="workspace" id="workspace">
                    <div class="workspace-content"></div>
                </div>
                
                <div class="history-sidebar" id="historySidebar">
                    <div class="history-header">
                        <button class="collapse-toggle" onclick="toggleHistorySidebar()" title="Kollaps/udvid historie">></button>
                        <select id="historyFilter" class="history-filter" onchange="setHistoryFilter(this.value)"></select>
                    </div>
                    <div class="history-content">
                        <div class="history-navigation">
                            <div class="nav-btn-group">
                                <button class="nav-btn" id="navUp" onclick="navigateHistory(-1)" title="Gå ned"></button>
                                <button class="nav-btn" id="navDown" onclick="navigateHistory(1)" title="Gå op"></button>
                            </div>
                        </div>
                        <div class="history-list" id="historyList"></div>
                    </div>
                    <button class="collapse-toggle collapse-toggle-bottom" onclick="toggleHistorySidebar()" title="Kollaps/udvid historie">></button>
                </div>
                
                <!-- notes-title removed -->
                
                <div class="notes-section">
                    <div class="notes-content">
                        <div class="notes-container">
                            <h4 id="notesContainerTitle">Noter</h4>

					
                            <textarea id="partNotes" placeholder="Generelle noter for opstillingen"></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
    </div>

    <!-- Color Picker Modal -->
    <div class="color-picker-modal" id="colorPickerModal">
        <div class="picker">
            <div class="picker-drag-bar"></div>
            <div class="picker-content">
                <div class="color-grid" id="colorGrid"></div>
            </div>
        </div>
    </div>
	
	<!-- Pose Picker Modal -->
	<div class="pose-picker-modal" id="posePickerModal">
		<div class="pose-picker">
			<div class="pose-mirror-section">
				<label class="pose-mirror-label">
					<input type="checkbox" id="posePickerMirror" onchange="togglePosePickerMirror()">
					<span>Spejl</span>
				</label>
			</div>
			<div class="pose-grid" id="poseGrid"></div>
		</div>
	</div>
	
	<!-- Note Overlay -->
	<div class="note-overlay" id="noteOverlay">
		<textarea id="noteTextarea" placeholder="Navn..." maxlength="24"></textarea>
	</div>
	
	<!-- Keywords Popup Modal -->
	<div class="keywords-popup-modal" id="keywordsPopupModal">
		<div class="keywords-popup">
			<h3>Stikord for <span id="keywordsPopupName"></span></h3>
			<input type="text" class="keywords-popup-input" id="popupKeyword1" placeholder="Alder" maxlength="70">
			<input type="text" class="keywords-popup-input" id="popupKeyword2" placeholder="Relation" maxlength="70">
			<input type="text" class="keywords-popup-input" id="popupKeyword3" placeholder="Køn" maxlength="70">
			<input type="text" class="keywords-popup-input" id="popupKeyword4" placeholder="Stikord 4" maxlength="70">
			<input type="text" class="keywords-popup-input" id="popupKeyword5" placeholder="Stikord 5" maxlength="70">
			<input type="text" class="keywords-popup-input" id="popupKeyword6" placeholder="Stikord 6" maxlength="70">
			<button class="keywords-popup-button" onclick="closeKeywordsPopup()">Senere</button>
		</div>
	</div>
	
	<!-- Samling Manager Overlay -->
	<div class="samling-manager-overlay" id="samlingManagerOverlay">
		<div class="samling-manager-backdrop" onclick="closeSamlingManager()"></div>
		<div class="samling-manager-panel">
			<div class="samling-manager-header">
				<h2>Samlinger</h2>
				<button class="samling-manager-close" onclick="closeSamlingManager()" title="Luk">×</button>
			</div>
			<div class="samling-manager-list" id="samlingManagerList"></div>
			<div class="samling-manager-divider"></div>
			<div class="samling-manager-new" id="samlingManagerNewRow">
				<input type="text" id="newSamlingName" placeholder="Ny samling-navn" autocomplete="off">
				<div class="samling-manager-actions">
					<button class="samling-color-select" id="newSamlingColorBtn" onclick="openSamlingColorPicker({ type: 'new' })" title="Vælg farve">
						<span class="sr-only">Vælg farve</span>
						<span aria-hidden="true">C</span>
					</button>
					<button class="samling-create-btn" onclick="confirmCreateSamling()" title="Opret samling">✓</button>
				</div>
			</div>
		</div>
	</div>

	<!-- Samling Color Picker Modal -->
	<div class="samling-color-picker-modal" id="samlingColorPickerModal" onclick="backdropCloseSamlingHandler(event)">
		<div class="samling-color-picker" onclick="event.stopPropagation()">
			<div class="samling-color-picker-header">
				<h3>Vælg farve</h3>
			</div>
			<div class="samling-color-grid" id="samlingColorGrid"></div>
		</div>
	</div>
	
	
	
	

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCl6ZYtkfYx3kFF9329eGpeazsmJAPMKzA",
            authDomain: "relationer-fe5fe.firebaseapp.com",
            projectId: "relationer-fe5fe",
            storageBucket: "relationer-fe5fe.firebasestorage.app",
            messagingSenderId: "156720560629",
            appId: "1:156720560629:web:1a138e4e89f02a131f88bc",
            measurementId: "G-K5W7J8JHZG"
        };
        
        // Initialize Firebase
        let auth = null;
        let db = null;
        let currentUser = null;
        
        // Initialize Firebase immediately (before DOM is ready) for faster auth state detection
        try {
            firebase.initializeApp(firebaseConfig);
            auth = firebase.auth();
            db = firebase.firestore();
            
            // Enable Firestore offline persistence
            try {
                firebase.firestore().enablePersistence({
                    synchronizeTabs: true
                });
                console.log('Firestore offline persistence enabled');
            } catch (err) {
                if (err.code === 'failed-precondition') {
                    console.warn('Persistence can only be enabled in one tab at a time');
                } else if (err.code === 'unimplemented') {
                    console.warn('Browser doesn\'t support persistence');
                } else {
                    console.error('Error enabling Firestore persistence:', err);
                }
            }
        } catch (error) {
            console.error('Firebase initialization error:', error);
        }
        
        // Check auth state - this should run before DOMContentLoaded loads data
        let authStateReady = false;
        let authStateResolver = null;
        const authStatePromise = new Promise(resolve => {
            authStateResolver = resolve;
        });
        
        if (auth) {
            // Set up auth state listener immediately - Firebase usually resolves auth state very quickly
            auth.onAuthStateChanged(user => {
                currentUser = user;
                
                if (user) {
                    // Setup snapshot listener for real-time updates
                    setupOpstillingSnapshotListener();
                } else {
                    // Clean up listener when user logs out
                    if (opstillingSnapshotUnsubscribe) {
                        opstillingSnapshotUnsubscribe();
                        opstillingSnapshotUnsubscribe = null;
                    }
                    opstillingDataCache = undefined;
                }
                
                // Mark auth as ready and resolve promise immediately
                if (!authStateReady) {
                    authStateReady = true;
                    if (authStateResolver) {
                        authStateResolver();
                        authStateResolver = null;
                    }
                }
                
                // When user logs in, reload data from Firestore
                if (user) {
                    (async () => {
                        // IMPORTANT: Always reload, even if OpstillingData already exists, to ensure we get the correct source
                        const data = await loadOpstillingData();
                        
                        // Only update OpstillingData if we got data from Firestore
                        // If data is null, only create blank structure if we're sure there's no data (opstillingDataCache === null)
                        if (data !== null) {
                            OpstillingData = data;
                        } else if (opstillingDataCache === null) {
                            // Confirmed no data in Firestore - create default structure
                            OpstillingData = null;
                            await ensureDefaultOpstillingData();
                        }
                        // If opstillingDataCache is undefined, snapshot hasn't responded yet - don't create blank data
                        
                        // Always reload active setup to update workspace with positions and notes
                        const activeSetup = getActiveSetup();
                        if (activeSetup) {
                            await loadSetupFromOpstillingData(activeSetup);
                        } else {
                            await loadActiveOpstilling();
                        }
                        await renderHistory();
                    })();
                }
            });
        }
        
        // Multi-background system variables
        let currentBackground = 'none';
		const allBackgrounds = ['none', 'har_onsker', 'xy_axes', 'timeline', 'for_imod', 'drama_trekant', 'mandala'];        
        // Background functionality variables
        let currentGroupBtn = null;
        let backgroundLabels = {};
		let currentKeywordsPart = null;
        
        // Original functionality variables
        let partCounter = 0;
        let draggedElement = null;
        let offset = { x: 0, y: 0 };
        let selectedPart = null; // selection disabled; kept for compatibility but unused
        let colorIndex = 0;
		let generalNotes = '';
		
		// Simple drag animation variables
		let dragState = null;
        
        // Color picker variables
        let currentPart = null;

        let isLoadingSetup = false;
        let isInitialLoad = true; // Track if page is still doing initial load
        let isSavingToFirestore = false; // Track if we're currently saving to prevent snapshot loops
        
        // New persistent data model for Opstilling
        let OpstillingData = null; // { version, updated, activeCollectionId, activeSetupId, collections: [...] }
        
        // Firestore functions
        // Global cache for opstilling data
        // undefined = not yet loaded, null = confirmed no data, object = has data
        let opstillingDataCache = undefined;
        let opstillingSnapshotUnsubscribe = null;

        // Setup real-time listener for opstilling data from Firestore
        function setupOpstillingSnapshotListener() {
            // Clean up existing listener if any
            if (opstillingSnapshotUnsubscribe) {
                opstillingSnapshotUnsubscribe();
                opstillingSnapshotUnsubscribe = null;
            }
            
            if (!currentUser || !db) {
                opstillingDataCache = null;
                return;
            }
            
            try {
                const userDocRef = db.collection('users').doc(currentUser.uid);
                
                // Set up real-time listener
                opstillingSnapshotUnsubscribe = userDocRef.onSnapshot(
                    (doc) => {
                        if (!doc.exists || !doc.data()?.opstillingData) {
                            opstillingDataCache = null;
                            return;
                        }
                        
                        const newData = doc.data().opstillingData;
                        
                        // CRITICAL: Deduplicate snapshot data before using it
                        // Create a copy to avoid mutating the original
                        const dataCopy = JSON.parse(JSON.stringify(newData));
                        OpstillingData = dataCopy;
                        const hadDuplicates = deduplicateOpstillingData();
                        if (hadDuplicates) {
                            console.error('[SNAPSHOT] Received data with duplicates from Firestore!');
                            opstillingDataCache = OpstillingData; // Update cache with cleaned data
                            // Don't save back - might create loop
                        } else {
                            opstillingDataCache = newData;
                        }
                        
                        // CRITICAL: Don't reload during saves or loads
                        if (isSavingToFirestore || isLoadingSetup || isInitialLoad) {
                            console.log('[SNAPSHOT] Ignored: operation in progress');
                            return;
                        }
                        
                        // Check if actually changed (deep comparison of parts)
                        const currentSetup = getActiveSetup();
                        const newSetup = OpstillingData.collections
                            ?.find(c => c.id === OpstillingData?.activeCollectionId)
                            ?.setups?.find(s => s.id === OpstillingData?.activeSetupId);
                        
                        const currentParts = currentSetup?.parts?.length || 0;
                        const newParts = newSetup?.parts?.length || 0;
                        
                        // Only reload if significant change
                        if (Math.abs(currentParts - newParts) > 0 || 
                            JSON.stringify(currentSetup?.parts) !== JSON.stringify(newSetup?.parts)) {
                            console.log('[SNAPSHOT] Reloading:', currentParts, '→', newParts, 'parts');
                            
                            const activeSetup = getActiveSetup();
                            if (activeSetup) {
                                loadSetupFromOpstillingData(activeSetup);
                            }
                            renderHistory();
                        }
                    },
                    (error) => {
                        console.error('Snapshot error:', error);
                    }
                );
            } catch (error) {
                console.error('Error setting up opstilling snapshot listener:', error);
                opstillingDataCache = null;
            }
        }

        async function loadOpstillingDataFromFirestore() {
            // Return cached data from snapshot listener
            // undefined means not loaded yet, null means confirmed no data
            return opstillingDataCache === undefined ? null : opstillingDataCache;
        }
        
        // Check if there's any opstilling data in Firestore (for verification before overwriting)
        // First checks cache (faster and more reliable), then Firestore if cache is not available
        async function checkOpstillingDataExistsInFirestore() {
            // First check cache - it should have the latest data from snapshot listener
            if (opstillingDataCache && typeof opstillingDataCache === 'object') {
                const opstillingData = opstillingDataCache;
                
                // Check if there are any collections with setups that have parts
                if (Array.isArray(opstillingData.collections) && opstillingData.collections.length > 0) {
                    let totalParts = 0;
                    let totalSetups = 0;
                    opstillingData.collections.forEach(collection => {
                        if (Array.isArray(collection.setups)) {
                            collection.setups.forEach(setup => {
                                totalSetups++;
                                if (Array.isArray(setup.parts)) {
                                    totalParts += setup.parts.length;
                                }
                            });
                        }
                    });
                    
                    console.log(`[FIRESTORE_CHECK] From cache: Found ${opstillingData.collections.length} collections, ${totalSetups} setups, ${totalParts} total parts`);
                    
                    return {
                        exists: true,
                        collectionsCount: opstillingData.collections.length,
                        setupsCount: totalSetups,
                        partsCount: totalParts,
                        data: opstillingData,
                        source: 'cache'
                    };
                }
            }
            
            // If cache is not available, check Firestore directly
            if (!currentUser || !db) {
                console.log('[FIRESTORE_CHECK] No user or db, cannot check Firestore');
                return false;
            }
            
            try {
                const userDocRef = db.collection('users').doc(currentUser.uid);
                const doc = await userDocRef.get();
                
                if (!doc.exists) {
                    console.log('[FIRESTORE_CHECK] User document does not exist');
                    return false;
                }
                
                const userData = doc.data();
                if (!userData || !userData.opstillingData) {
                    console.log('[FIRESTORE_CHECK] No opstillingData in user document');
                    return false;
                }
                
                const opstillingData = userData.opstillingData;
                
                // Check if there are any collections with setups that have parts
                if (!Array.isArray(opstillingData.collections) || opstillingData.collections.length === 0) {
                    console.log('[FIRESTORE_CHECK] No collections in opstillingData');
                    return false;
                }
                
                // Check if any setup has parts
                let totalParts = 0;
                let totalSetups = 0;
                opstillingData.collections.forEach(collection => {
                    if (Array.isArray(collection.setups)) {
                        collection.setups.forEach(setup => {
                            totalSetups++;
                            if (Array.isArray(setup.parts)) {
                                totalParts += setup.parts.length;
                            }
                        });
                    }
                });
                
                console.log(`[FIRESTORE_CHECK] From Firestore: Found ${opstillingData.collections.length} collections, ${totalSetups} setups, ${totalParts} total parts`);
                
                return {
                    exists: true,
                    collectionsCount: opstillingData.collections.length,
                    setupsCount: totalSetups,
                    partsCount: totalParts,
                    data: opstillingData,
                    source: 'firestore'
                };
            } catch (error) {
                console.error('[FIRESTORE_CHECK] Error checking Firestore:', error);
                return false;
            }
        }
        
        async function saveOpstillingDataToFirestore() {
            if (!currentUser || !db) return false;
            
            try {
                if (!OpstillingData) return false;
                OpstillingData.updated = new Date().toISOString();
                
                // Log what we're saving
                const activeSetup = getActiveSetup();
                const partsCount = activeSetup ? (Array.isArray(activeSetup.parts) ? activeSetup.parts.length : 0) : 0;
                const collectionsCount = Array.isArray(OpstillingData.collections) ? OpstillingData.collections.length : 0;
                const stackTrace = new Error().stack;
                console.log(`[FIRESTORE WRITE] Saving opstillingData to Firestore:`, {
                    timestamp: new Date().toISOString(),
                    partsCount: partsCount,
                    collectionsCount: collectionsCount,
                    activeCollectionId: OpstillingData.activeCollectionId,
                    activeSetupId: OpstillingData.activeSetupId,
                    isLoadingSetup: isLoadingSetup,
                    isSavingToFirestore: isSavingToFirestore,
                    stackTrace: stackTrace
                });
                
                // Set flag to prevent snapshot listener from reloading while we're saving
                isSavingToFirestore = true;
                
                const userDocRef = db.collection('users').doc(currentUser.uid);
                // Use set() instead of merge to ensure complete data is written
                await userDocRef.set({
                    opstillingData: OpstillingData,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
                
                console.log(`[FIRESTORE WRITE] Successfully saved to Firestore with ${partsCount} parts`);
                
                // Update cache immediately to prevent snapshot from overwriting with stale data
                opstillingDataCache = OpstillingData;
                
                // Clear flag after a longer delay to allow snapshot to process and prevent loops
                // This gives Firestore time to process the write and update the snapshot
                setTimeout(() => {
                    isSavingToFirestore = false;
                }, 2000);
                
                return true;
            } catch (error) {
                console.error('[FIRESTORE WRITE] Error saving opstillingData to Firestore:', error);
                isSavingToFirestore = false;
                return false;
            }
        }
        
        // Load from Firestore only
        async function loadOpstillingData() {
            if (!currentUser || !db) {
                console.error('[LOAD] User not logged in - cannot load data');
                return null;
            }
            
            // Ensure snapshot listener is set up
            if (!opstillingSnapshotUnsubscribe) {
                setupOpstillingSnapshotListener();
                // Wait for snapshot listener to get initial data from Firestore
                // Wait up to 2 seconds, checking every 100ms if data has arrived
                for (let i = 0; i < 20; i++) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    if (opstillingDataCache !== undefined) {
                        // Snapshot listener has responded (either with data or null)
                        break;
                    }
                }
            }
            
            const firestoreData = await loadOpstillingDataFromFirestore();
            if (firestoreData !== null) {
                // Deduplicate before returning
                OpstillingData = firestoreData;
                const hadDuplicates = deduplicateOpstillingData();
                if (hadDuplicates) {
                    console.warn('[LOAD] Found duplicates in loaded data, cleaning up...');
                    // Save cleaned data back to Firestore
                    await saveOpstillingDataToFirestore();
                }
                return OpstillingData;
            }
            
            return null;
        }
        
        // Save to Firestore only
        async function saveOpstillingDataToLocalStorage() {
            if (!currentUser || !db) {
                console.error('[SAVE] User not logged in - cannot save data');
                return false;
            }
            
            try {
                if (!OpstillingData) return false;
                OpstillingData.updated = new Date().toISOString();
                
                const success = await saveOpstillingDataToFirestore();
                return success;
            } catch (error) {
                console.error('[SAVE] Error saving to Firestore:', error);
                return false;
            }
        }
        
        async function ensureDefaultOpstillingData() {
            let dataWasCreated = false;
            
            if (!OpstillingData || !Array.isArray(OpstillingData.collections)) {
                OpstillingData = {
                    version: '1.0',
                    updated: new Date().toISOString(),
                    activeCollectionId: 1,
                    activeSetupId: 1,
                    collections: []
                };
                dataWasCreated = true;
            }
            if (!Array.isArray(OpstillingData.collections) || OpstillingData.collections.length === 0) {
                OpstillingData.collections = [{
                    id: 1,
                    name: 'Samling 1',
                    color: SAMLING_COLOR_PRESETS[0],
                    setups: []
                }];
                OpstillingData.activeCollectionId = 1;
                dataWasCreated = true;
            }
            // Ensure all collections have colors
            OpstillingData.collections.forEach((collection, idx) => {
                if (!collection.color) {
                    collection.color = SAMLING_COLOR_PRESETS[idx % SAMLING_COLOR_PRESETS.length];
                }
            });
            const collection = OpstillingData.collections.find(c => c.id === OpstillingData.activeCollectionId) || OpstillingData.collections[0];
            if (!collection.setups || collection.setups.length === 0) {
                const now = new Date().toISOString();
                const initialSetup = {
                    id: 1,
                    name: 'Opstilling 1',
                    notes: '',
                    parts: [],
                    timestamp: now,
                    updated: now
                };
                collection.setups = [initialSetup];
                OpstillingData.activeSetupId = 1;
                dataWasCreated = true;
            }
            // Ensure all setups have timestamps
            OpstillingData.collections.forEach(collection => {
                if (Array.isArray(collection.setups)) {
                    collection.setups.forEach(setup => {
                        if (!setup.timestamp) {
                            setup.timestamp = setup.updated || new Date().toISOString();
                        }
                        if (!setup.updated) {
                            setup.updated = setup.timestamp || new Date().toISOString();
                        }
                    });
                }
            });
            // Only save if we actually created new data structure
            // This prevents overwriting existing Firestore data with empty data on page load
            // BUT: Before saving, check if Firestore already has data - if so, don't overwrite
            if (dataWasCreated) {
                // Check if Firestore has data before saving empty defaults
                const firestoreCheck = await checkOpstillingDataExistsInFirestore();
                if (firestoreCheck && firestoreCheck.exists && (firestoreCheck.partsCount > 0 || firestoreCheck.setupsCount > 0)) {
                    console.log(`[ENSURE_DEFAULT] Firestore has data (${firestoreCheck.partsCount} parts, ${firestoreCheck.setupsCount} setups), not saving empty defaults`);
                    // Use Firestore data instead
                    OpstillingData = firestoreCheck.data;
                    return; // Don't save empty defaults
                }
                console.log('[ENSURE_DEFAULT] No data in Firestore, saving default structure');
                await saveOpstillingDataToLocalStorage();
            }
        }
        
        // Debounce timeout for saving parts to Firestore
        let partSaveDebounceTimeout = null;
        
        function getActiveCollection() {
            if (!OpstillingData || !Array.isArray(OpstillingData.collections)) return null;
            return OpstillingData.collections.find(c => c.id === OpstillingData.activeCollectionId) || OpstillingData.collections[0] || null;
        }
        
        function getActiveSetup() {
            const col = getActiveCollection();
            if (!col || !Array.isArray(col.setups)) return null;
            return col.setups.find(s => s.id === OpstillingData.activeSetupId) || col.setups[0] || null;
        }
        
        /**
         * Deduplicates collections and setups in OpstillingData in-place.
         * Returns true if any duplicates were found and removed.
         */
        function deduplicateOpstillingData() {
            if (!OpstillingData || !Array.isArray(OpstillingData.collections)) {
                return false;
            }
            
            let foundDuplicates = false;
            
            // Deduplicate collections by ID (keep first occurrence)
            const seenCollectionIds = new Map(); // Map<id, collection>
            const uniqueCollections = [];
            
            OpstillingData.collections.forEach(collection => {
                if (seenCollectionIds.has(collection.id)) {
                    console.warn('[DEDUPE] Removing duplicate collection ID:', collection.id, 
                                'Name:', collection.name, 
                                'Original:', seenCollectionIds.get(collection.id).name);
                    foundDuplicates = true;
                } else {
                    seenCollectionIds.set(collection.id, collection);
                    uniqueCollections.push(collection);
                }
            });
            
            OpstillingData.collections = uniqueCollections;
            
            // Deduplicate setups within each collection
            OpstillingData.collections.forEach(collection => {
                if (!Array.isArray(collection.setups)) return;
                
                const seenSetupIds = new Map(); // Map<id, setup>
                const uniqueSetups = [];
                
                collection.setups.forEach(setup => {
                    if (seenSetupIds.has(setup.id)) {
                        console.warn('[DEDUPE] Removing duplicate setup ID:', setup.id,
                                    'in collection:', collection.name,
                                    'Name:', setup.name,
                                    'Original:', seenSetupIds.get(setup.id).name);
                        foundDuplicates = true;
                    } else {
                        seenSetupIds.set(setup.id, setup);
                        uniqueSetups.push(setup);
                    }
                });
                
                collection.setups = uniqueSetups;
            });
            
            return foundDuplicates;
        }
        
        // Color presets for collections (from bodymap)
        const SAMLING_COLOR_PRESETS = [
            '#ef4444', '#f97316', '#fbbf24', '#10b981', '#14b8a6', '#0ea5e9',
            '#3b82f6', '#6366f1', '#a855f7', '#ec4899', '#f472b6', '#94a3b8'
        ];
        
        // Helper functions for colors (from bodymap)
        function hexToRgba(hex, alpha) {
            if (!hex) {
                return `rgba(232, 220, 198, ${alpha})`;
            }
            const normalized = hex.replace('#', '');
            if (normalized.length === 3) {
                const r = parseInt(normalized[0] + normalized[0], 16);
                const g = parseInt(normalized[1] + normalized[1], 16);
                const b = parseInt(normalized[2] + normalized[2], 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
            if (normalized.length === 6) {
                const r = parseInt(normalized.substring(0, 2), 16);
                const g = parseInt(normalized.substring(2, 4), 16);
                const b = parseInt(normalized.substring(4, 6), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
            return hex;
        }
        
        function lightenHex(hex, amount = 0.5) {
            if (!hex) return '#f2e7d2';
            const normalized = hex.replace('#', '');
            const expand = normalized.length === 3
                ? normalized.split('').map(ch => ch + ch).join('')
                : normalized.padEnd(6, '0');
            const r = parseInt(expand.substring(0, 2), 16);
            const g = parseInt(expand.substring(2, 4), 16);
            const b = parseInt(expand.substring(4, 6), 16);
            const clampAmount = Math.max(0, Math.min(1, amount));
            const newR = Math.round(r + (255 - r) * clampAmount);
            const newG = Math.round(g + (255 - g) * clampAmount);
            const newB = Math.round(b + (255 - b) * clampAmount);
            return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
        }
        
        function formatDkDate(dateStr) {
            // Convert ISO date to DD-MM-YYYY for display
            if (typeof dateStr === 'string' && /^\d{4}-\d{2}-\d{2}/.test(dateStr)) {
                const datePart = dateStr.split('T')[0];
                const [y, m, d] = datePart.split('-');
                return `${d}-${m}-${y}`;
            }
            return dateStr || '';
        }
        
        // History sidebar state
        let historyFilterCollectionId = 'all';
        let samlingManagerOverlayEl = null;
        let samlingManagerListEl = null;
        let newSamlingNameInputEl = null;
        let newSamlingColorBtnEl = null;
        let samlingColorPickerModalEl = null;
        let samlingColorGridEl = null;
        let samlingColorPickerTarget = null;
        let newSamlingDraftColor = SAMLING_COLOR_PRESETS[0];
        let newSamlingDraftName = '';
        let newSamlingColorDirty = false;
        
        function exportCurrentPartsToModel() {
            const parts = document.querySelectorAll('.part');
            const result = [];
            parts.forEach(part => {
                const name = part.querySelector('.part-name')?.textContent || '';
                const x = parseInt(part.style.left) || 0;
                const y = parseInt(part.style.top) || 0;
                const size = parseFloat(part.getAttribute('data-part-scale') || '1') || 1;
                const poseAttr = part.getAttribute('data-pose') || '';
                const pose = poseAttr; // keep raw pose id/name for now
                const flipped = part.getAttribute('data-mirror') === 'true';
                const layer = parseInt(part.getAttribute('data-layer') || '1') || 1;
                const colorIndexAttr = Number.parseInt(part.getAttribute('data-color-index'), 10);
                const fallbackColorIndex = Number.isNaN(colorIndexAttr) ? 0 : colorIndexAttr;
                const color = part.getAttribute('data-custom-color') || partColors[fallbackColorIndex] || '#f59e0b';
                result.push({ name, x, y, size, pose, flipped, layer, color });
            });
            return result;
        }
        
        function updateNotesTitle() {
            const titleEl = document.getElementById('notesContainerTitle');
            if (!titleEl) return;
            const activeSetup = getActiveSetup();
            const activeCollection = getActiveCollection();
            if (activeSetup && activeCollection) {
                const setupName = activeSetup.name || 'Opstilling';
                const collectionName = activeCollection.name || 'Samling';
                titleEl.textContent = `Noter til ${setupName} i ${collectionName}`;
            } else {
                titleEl.textContent = 'Noter';
            }
        }
        
        async function syncCurrentWorkspaceToActiveSetup() {
            // NEVER save during initial load
            if (isInitialLoad) {
                console.log('[SYNC] Blocked: initial load in progress');
                return;
            }
            
            // NEVER save if loading a setup
            if (isLoadingSetup) {
                console.log('[SYNC] Blocked: loading setup in progress');
                return;
            }
            
            if (!OpstillingData) {
                console.log('[SYNC] Skipping sync - OpstillingData is null');
                return;
            }
            const setup = getActiveSetup();
            if (!setup) {
                console.log('[SYNC] Skipping sync - no active setup');
                return;
            }
            
            // Check if parts are actually loaded in DOM before saving
            const partsInDOM = document.querySelectorAll('.part').length;
            const exportedParts = exportCurrentPartsToModel();
            
            // CRITICAL: Never save with 0 parts if we're in initial load or if setup has parts in data
            // This prevents overwriting existing data with empty data during page load/refresh
            const partsInData = Array.isArray(setup.parts) ? setup.parts.length : 0;
            
            // CRITICAL: Never save 0 parts if Firestore has >0 parts
            if (exportedParts.length === 0) {
                const firestoreCheck = await checkOpstillingDataExistsInFirestore();
                if (firestoreCheck && firestoreCheck.exists && firestoreCheck.partsCount > 0) {
                    console.error('[SYNC] BLOCKED: Refusing to overwrite', 
                                 firestoreCheck.partsCount, 'parts with empty data');
                    return;
                }
            }
            
            // If setup has parts in data but we have 0 in DOM, we're probably still loading
            // Don't overwrite with empty data
            if (partsInData > 0 && partsInDOM === 0 && exportedParts.length === 0) {
                console.log(`[SYNC] Skipping sync - setup has ${partsInData} parts in data but 0 in DOM (still loading)`);
                return;
            }
            
            setup.notes = generalNotes || '';
            setup.parts = exportedParts;
            const now = new Date().toISOString();
            setup.updated = now;
            if (!setup.timestamp) {
                setup.timestamp = now;
            }
            
            console.log(`[SYNC] Syncing workspace: ${exportedParts.length} parts, ${partsInDOM} parts in DOM, partsInData: ${partsInData}, isInitialLoad: ${isInitialLoad}`);
            
            // Force save - ensure it completes before returning
            const saved = await saveOpstillingDataToLocalStorage();
            if (!saved) {
                console.error('[SYNC] Failed to save opstilling data');
            }
        }
        
        async function createNewCollection() {
            if (!OpstillingData) {
                OpstillingData = {
                    version: '1.0',
                    updated: new Date().toISOString(),
                    activeCollectionId: null,
                    activeSetupId: null,
                    collections: []
                };
            }
            
            // Find highest collection ID
            let maxId = 0;
            if (Array.isArray(OpstillingData.collections)) {
                OpstillingData.collections.forEach(c => {
                    if (c.id > maxId) maxId = c.id;
                });
            }
            
            const newId = maxId + 1;
            const collectionName = prompt('Navn på ny samling:', `Samling ${newId}`);
            if (!collectionName || collectionName.trim() === '') return;
            
            // Save current workspace before switching
            await syncCurrentWorkspaceToActiveSetup();
            
            // Create new collection with default setup
            const newCollection = {
                id: newId,
                name: collectionName.trim(),
                setups: [{
                    id: 1,
                    name: 'Opstilling 1',
                    notes: '',
                    parts: []
                }]
            };
            
            if (!Array.isArray(OpstillingData.collections)) {
                OpstillingData.collections = [];
            }
            OpstillingData.collections.push(newCollection);
            OpstillingData.activeCollectionId = newId;
            OpstillingData.activeSetupId = 1;
            
            await saveOpstillingDataToLocalStorage();
            
            // Load the new empty setup
            await loadSetupFromOpstillingData(newCollection.setups[0]);
        }
        
        async function createNewSetup() {
            if (!OpstillingData) {
                await ensureDefaultOpstillingData();
            }
            
            let collection = getActiveCollection();
            if (!collection) {
                await ensureDefaultOpstillingData();
                collection = getActiveCollection();
                if (!collection) {
                    console.error('[CREATE_SETUP] No collection available after ensure');
                    return;
                }
            }
            
            // Find highest setup ID in CURRENT collection only
            let maxId = 0;
            if (Array.isArray(collection.setups)) {
                collection.setups.forEach(s => {
                    if (s.id > maxId) maxId = s.id;
                });
            }
            
            let newId = maxId + 1;
            
            // CRITICAL: Check if setup with this ID already exists
            const existingSetup = collection.setups?.find(s => s.id === newId);
            if (existingSetup) {
                console.error('[CREATE_SETUP] Duplicate setup ID detected!', newId, 
                             'in collection:', collection.name);
                // Force new ID
                const newIdRetry = maxId + 2;
                const retryCheck = collection.setups?.find(s => s.id === newIdRetry);
                if (retryCheck) {
                    console.error('[CREATE_SETUP] Even retry ID exists! Data corruption.');
                    alert('Fejl: Kunne ikke oprette opstilling (ID konflikt). Reload siden og prøv igen.');
                    return;
                }
                newId = newIdRetry;
            }
            
            const setupName = `Opstilling ${newId}`;
            
            // Save current workspace BEFORE switching
            await syncCurrentWorkspaceToActiveSetup();
            
            // Create new setup
            const now = new Date().toISOString();
            const newSetup = {
                id: newId,
                name: setupName,
                notes: '',
                parts: [],
                timestamp: now,
                updated: now
            };
            
            // Add to collection
            if (!Array.isArray(collection.setups)) {
                collection.setups = [];
            }
            collection.setups.push(newSetup);
            OpstillingData.activeSetupId = newId;
            
            console.log('[CREATE_SETUP] Created new setup:', newId, setupName,
                        'in collection:', collection.name,
                        'Total setups:', collection.setups.length);
            
            // Save ONCE to Firestore
            await saveOpstillingDataToLocalStorage();
            
            // Load the new empty setup
            await loadSetupFromOpstillingData(newSetup);
            updateNotesTitle();
            renderHistory();
            
            // Make the new history item's name editable and focus it
            requestAnimationFrame(() => {
                const newHistoryItem = document.querySelector(
                    `.history-item.active input[data-setup-id="${newId}"]`
                );
                if (newHistoryItem) {
                    newHistoryItem.readOnly = false;
                    newHistoryItem.focus();
                    newHistoryItem.select();
                }
            });
        }
        
        // ===== HISTORY SIDEBAR FUNCTIONS (from bodymap_01.html) =====
        
        function getAllSetupsSorted() {
            if (!OpstillingData || !Array.isArray(OpstillingData.collections)) return [];
            
            // CRITICAL: Deduplicate data first
            const hadDuplicates = deduplicateOpstillingData();
            if (hadDuplicates) {
                console.error('[HISTORY] Found duplicates in OpstillingData! This should not happen.');
                // Save cleaned data
                saveOpstillingDataToLocalStorage().catch(err => {
                    console.error('[HISTORY] Failed to save after deduplication:', err);
                });
            }
            
            const allSetups = [];
            
            OpstillingData.collections.forEach(collection => {
                if (Array.isArray(collection.setups)) {
                    collection.setups.forEach(setup => {
                        // No need for seenSetups check anymore - data is deduplicated
                        
                        // Ensure setup has timestamp
                        if (!setup.timestamp && setup.updated) {
                            setup.timestamp = setup.updated;
                        } else if (!setup.timestamp) {
                            setup.timestamp = new Date().toISOString();
                        }
                        
                        allSetups.push({
                            setup,
                            collection,
                            timestamp: new Date(setup.timestamp)
                        });
                    });
                }
            });
            
            // Sort by timestamp descending (newest first)
            allSetups.sort((a, b) => b.timestamp - a.timestamp);
            
            return allSetups;
        }
        
        function getFilteredSortedSetups() {
            const all = getAllSetupsSorted();
            if (historyFilterCollectionId === 'all') {
                return all;
            }
            const filterId = parseFloat(historyFilterCollectionId);
            return all.filter(entry => entry.collection && entry.collection.id === filterId);
        }
        
        function renderHistoryFilterOptions() {
            const filterEl = document.getElementById('historyFilter');
            if (!filterEl) return;
            
            const desiredValue = historyFilterCollectionId === 'all' ? 'all' : String(historyFilterCollectionId);
            const options = ['<option value="all">Vis alle</option>'];
            
            if (OpstillingData && Array.isArray(OpstillingData.collections)) {
                const sortedCollections = [...OpstillingData.collections].sort((a, b) => 
                    (a.name || '').localeCompare(b.name || '', 'da', { sensitivity: 'base' })
                );
                sortedCollections.forEach(collection => {
                    options.push(`<option value="${collection.id}">${collection.name || 'Samling'}</option>`);
                });
            }
            
            filterEl.innerHTML = options.join('');
            const allowedValues = ['all', ...(OpstillingData?.collections || []).map(c => String(c.id))];
            const nextValue = allowedValues.includes(desiredValue) ? desiredValue : 'all';
            filterEl.value = nextValue;
            historyFilterCollectionId = nextValue === 'all' ? 'all' : parseFloat(nextValue);
        }
        
        function setHistoryFilter(value) {
            historyFilterCollectionId = value === 'all' ? 'all' : parseFloat(value);
            renderHistory();
        }
        
        async function renderHistory() {
            const list = document.getElementById('historyList');
            if (!list) return;
            list.innerHTML = '';
            
            // Don't create default data in renderHistory - it should already exist
            // Only ensure it exists if we're in initial load
            if (!OpstillingData || !Array.isArray(OpstillingData.collections)) {
                if (isInitialLoad) {
                    await ensureDefaultOpstillingData();
                } else {
                    console.warn('[RENDER_HISTORY] OpstillingData is missing but not in initial load');
                    return;
                }
            }
            
            renderHistoryFilterOptions();
            
            const sortedEntries = getFilteredSortedSetups();
            const activeSetup = getActiveSetup();
            const activeCollection = getActiveCollection();
            
            sortedEntries.forEach(({ setup, collection }) => {
                const item = document.createElement('div');
                const isActive = setup.id === OpstillingData.activeSetupId && 
                                collection.id === OpstillingData.activeCollectionId;
                item.className = `history-item ${isActive ? 'active' : ''}`;
                
                const collectionColor = collection.color || SAMLING_COLOR_PRESETS[0];
                const collectionName = collection.name || 'Samling';
                
                const baseBackground = lightenHex(collectionColor, isActive ? 0.35 : 0.7);
                item.style.backgroundColor = baseBackground;
                item.style.color = '#1f2937';
                item.style.borderColor = isActive ? collectionColor : 'transparent';
                
                const collectionBadge = document.createElement('div');
                collectionBadge.className = 'history-item-collection';
                collectionBadge.textContent = collectionName;
                collectionBadge.style.backgroundColor = collectionColor;
                collectionBadge.style.color = '#ffffff';
                item.appendChild(collectionBadge);
                
                const titleDisplay = setup.name || 'Opstilling';
                const titleWrapper = document.createElement('div');
                titleWrapper.className = 'history-item-title';
                titleWrapper.innerHTML = `<input type="text" class="history-item-date" value="${titleDisplay}" data-collection-id="${collection.id}" data-setup-id="${setup.id}" title="Rediger titel">`;
                item.appendChild(titleWrapper);
                
                const metaWrapper = document.createElement('div');
                metaWrapper.className = 'history-item-meta';
                const timestamp = setup.timestamp || setup.updated || new Date().toISOString();
                const dateObj = new Date(timestamp);
                const dateDk = formatDkDate(dateObj.toISOString().split('T')[0]);
                const timeStr = dateObj.toTimeString().split(' ')[0].substring(0, 5);
                const partsCount = Array.isArray(setup.parts) ? setup.parts.length : 0;
                metaWrapper.innerHTML = `
                    <span class="history-item-time">${dateDk} ${timeStr}</span>
                    <span class="history-item-parts">Del: ${partsCount}</span>
                `;
                item.appendChild(metaWrapper);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'history-item-delete';
                deleteBtn.dataset.collectionId = collection.id;
                deleteBtn.dataset.setupId = setup.id;
                deleteBtn.textContent = '×';
                item.appendChild(deleteBtn);
                
                item.addEventListener('click', (e) => {
                    if (e.target.classList.contains('history-item-date') && isActive) return;
                    if (e.target.classList.contains('history-item-delete')) return;
                    if (!isActive) {
                        OpstillingData.activeCollectionId = collection.id;
                        OpstillingData.activeSetupId = setup.id;
                        (async () => {
                            await saveOpstillingDataToLocalStorage();
                            await loadSetupFromOpstillingData(setup);
                            updateNotesTitle();
                            await renderHistory();
                        })();
                    }
                });
                
                const titleInput = item.querySelector('.history-item-date');
                if (!isActive) {
                    titleInput.readOnly = true;
                    titleInput.tabIndex = -1;
                } else {
                    titleInput.readOnly = false;
                    titleInput.tabIndex = 0;
                }
                titleInput.addEventListener('focus', (e) => {
                    if (!isActive) {
                        e.preventDefault();
                        item.click();
                        return;
                    }
                });
                titleInput.addEventListener('change', (e) => {
                    const collectionId = parseFloat(e.target.dataset.collectionId);
                    const setupId = parseFloat(e.target.dataset.setupId);
                    const collection = OpstillingData.collections.find(c => c.id === collectionId);
                    if (collection) {
                        const setup = collection.setups.find(s => s.id === setupId);
                        if (setup) {
                            setup.name = e.target.value;
                            (async () => {
                                await saveOpstillingDataToLocalStorage();
                                await renderHistory();
                            })();
                        }
                    }
                });
                
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const collectionId = parseFloat(e.target.dataset.collectionId);
                    const setupId = parseFloat(e.target.dataset.setupId);
                    (async () => {
                        await deleteSetup(collectionId, setupId);
                    })();
                });
                
                list.appendChild(item);
            });
            
            const navUp = document.getElementById('navUp');
            const navDown = document.getElementById('navDown');
            const canNavigate = sortedEntries.length > 1;
            if (navUp) navUp.disabled = !canNavigate;
            if (navDown) navDown.disabled = !canNavigate;
        }
        
        async function navigateHistory(direction) {
            const sortedEntries = getFilteredSortedSetups();
            if (!sortedEntries.length) return;
            
            const activeSetup = getActiveSetup();
            const activeCollection = getActiveCollection();
            let currentPos = sortedEntries.findIndex(entry => 
                entry.setup.id === OpstillingData.activeSetupId && 
                entry.collection.id === OpstillingData.activeCollectionId
            );
            if (currentPos === -1) {
                currentPos = 0;
            }
            
            if (direction > 0) {
                if (currentPos < sortedEntries.length - 1) {
                    currentPos += 1;
                }
            } else {
                if (currentPos > 0) {
                    currentPos -= 1;
                }
            }
            
            const targetEntry = sortedEntries[currentPos];
            OpstillingData.activeCollectionId = targetEntry.collection.id;
            OpstillingData.activeSetupId = targetEntry.setup.id;
            await saveOpstillingDataToLocalStorage();
            await loadSetupFromOpstillingData(targetEntry.setup);
            updateNotesTitle();
            renderHistory();
        }
        
        function toggleHistorySidebar() {
            const sidebar = document.getElementById('historySidebar');
            const toggleBtns = sidebar.querySelectorAll('.collapse-toggle');
            if (!sidebar || !toggleBtns.length) return;
            
            sidebar.classList.toggle('collapsed');
            const isCollapsed = sidebar.classList.contains('collapsed');
            localStorage.setItem('opstilling_historySidebarCollapsed', isCollapsed);
            toggleBtns.forEach(btn => {
                btn.textContent = isCollapsed ? '<' : '>';
            });
        }
        
        async function deleteSetup(collectionId, setupId) {
            const collection = OpstillingData.collections.find(c => c.id === collectionId);
            if (!collection || !Array.isArray(collection.setups)) return;
            
            if (collection.setups.length <= 1) {
                alert('Du kan ikke slette den sidste opstilling i en samling. Slet samlingen i stedet.');
                return;
            }
            
            if (!confirm('Er du sikker på du vil slette denne opstilling?')) {
                return;
            }
            
            collection.setups = collection.setups.filter(s => s.id !== setupId);
            
            if (OpstillingData.activeSetupId === setupId && OpstillingData.activeCollectionId === collectionId) {
                if (collection.setups.length > 0) {
                    OpstillingData.activeSetupId = collection.setups[collection.setups.length - 1].id;
                } else {
                    // Find another collection with setups
                    const otherCollection = OpstillingData.collections.find(c => 
                        c.id !== collectionId && Array.isArray(c.setups) && c.setups.length > 0
                    );
                    if (otherCollection) {
                        OpstillingData.activeCollectionId = otherCollection.id;
                        OpstillingData.activeSetupId = otherCollection.setups[otherCollection.setups.length - 1].id;
                    }
                }
            }
            
            await saveOpstillingDataToLocalStorage();
            const activeSetup = getActiveSetup();
            if (activeSetup) {
                await loadSetupFromOpstillingData(activeSetup);
            }
            await renderHistory();
        }
        
        // ===== SAMLING MANAGER FUNCTIONS (from map manager) =====
        
        async function openSamlingManager() {
            if (!samlingManagerOverlayEl) {
                samlingManagerOverlayEl = document.getElementById('samlingManagerOverlay');
                samlingManagerListEl = document.getElementById('samlingManagerList');
                newSamlingNameInputEl = document.getElementById('newSamlingName');
                newSamlingColorBtnEl = document.getElementById('newSamlingColorBtn');
            }
            if (!samlingColorPickerModalEl) {
                samlingColorPickerModalEl = document.getElementById('samlingColorPickerModal');
            }
            if (!samlingColorGridEl) {
                samlingColorGridEl = document.getElementById('samlingColorGrid');
            }
            if (newSamlingNameInputEl) {
                newSamlingDraftName = newSamlingNameInputEl.value;
            }
            if (samlingColorGridEl && samlingColorGridEl.childElementCount === 0) {
                buildSamlingColorGrid();
            }
            if (!samlingManagerOverlayEl) return;
            
            // Always reload data (from Firestore or localStorage) to ensure we have the latest collections list
            const data = await loadOpstillingData();
            if (data) {
                OpstillingData = data;
            }
            await ensureDefaultOpstillingData();
            
            resetNewSamlingDraft();
            await renderSamlingManagerList();
            // Also update history to ensure collection names are displayed correctly
            await renderHistory();
            samlingManagerOverlayEl.classList.add('show');
            setTimeout(() => {
                if (newSamlingNameInputEl) {
                    newSamlingNameInputEl.focus();
                }
            }, 80);
        }
        
        function closeSamlingManager() {
            if (samlingManagerOverlayEl) {
                samlingManagerOverlayEl.classList.remove('show');
            }
            closeSamlingColorPicker();
        }
        
        function resetNewSamlingDraft() {
            newSamlingDraftColor = SAMLING_COLOR_PRESETS[0];
            newSamlingDraftName = '';
            newSamlingColorDirty = false;
            if (newSamlingNameInputEl) {
                newSamlingNameInputEl.value = '';
            }
            updateNewSamlingColorButton();
        }
        
        function updateNewSamlingColorButton() {
            if (!newSamlingColorBtnEl) return;
            if (newSamlingColorDirty) {
                const baseColor = newSamlingDraftColor || SAMLING_COLOR_PRESETS[0];
                newSamlingColorBtnEl.style.background = baseColor;
                newSamlingColorBtnEl.style.color = '#ffffff';
                if (newSamlingNameInputEl) {
                    newSamlingNameInputEl.style.background = lightenHex(baseColor, 0.85);
                    newSamlingNameInputEl.style.boxShadow = `0 0 0 2px ${hexToRgba(baseColor, 0.35)}`;
                }
            } else {
                const baseColor = SAMLING_COLOR_PRESETS[0] || '#ef4444';
                newSamlingColorBtnEl.style.background = baseColor;
                newSamlingColorBtnEl.style.color = '#ffffff';
                if (newSamlingNameInputEl) {
                    newSamlingNameInputEl.style.background = lightenHex(baseColor, 0.85);
                    newSamlingNameInputEl.style.boxShadow = `0 0 0 2px ${hexToRgba(baseColor, 0.35)}`;
                }
            }
        }
        
        async function renderSamlingManagerList() {
            if (!samlingManagerListEl) return;
            samlingManagerListEl.innerHTML = '';
            
            if (!OpstillingData || !Array.isArray(OpstillingData.collections)) {
                await ensureDefaultOpstillingData();
            }
            
            OpstillingData.collections.forEach(collection => {
                const item = document.createElement('div');
                item.className = 'samling-manager-item';
                
                const nameBtn = document.createElement('button');
                nameBtn.className = 'samling-name-btn';
                nameBtn.textContent = collection.name || 'Samling';
                const baseColor = collection.color || SAMLING_COLOR_PRESETS[0];
                nameBtn.style.background = lightenHex(baseColor, 0.7);
                nameBtn.style.border = `1px solid ${baseColor}`;
                nameBtn.addEventListener('click', () => beginSamlingNameInlineEdit(collection, nameBtn));
                
                const actions = document.createElement('div');
                actions.className = 'samling-item-actions';
                
                const colorBtn = document.createElement('button');
                colorBtn.className = 'samling-action-btn color';
                colorBtn.textContent = 'C';
                colorBtn.style.background = collection.color || SAMLING_COLOR_PRESETS[0];
                colorBtn.onclick = () => openSamlingColorPicker({ type: 'samling', collectionId: collection.id });
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'samling-action-btn delete';
                deleteBtn.textContent = '✕';
                deleteBtn.onclick = () => deleteSamling(collection.id);
                
                actions.appendChild(colorBtn);
                actions.appendChild(deleteBtn);
                
                item.appendChild(nameBtn);
                item.appendChild(actions);
                samlingManagerListEl.appendChild(item);
            });
            
            newSamlingNameInputEl = document.getElementById('newSamlingName');
            newSamlingColorBtnEl = document.getElementById('newSamlingColorBtn');
            if (newSamlingNameInputEl) {
                newSamlingNameInputEl.value = newSamlingDraftName;
                newSamlingNameInputEl.addEventListener('input', (e) => {
                    newSamlingDraftName = e.target.value;
                });
            }
            updateNewSamlingColorButton();
        }
        
        function beginSamlingNameInlineEdit(collection, buttonEl) {
            if (!collection || !buttonEl) return;
            const baseColor = collection.color || SAMLING_COLOR_PRESETS[0];
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'samling-name-input';
            input.value = collection.name || 'Samling';
            input.style.background = lightenHex(baseColor, 0.7);
            input.style.borderColor = baseColor;
            
            let finished = false;
            const commit = (shouldSave) => {
                if (finished) return;
                finished = true;
                const newName = input.value.trim();
                if (shouldSave && newName && newName !== collection.name) {
                    collection.name = newName;
                    renderHistoryFilterOptions();
                    (async () => {
                        await renderHistory();
                        await saveOpstillingDataToLocalStorage();
                        await renderSamlingManagerList();
                    })();
                } else {
                    renderSamlingManagerList();
                }
            };
            
            input.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    commit(true);
                } else if (event.key === 'Escape') {
                    commit(false);
                }
            });
            
            input.addEventListener('blur', () => commit(true));
            
            buttonEl.replaceWith(input);
            input.focus();
            input.select();
        }
        
        function openSamlingColorPicker(target) {
            if (!samlingColorPickerModalEl) {
                samlingColorPickerModalEl = document.getElementById('samlingColorPickerModal');
                samlingColorGridEl = document.getElementById('samlingColorGrid');
            }
            if (!samlingColorPickerModalEl || !samlingColorGridEl) return;
            samlingColorPickerTarget = target;
            samlingColorPickerModalEl.classList.add('show');
        }
        
        function closeSamlingColorPicker() {
            samlingColorPickerTarget = null;
            if (samlingColorPickerModalEl) {
                samlingColorPickerModalEl.classList.remove('show');
            }
        }
        
        function backdropCloseSamlingHandler(event) {
            if (event.target === samlingColorPickerModalEl) {
                closeSamlingColorPicker();
            }
        }
        
        function handleSamlingColorSelected(color) {
            if (!samlingColorPickerTarget) return;
            if (samlingColorPickerTarget.type === 'samling') {
                (async () => {
                    await applySamlingColor(samlingColorPickerTarget.collectionId, color);
                })();
            } else if (samlingColorPickerTarget.type === 'new') {
                newSamlingDraftColor = color;
                newSamlingColorDirty = true;
                updateNewSamlingColorButton();
            }
            closeSamlingColorPicker();
        }
        
        async function applySamlingColor(collectionId, color) {
            const collection = OpstillingData.collections.find(c => c.id === collectionId);
            if (!collection) return;
            collection.color = color;
            await renderHistory();
            await renderSamlingManagerList();
            renderHistoryFilterOptions();
            await saveOpstillingDataToLocalStorage();
        }
        
        async function confirmCreateSamling() {
            if (!newSamlingNameInputEl) return;
            const name = newSamlingNameInputEl.value.trim();
            if (!name) {
                newSamlingNameInputEl.focus();
                return;
            }
            const color = newSamlingDraftColor || SAMLING_COLOR_PRESETS[0];
            
            // Save current workspace before switching
            await syncCurrentWorkspaceToActiveSetup();
            
            // DON'T reload - work with existing OpstillingData
            await ensureDefaultOpstillingData();
            
            // CRITICAL: Check if collection with this name already exists
            const existingByName = OpstillingData.collections.find(
                c => c.name.toLowerCase().trim() === name.toLowerCase().trim()
            );
            if (existingByName) {
                alert(`En samling med navnet "${name}" eksisterer allerede!`);
                newSamlingNameInputEl.focus();
                newSamlingNameInputEl.select();
                return;
            }
            
            // Find highest collection ID
            let maxId = 0;
            OpstillingData.collections.forEach(c => {
                if (c.id > maxId) maxId = c.id;
            });
            let newId = maxId + 1;
            
            // CRITICAL: Check if collection with this ID already exists (shouldn't happen)
            const existingById = OpstillingData.collections.find(c => c.id === newId);
            if (existingById) {
                console.error('[CREATE_SAMLING] Duplicate ID detected!', newId, 'Forcing new ID');
                // Force new ID by adding 1 extra
                const newIdRetry = maxId + 2;
                const retryCheck = OpstillingData.collections.find(c => c.id === newIdRetry);
                if (retryCheck) {
                    console.error('[CREATE_SAMLING] Even retry ID exists! Data corruption possible.');
                    alert('Fejl: Kunne ikke oprette samling (ID konflikt). Reload siden og prøv igen.');
                    return;
                }
                // Use retry ID
                newId = newIdRetry;
            }
            
            const now = new Date().toISOString();
            const newCollection = {
                id: newId,
                name,
                color,
                setups: [{
                    id: 1,
                    name: 'Opstilling 1',
                    notes: '',
                    parts: [],
                    timestamp: now,
                    updated: now
                }]
            };
            
            // Add to collections
            OpstillingData.collections.push(newCollection);
            OpstillingData.activeCollectionId = newId;
            OpstillingData.activeSetupId = 1;
            
            console.log('[CREATE_SAMLING] Created new collection:', newId, name, 
                        'Total collections:', OpstillingData.collections.length);
            
            // Save ONCE to Firestore
            await saveOpstillingDataToLocalStorage();
            
            // Load the new empty setup
            await loadSetupFromOpstillingData(newCollection.setups[0]);
            
            // Update UI
            await renderHistory();
            await renderSamlingManagerList();
            
            // Reset and close
            if (newSamlingNameInputEl) {
                newSamlingNameInputEl.value = '';
            }
            resetNewSamlingDraft();
            closeSamlingManager();
        }
        
        async function deleteSamling(collectionId) {
            if (!OpstillingData || !Array.isArray(OpstillingData.collections)) return;
            
            // Prevent deleting the last remaining collection
            if (OpstillingData.collections.length <= 1) {
                alert('Du kan ikke slette den sidste samling.');
                return;
            }
            
            const collection = OpstillingData.collections.find(c => c.id === collectionId);
            if (!collection) return;
            
            if (!confirm(`Vil du slette alle opstillinger i "${collection.name}"?`)) {
                return;
            }
            
            closeSamlingColorPicker();
            OpstillingData.collections = OpstillingData.collections.filter(c => c.id !== collectionId);
            
            if (OpstillingData.activeCollectionId === collectionId) {
                OpstillingData.activeCollectionId = null;
            }
            
            // Find a new active collection and setup
            if (OpstillingData.collections.length > 0) {
                const fallbackCollection = OpstillingData.collections[OpstillingData.collections.length - 1];
                OpstillingData.activeCollectionId = fallbackCollection.id;
                if (Array.isArray(fallbackCollection.setups) && fallbackCollection.setups.length > 0) {
                    OpstillingData.activeSetupId = fallbackCollection.setups[fallbackCollection.setups.length - 1].id;
                } else {
                    // Create default setup
                    fallbackCollection.setups = [{
                        id: 1,
                        name: 'Opstilling 1',
                        notes: '',
                        parts: [],
                        timestamp: new Date().toISOString(),
                        updated: new Date().toISOString()
                    }];
                    OpstillingData.activeSetupId = 1;
                }
            }
            
            await saveOpstillingDataToLocalStorage();
            const activeSetup = getActiveSetup();
            if (activeSetup) {
                loadSetupFromOpstillingData(activeSetup);
            }
            renderHistoryFilterOptions();
            await renderHistory();
            await renderSamlingManagerList();
        }
        
        function buildSamlingColorGrid() {
            if (!samlingColorGridEl) return;
            samlingColorGridEl.innerHTML = '';
            SAMLING_COLOR_PRESETS.forEach(color => {
                const swatch = document.createElement('button');
                swatch.className = 'samling-color-swatch';
                swatch.style.background = color;
                swatch.title = color;
                swatch.onclick = () => handleSamlingColorSelected(color);
                samlingColorGridEl.appendChild(swatch);
            });
        }
        
        // Update createNewCollection to use overlay instead
        function createNewCollection() {
            openSamlingManager();
        }

        // Load setup from opstillingData structure
        async function loadSetupFromOpstillingData(setup) {
            if (!setup) return false;
            
            // Set flag FIRST
            isLoadingSetup = true;
            
            try {
                // Ensure setup has timestamp
                if (!setup.timestamp) {
                    setup.timestamp = setup.updated || new Date().toISOString();
                }
                if (!setup.updated) {
                    setup.updated = setup.timestamp || new Date().toISOString();
                }
                
                // Clear current workspace
                const workspace = document.getElementById('workspace');
                const workspaceContent = workspace.querySelector('.workspace-content');
                workspaceContent.innerHTML = `
                    <div class="background-layer" id="backgroundLayer"></div>
                    <div class="background-labels" id="backgroundLabels"></div>
                `;
                selectedPart = null;
                draggedElement = null;
                dragState = null;
                colorIndex = 0;
                
                // Restore general notes
                generalNotes = setup.notes || '';
                const notesEl = document.getElementById('partNotes');
                if (notesEl) {
                    notesEl.value = generalNotes;
                    notesEl.placeholder = 'Generelle noter til hele opstillingen...';
                }
                
                // Update notes title
                updateNotesTitle();
                
                // Load parts - check success
                if (Array.isArray(setup.parts) && setup.parts.length > 0) {
                    setup.parts.forEach(p => {
                        try {
                            loadPartFromData({
                                name: p.name || '',
                                x: Number(p.x) || 0,
                                y: Number(p.y) || 0,
                                size: Number(p.size) || 1,
                                color: p.color || '',
                                borderColor: '',
                                layer: Number(p.layer) || 1,
                                notes: '',
                                keywords: [],
                                groupIndex: '',
                                group: '',
                                poseName: (p.pose || ''),
                                mirror: !!p.flipped
                            });
                        } catch (e) {
                            console.error('Failed to load part:', e);
                        }
                    });
                    
                    // Verify parts were actually loaded
                    await new Promise(resolve => setTimeout(resolve, 100));
                    const loadedCount = document.querySelectorAll('.part').length;
                    if (loadedCount !== setup.parts.length) {
                        console.error('Parts mismatch: expected', setup.parts.length, 
                                    'but loaded', loadedCount);
                    }
                } else {
                    // If setup.parts is empty or doesn't exist, ensure it's an empty array
                    if (!Array.isArray(setup.parts)) {
                        setup.parts = [];
                    }
                }
                
                // Render
                renderBackground();
                renderLabels();
                
                return true;
            } catch (e) {
                console.error('Fejl ved indlæsning fra opstillingData:', e);
                return false;
            } finally {
                // Only after parts are fully loaded
                await new Promise(resolve => setTimeout(resolve, 200));
                isLoadingSetup = false;
            }
        }
        
        // Load active setup from opstillingData, or fallback to legacy storage
        async function loadActiveOpstilling() {
            // First try to load from new opstillingData structure
            if (OpstillingData && Array.isArray(OpstillingData.collections) && OpstillingData.collections.length > 0) {
                const activeSetup = getActiveSetup();
                if (activeSetup) {
                    // Always load setup to update workspace with positions and notes, even if empty
                    const loaded = await loadSetupFromOpstillingData(activeSetup);
                    if (loaded) {
                        // Verify that parts were actually loaded
                        const partsInDOM = document.querySelectorAll('.part').length;
                        const partsInData = Array.isArray(activeSetup.parts) ? activeSetup.parts.length : 0;
                        if (partsInData > 0 && partsInDOM === 0) {
                            console.warn('Parts in data but not loaded to DOM. Retrying...');
                            // Retry loading after a short delay
                            setTimeout(async () => {
                                await loadSetupFromOpstillingData(activeSetup);
                            }, 500);
                        }
                        return true;
                    }
                }
            }
            
            // Legacy localStorage fallback removed - Firestore only
            return false;
        }
        
        async function saveCharactersToShared() {
            // Wrapper for syncCurrentWorkspaceToActiveSetup - kept for compatibility
            // All saves now go through syncCurrentWorkspaceToActiveSetup which has safety guards
            await syncCurrentWorkspaceToActiveSetup();
            await renderHistory();
        }
        
        const partColors = [
            '#f59e0b',  // orange/gul
            '#0891b2',  // cyan
            '#db2777',  // pink
            '#7c3aed',  // lilla
            '#059669',  // grøn
            '#ea580c',  // orange
            '#dc2626',  // rød
            '#2563eb',  // blå
            '#65a30d',  // lime grøn
            '#9333ea'   // violet
        ];
        
        const borderColors = ['#fbbf24', '#06b6d4', '#ec4899', '#8b5cf6', '#10b981', '#f97316', '#ef4444', '#3b82f6', '#84cc16', '#a855f7'];
        
        const groupColors = [
            '#f59e0b',  // orange/gul
            '#0891b2',  // cyan
            '#db2777',  // pink
            '#7c3aed',  // lilla
            '#059669',  // grøn
            '#ea580c',  // orange
            '#dc2626',  // rød
            '#2563eb',  // blå
            '#65a30d',  // lime grøn
            '#9333ea'   // violet
        ];
		
		
		
		const presets = {};

        
        const defaultLabels = {
            har_onsker: {
                topLeft: 'Har/Ønsker',
                topRight: 'Har/Ønsker-ikke', 
                bottomLeft: 'Har ikke/Ønsker',
                bottomRight: 'Har ikke/Ønsker ikke'
            },
            xy_axes: {
                xLabel: 'X-akse',
                yLabel: 'Y-akse'
            },
            timeline: {
                title: 'Tidslinje',
                start: 'Start',
                end: 'Slut'
            },
            for_imod: {
                left: 'For',
                right: 'Imod'
            },
            drama_trekant: {
                offer: 'Offer',
                hjaelper: 'Hjælper',
                boeddel: 'Bøddel'
            },
			mandala: {
				kerne: 'Kerne',
				primaer: 'Primær',
				sekundaer: 'Sekundær',
				periferi: 'Periferi'
			}
        };
		
		////pose bibliotek
// Pose Library - loaded from external JSON file
let poseLibrary = [];

// Load pose library from external JSON file
async function loadPoseLibrary() {
    try {
        const response = await fetch('Standard_new_poses.json');
        if (response.ok) {
            poseLibrary = await response.json();
        } else {
            console.error('Failed to load pose library');
            // Fallback to basic poses
            poseLibrary = [
                {
                    "name": "standard",
                    "pose": {
                        "translate_x_left": -3,
                        "translate_y_left": 0,
                        "skulder_rot_left": -70,
                        "albue_rot_left": 0,
                        "translate_x": 3,
                        "translate_y": 0,
                        "skulder_rot": 70,
                        "albue_rot": 0,
                        "translate_x_left_leg": 0,
                        "translate_y_left_leg": 0,
                        "hofte_rot_left": 6,
                        "knae_rot_left": 0,
                        "translate_x_right_leg": 0,
                        "translate_y_right_leg": 0,
                        "hofte_rot_right": -6,
                        "knae_rot_right": 0,
                        "left_arm_front": false,
                        "right_arm_front": false,
                        "duration": 0.3
                    }
                }
            ];
        }
    } catch (error) {
        console.error('Error loading pose library:', error);
        // Fallback to basic poses
        poseLibrary = [
            {
                "name": "standard",
                "pose": {
                    "translate_x_left": -3,
                    "translate_y_left": 0,
                    "skulder_rot_left": -70,
                    "albue_rot_left": 0,
                    "translate_x": 3,
                    "translate_y": 0,
                    "skulder_rot": 70,
                    "albue_rot": 0,
                    "translate_x_left_leg": 0,
                    "translate_y_left_leg": 0,
                    "hofte_rot_left": 6,
                    "knae_rot_left": 0,
                    "translate_x_right_leg": 0,
                    "translate_y_right_leg": 0,
                    "hofte_rot_right": -6,
                    "knae_rot_right": 0,
                    "left_arm_front": false,
                    "right_arm_front": false,
                    "duration": 0.3
                }
            }
        ];
    }
}
		
		
//////////	slut	// pose bibliotek
		
		function resetPose(part) {
			// Apply the "standard" pose from poseLibrary if available; fallback to previous relaxed pose
			const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
			if (standardIndex !== -1) {
				// Persist selection so it is saved to storage for new parts
				part.setAttribute('data-pose', standardIndex.toString());
				part.setAttribute('data-mirror', 'false');
				applyPose(part, standardIndex, false);
				return;
			}
			const relaxedPose = {
				translate_x_left: -3,
				translate_y_left: 0,
				skulder_rot_left: -70,
				albue_rot_left: 0,
				translate_x: 3,
				translate_y: 0,
				skulder_rot: 70,
				albue_rot: 0,
				translate_x_left_leg: 0,
				translate_y_left_leg: 0,
				hofte_rot_left: 6,
				knae_rot_left: 0,
				translate_x_right_leg: 0,
				translate_y_right_leg: 0,
				hofte_rot_right: -6,
				knae_rot_right: 0,
				left_arm_front: false,
				right_arm_front: false
			};
			applyPoseData(part, relaxedPose);
		}

		function applyPose(part, poseIndex, mirror = false) {
			if (poseIndex === '' || poseIndex === null) {
				resetPose(part);
				return;
			}
			
			const pose = poseLibrary[poseIndex];
			if (!pose) return;
			
			let poseData = pose.pose;
			
			// If mirror is checked, create mirrored version
			if (mirror) {
				poseData = {
					translate_x_left: -(pose.pose.translate_x || 0),
					translate_x: -(pose.pose.translate_x_left || 0),
					translate_y_left: pose.pose.translate_y || 0,
					translate_y: pose.pose.translate_y_left || 0,
					skulder_rot_left: -(pose.pose.skulder_rot || 0),
					skulder_rot: -(pose.pose.skulder_rot_left || 0),
					albue_rot_left: -(pose.pose.albue_rot || 0),
					albue_rot: -(pose.pose.albue_rot_left || 0),
					translate_x_left_leg: -(pose.pose.translate_x_right_leg || 0),
					translate_x_right_leg: -(pose.pose.translate_x_left_leg || 0),
					translate_y_left_leg: pose.pose.translate_y_right_leg || 0,
					translate_y_right_leg: pose.pose.translate_y_left_leg || 0,
					hofte_rot_left: -(pose.pose.hofte_rot_right || 0),
					hofte_rot_right: -(pose.pose.hofte_rot_left || 0),
					knae_rot_left: -(pose.pose.knae_rot_right || 0),
					knae_rot_right: -(pose.pose.knae_rot_left || 0),
					left_arm_front: pose.pose.right_arm_front || false,
					right_arm_front: pose.pose.left_arm_front || false
				};
			}
			
			applyPoseData(part, poseData);
		}

		function applyPoseData(part, poseData) {
			const skulderLeft = part.querySelector('.skulder_translate_left');
			const skulderRight = part.querySelector('.skulder_translate_right');
			const hofteLeft = part.querySelector('.hofte_translate_left');
			const hofteRight = part.querySelector('.hofte_translate_right');
			
			if (skulderLeft) {
				skulderLeft.style.transform = `translate(${poseData.translate_x_left || 0}px, ${poseData.translate_y_left || 0}px)`;
				const skulderRotLeft = skulderLeft.querySelector('.skulder_rotate_left');
				if (skulderRotLeft) {
					skulderRotLeft.style.transform = `rotate(${poseData.skulder_rot_left || 0}deg)`;
					const albueRotLeft = skulderRotLeft.querySelector('.albue_rotate_left');
					if (albueRotLeft) {
						albueRotLeft.style.transform = `rotate(${poseData.albue_rot_left || 0}deg)`;
					}
				}
			}
			
			if (skulderRight) {
				skulderRight.style.transform = `translate(${poseData.translate_x || 0}px, ${poseData.translate_y || 0}px)`;
				const skulderRotRight = skulderRight.querySelector('.skulder_rotate_right');
				if (skulderRotRight) {
					skulderRotRight.style.transform = `rotate(${poseData.skulder_rot || 0}deg)`;
					const albueRotRight = skulderRotRight.querySelector('.albue_rotate_right');
					if (albueRotRight) {
						albueRotRight.style.transform = `rotate(${poseData.albue_rot || 0}deg)`;
					}
				}
			}
			
			if (hofteLeft) {
				hofteLeft.style.transform = `translate(${poseData.translate_x_left_leg || 0}px, ${poseData.translate_y_left_leg || 0}px)`;
				const hofteRotLeft = hofteLeft.querySelector('.hofte_rotate_left');
				if (hofteRotLeft) {
					hofteRotLeft.style.transform = `rotate(${poseData.hofte_rot_left || 0}deg)`;
					const knaeRotLeft = hofteRotLeft.querySelector('.knae_rotate_left');
					if (knaeRotLeft) {
						knaeRotLeft.style.transform = `rotate(${poseData.knae_rot_left || 0}deg)`;
					}
				}
			}
			
			if (hofteRight) {
				hofteRight.style.transform = `translate(${poseData.translate_x_right_leg || 0}px, ${poseData.translate_y_right_leg || 0}px)`;
				const hofteRotRight = hofteRight.querySelector('.hofte_rotate_right');
				if (hofteRotRight) {
					hofteRotRight.style.transform = `rotate(${poseData.hofte_rot_right || 0}deg)`;
					const knaeRotRight = hofteRotRight.querySelector('.knae_rotate_right');
					if (knaeRotRight) {
						knaeRotRight.style.transform = `rotate(${poseData.knae_rot_right || 0}deg)`;
					}
				}
			}
			
			// Handle arm layering
			if (poseData.left_arm_front) {
				skulderLeft.classList.add('front-arm');
			} else {
				skulderLeft.classList.remove('front-arm');
			}
			
			if (poseData.right_arm_front) {
				skulderRight.classList.add('front-arm');
			} else {
				skulderRight.classList.remove('front-arm');
			}
			
		}		
		
		function updatePoseDropdown() {
			const dropdown = document.getElementById('partPoseSelect');
			const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
			if (standardIndex !== -1) {
				dropdown.innerHTML = '';
			} else {
				dropdown.innerHTML = '<option value="">Standard pose</option>';
			}
			
			poseLibrary.forEach((pose, index) => {
				const option = document.createElement('option');
				option.value = index;
				option.textContent = pose.name;
				dropdown.appendChild(option);
			});
		}

		function applyPartPose(poseIndex) {
			if (!selectedPart) return;
			
			const mirror = document.getElementById('partMirrorPose').checked;
			
			// Save pose data to part (store as string for consistency)
			selectedPart.setAttribute('data-pose', poseIndex.toString());
			selectedPart.setAttribute('data-mirror', mirror.toString());
			
			// Apply the pose (convert to number for applyPose function)
			const numericPoseIndex = poseIndex === '' ? '' : parseInt(poseIndex);
			applyPose(selectedPart, numericPoseIndex, mirror);
			// Auto-save after pose change
			(async () => { await saveCharactersToShared(); })();
		}

		function togglePartMirror() {
			if (!selectedPart) return;
			
			const poseIndex = document.getElementById('partPoseSelect').value;
			const mirror = document.getElementById('partMirrorPose').checked;
			
			// Save mirror state
			selectedPart.setAttribute('data-mirror', mirror.toString());
			
			// Reapply current pose with new mirror setting (convert to number)
			const numericPoseIndex = poseIndex === '' ? '' : parseInt(poseIndex);
			applyPose(selectedPart, numericPoseIndex, mirror);
			// Auto-save after mirror change
			(async () => { await saveCharactersToShared(); })();
		}		
		
		function openPosePicker(btn) {
    currentPosePart = btn.closest('.part');
    
    const modal = document.getElementById('posePickerModal');
    const picker = modal.querySelector('.pose-picker');
    
    // Populate pose grid
    populatePoseGrid();
    
    // Set current mirror state
    const currentMirror = currentPosePart.getAttribute('data-mirror') === 'true';
    document.getElementById('posePickerMirror').checked = currentMirror;
    
    // Remove any previous positioning
    picker.style.position = '';
    picker.style.left = '';
    picker.style.top = '';
    
    // Initialize drag functionality for mirror label
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let initialX = 0;
    let initialY = 0;
    
    // Remove previous listeners if any and set up drag
    const newMirrorLabel = picker.querySelector('.pose-mirror-label');
    if (newMirrorLabel) {
        // Clone and replace to remove old listeners
        const newLabel = newMirrorLabel.cloneNode(true);
        newMirrorLabel.parentNode.replaceChild(newLabel, newMirrorLabel);
        
        // Update mirrorLabel reference to point to new element
        const actualMirrorLabel = newLabel;
        
        // Update startDrag to move entire picker when dragging from label
        function actualStartDrag(e) {
            // Don't start drag if clicking on checkbox
            if (e.target.type === 'checkbox') {
                return;
            }
            
            // Prevent label from toggling checkbox
            e.preventDefault();
            e.stopPropagation();
            
            isDragging = true;
            const pickerRect = picker.getBoundingClientRect();
            startX = e.clientX;
            startY = e.clientY;
            initialX = pickerRect.left;
            initialY = pickerRect.top;
            
            picker.style.position = 'fixed';
            picker.style.zIndex = '10000';
            
            document.addEventListener('pointermove', actualDrag, { passive: false });
            document.addEventListener('pointerup', stopDrag, { passive: false });
        }
        
        function actualDrag(e) {
            if (!isDragging) return;
            if (e && typeof e.preventDefault === 'function') e.preventDefault();
            
            const deltaX = e.clientX - startX;
            const deltaY = e.clientY - startY;
            
            picker.style.left = (initialX + deltaX) + 'px';
            picker.style.top = (initialY + deltaY) + 'px';
        }
        
        function stopDrag() {
            if (isDragging) {
                isDragging = false;
                document.removeEventListener('pointermove', actualDrag);
                document.removeEventListener('pointerup', stopDrag);
            }
        }
        
        // Re-attach checkbox change handler
        const checkbox = newLabel.querySelector('#posePickerMirror');
        if (checkbox) {
            checkbox.addEventListener('change', togglePosePickerMirror);
            
            // Prevent label from toggling checkbox when clicking on label (not checkbox)
            newLabel.addEventListener('click', function(e) {
                // Only prevent if clicking on label itself, not checkbox
                if (e.target.type !== 'checkbox' && e.target !== checkbox && e.target.tagName !== 'INPUT') {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true); // Use capture phase to catch before default label behavior
        }
        
        // Add drag listener
        newLabel.addEventListener('pointerdown', actualStartDrag, { passive: false });
    }
    
    // Show modal - CSS flexbox will center it
    modal.classList.add('show');
}

function populatePoseGrid() {
    const grid = document.getElementById('poseGrid');
    grid.innerHTML = '';
    const currentPose = currentPosePart.getAttribute('data-pose') || '';
    const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
    // Add all poses from library (including "standard")
    poseLibrary.forEach((pose, index) => {
        const btn = document.createElement('button');
        btn.className = 'pose-button';
        btn.textContent = pose.name;
        btn.onclick = () => selectPose(index);
        
        // Check if this is the current active pose
        if (currentPose === index.toString() || (currentPose === '' && index === standardIndex)) {
            btn.classList.add('active');
        }
        
        grid.appendChild(btn);
    });
}

function selectPose(poseIndex) {
    if (!currentPosePart) return;
    
    const mirror = document.getElementById('posePickerMirror').checked;
    
    // Map empty selection to standard index if available
    if (poseIndex === '') {
        const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
        if (standardIndex !== -1) {
            poseIndex = standardIndex;
        }
    }

    // Save pose data
    currentPosePart.setAttribute('data-pose', poseIndex);
    currentPosePart.setAttribute('data-mirror', mirror.toString());
    
    // Apply pose
    applyPose(currentPosePart, poseIndex, mirror);
    
    // Update active button
    populatePoseGrid();
    // Auto-save after pose change (picker)
    (async () => { await saveCharactersToShared(); })();
}

function togglePosePickerMirror() {
    if (!currentPosePart) return;
    
    let poseIndex = currentPosePart.getAttribute('data-pose') || '';
    const mirror = document.getElementById('posePickerMirror').checked;
    
    // Save mirror state
    currentPosePart.setAttribute('data-mirror', mirror.toString());
    
    // Reapply pose with new mirror setting
    if (poseIndex === '') {
        const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
        if (standardIndex !== -1) {
            poseIndex = standardIndex;
        }
    }
    applyPose(currentPosePart, poseIndex, mirror);
    // Auto-save after mirror change (picker)
    (async () => { await saveCharactersToShared(); })();
}

function closePosePicker() {
    document.getElementById('posePickerModal').classList.remove('show');
    // Save to Firestore when pose overlay closes
    if (currentPosePart) {
        (async () => {
            await syncCurrentWorkspaceToActiveSetup();
        })();
    }
    currentPosePart = null;
}
		
        
 // indtast stikord når figuren laves.
 function openKeywordsPopup(part) {
    currentKeywordsPart = part;
    const modal = document.getElementById('keywordsPopupModal');
    const popup = modal.querySelector('.keywords-popup');
    const nameSpan = document.getElementById('keywordsPopupName');
    const partName = part.querySelector('.part-name').textContent;
    
    nameSpan.textContent = partName;
    
    // Clear inputs
    for (let i = 1; i <= 6; i++) {
        document.getElementById(`popupKeyword${i}`).value = '';
    }
    
    modal.classList.add('show');
    
    // Position popup next to the part
    const partRect = part.getBoundingClientRect();
    popup.style.position = 'absolute';
    popup.style.left = (partRect.right + 20) + 'px';
    popup.style.top = (partRect.top) + 'px';
    
    // Adjust if goes off screen
    setTimeout(() => {
        const popupRect = popup.getBoundingClientRect();
        if (popupRect.right > window.innerWidth) {
            popup.style.left = (partRect.left - popupRect.width - 20) + 'px';
        }
        if (popupRect.bottom > window.innerHeight) {
            popup.style.top = (window.innerHeight - popupRect.height - 20) + 'px';
        }
        if (popupRect.top < 0) {
            popup.style.top = '20px';
        }
    }, 10);
    
    // Focus first input
    setTimeout(() => {
        document.getElementById('popupKeyword1').focus();
    }, 100);
}

function closeKeywordsPopup() {
    if (!currentKeywordsPart) return;
    
    // Save keywords to part
    for (let i = 1; i <= 6; i++) {
        const value = document.getElementById(`popupKeyword${i}`).value;
        currentKeywordsPart.setAttribute(`data-keyword${i}`, value);
    }
    
    // Update keywords display
    updatePartKeywords(currentKeywordsPart);
    // Auto-save after keywords popup close
    (async () => { await saveCharactersToShared(); })();
    
    // If this part is selected, update the bottom inputs too
    if (selectedPart === currentKeywordsPart) {
        for (let i = 1; i <= 6; i++) {
            const value = currentKeywordsPart.getAttribute(`data-keyword${i}`) || '';
            document.getElementById(`keyword${i}`).value = value;
        }
    }
    
    // Close modal
    document.getElementById('keywordsPopupModal').classList.remove('show');
    currentKeywordsPart = null;
}
       
        
        // Color picker functions
        function hslToHex(h,s,l){
            s /= 100; l /= 100;
            const k = n => (n + h/30) % 12;
            const a = s * Math.min(l, 1 - l);
            const f = n => {
                const color = l - a * Math.max(Math.min(k(n) - 3, 9 - k(n), 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }
        
        function darkenColor(hex, percent) {
            const num = parseInt(hex.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) - amt;
            const G = (num >> 8 & 0x00FF) - amt;
            const B = (num & 0x0000FF) - amt;
            return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
        }
        
        function openColorPicker(btn) {
            const isGroupBtn = btn.classList.contains('group-color-btn');

            if (isGroupBtn) {
                currentGroupBtn = btn;
                currentPart = null;
            } else {
                currentPart = btn.closest('.part');
                currentGroupBtn = null;
            }
            
            const modal = document.getElementById('colorPickerModal');
            const picker = modal.querySelector('.picker');
            const dragBar = picker.querySelector('.picker-drag-bar');

            // Remove any previous positioning
            picker.style.position = '';
            picker.style.left = '';
            picker.style.top = '';

            // Initialize drag functionality
            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let initialX = 0;
            let initialY = 0;

            function startDrag(e) {
                isDragging = true;
                const pickerRect = picker.getBoundingClientRect();
                startX = e.clientX;
                startY = e.clientY;
                initialX = pickerRect.left;
                initialY = pickerRect.top;

                picker.style.position = 'fixed';
                picker.style.zIndex = '10000';

                document.addEventListener('pointermove', drag, { passive: false });
                document.addEventListener('pointerup', stopDrag, { passive: false });

                e.preventDefault();
            }

            function drag(e) {
                if (!isDragging) return;
                if (e && typeof e.preventDefault === 'function') e.preventDefault();

                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                picker.style.left = (initialX + deltaX) + 'px';
                picker.style.top = (initialY + deltaY) + 'px';
            }

            function stopDrag() {
                if (isDragging) {
                    isDragging = false;
                    document.removeEventListener('pointermove', drag);
                    document.removeEventListener('pointerup', stopDrag);
                }
            }

            // Remove previous listeners if any and add drag listener to drag bar
            if (dragBar) {
                // Clone and replace to remove old listeners
                const newDragBar = dragBar.cloneNode(true);
                dragBar.parentNode.replaceChild(newDragBar, dragBar);
                
                // Add drag listener to new drag bar
                newDragBar.addEventListener('pointerdown', startDrag, { passive: false });
            }

            // Prevent clicks inside picker from closing modal
            picker.addEventListener('click', function(e) {
                e.stopPropagation();
            });

            // Show modal - CSS flexbox will center it
            modal.classList.add('show');
        }
        
        function closeColorPicker() {
            document.getElementById('colorPickerModal').classList.remove('show');
            // Save to Firestore when color overlay closes
            if (currentPart) {
                (async () => {
                    await syncCurrentWorkspaceToActiveSetup();
                })();
            }
            currentPart = null;
        }
        
        let currentNotePart = null;
        
        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            // Calculate height based on content, but ensure minimum size for one line
            const scrollHeight = textarea.scrollHeight;
            const lineHeight = parseFloat(getComputedStyle(textarea).lineHeight) || 22.4;
            const minHeight = lineHeight + 12; // padding
            textarea.style.height = Math.max(scrollHeight, minHeight) + 'px';
        }
        
        function openNoteOverlay(btn) {
            currentNotePart = btn.closest('.part');
            const overlay = document.getElementById('noteOverlay');
            const textarea = document.getElementById('noteTextarea');
            
            // Load existing name from part
            const nameElement = currentNotePart.querySelector('.part-name');
            const existingName = nameElement ? nameElement.textContent.trim() : '';
            textarea.value = existingName;
            
            // Auto-resize textarea to fit content
            autoResizeTextarea(textarea);
            
            // Position overlay near the button or over the part
            const btnRect = btn.getBoundingClientRect();
            const partRect = currentNotePart.getBoundingClientRect();
            
            // Position overlay to the right of button, or over part if button is on left
            let overlayLeft = btnRect.right + 10;
            let overlayTop = btnRect.top;
            
            // Get actual overlay dimensions
            overlay.classList.add('show');
            const overlayRect = overlay.getBoundingClientRect();
            
            // If overlay would go off screen, position it over the part
            if (overlayLeft + overlayRect.width > window.innerWidth) {
                overlayLeft = partRect.left + (partRect.width / 2) - (overlayRect.width / 2);
                overlayTop = partRect.top + (partRect.height / 2) - (overlayRect.height / 2);
            }
            
            // Adjust if goes off screen
            if (overlayLeft < 10) overlayLeft = 10;
            if (overlayLeft + overlayRect.width > window.innerWidth) overlayLeft = window.innerWidth - overlayRect.width - 10;
            if (overlayTop < 10) overlayTop = 10;
            if (overlayTop + overlayRect.height > window.innerHeight) overlayTop = window.innerHeight - overlayRect.height - 10;
            
            overlay.style.left = overlayLeft + 'px';
            overlay.style.top = overlayTop + 'px';
            
            // Remove previous input listener and add new one
            const newTextarea = textarea.cloneNode(true);
            newTextarea.value = textarea.value;
            textarea.parentNode.replaceChild(newTextarea, textarea);
            newTextarea.addEventListener('input', function() {
                autoResizeTextarea(newTextarea);
            });
            
            // Close overlay on Enter key
            newTextarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    closeNoteOverlay();
                }
            });
            
            // Focus textarea and select all text
            setTimeout(() => {
                newTextarea.focus();
                newTextarea.select();
            }, 50);
        }
        
        function closeNoteOverlay() {
            const overlay = document.getElementById('noteOverlay');
            const textarea = document.getElementById('noteTextarea');
            
            if (currentNotePart) {
                // Save name to part
                const nameText = textarea.value.trim();
                const nameElement = currentNotePart.querySelector('.part-name');
                if (nameElement) {
                    nameElement.textContent = nameText;
                }
                
                // Save to shared storage
                try {
                    (async () => { await saveCharactersToShared(); })();
                } catch (e) {
                    console.warn('Kunne ikke gemme navn:', e);
                }
            }
            
            overlay.classList.remove('show');
            currentNotePart = null;
        }
        
        function selectColor(hex) {
        if (currentPart) {
			// Erklær alle variabler først
			const head = currentPart.querySelector('.head');
			const torso = currentPart.querySelector('.torso');
			const armParts = currentPart.querySelectorAll('.arm_geo_left, .arm_geo_right, .albue_geo_left, .albue_geo_right');
			const legParts = currentPart.querySelectorAll('.laar_geo_left, .laar_geo_right, .skinneben_geo_left, .skinneben_geo_right');
			
			// Funktion til at gøre farver mørkere
			function darkenColor(color, factor) {
				const r = parseInt(color.slice(1, 3), 16);
				const g = parseInt(color.slice(3, 5), 16);
				const b = parseInt(color.slice(5, 7), 16);
				
				if (factor === 20) {
					// For border - gør mørkere med procent
					const amt = Math.round(2.55 * factor);
					const newR = Math.max(0, r - amt);
					const newG = Math.max(0, g - amt);
					const newB = Math.max(0, b - amt);
					return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
				} else {
					// For body parts - multiplicer med factor
					const newR = Math.round(r * factor);
					const newG = Math.round(g * factor);
					const newB = Math.round(b * factor);
					return `rgb(${newR}, ${newG}, ${newB})`;
				}
			}
			
			const borderColor = darkenColor(hex, 20);
			const darkerColor = darkenColor(hex, 0.92);
			
			// Sæt farver på head
						if (head) {
				head.style.backgroundColor = hex;
			}
			
			// Sæt farver på body parts
			if (torso) torso.style.background = hex;
			armParts.forEach(arm => arm.style.background = darkerColor);
			legParts.forEach(leg => leg.style.background = darkerColor);
			
            currentPart.setAttribute('data-custom-color', hex);
            currentPart.setAttribute('data-custom-border', borderColor);

            // Persist new color to shared storage
            try { (async () => { await saveCharactersToShared(); })(); } catch(_) {}
		} else if (currentGroupBtn) {
			currentGroupBtn.style.backgroundColor = hex;
			currentGroupBtn.setAttribute('data-custom-color', hex);
			const groupNumber = currentGroupBtn.id.match(/\d+/)[0];
			refreshPartsForGroup(groupNumber);
			if (!isLoadingSetup) {
				(async () => { await saveCharactersToShared(); })();
			}
		}
	}

        function changeColor(btn) {
            try {
                openColorPicker(btn);
            } catch (error) {
                console.error('Fejl i changeColor:', error);
            }
        }
		
		
		// preset parsers isedet for at læse fra fil læses fra defaults
		// Funktion til at parse grupper fra linjer
			function parseGroupsFromLines(lines) { /* no-op */ }
		
		// Funktion til at parse labels fra linjer
			function parseLabelsFromLines(lines) { /* no-op */ }

			// Funktion til at indlæse preset
			function loadPreset(presetName) { /* no-op */ }
		
		
			// Funktion til at håndtere tema-ændring
			function changeTheme() { /* no-op */ }		
		
        
        // Background functions
        function changeBackground() {
            // Background drawings disabled
            currentBackground = 'none';
            const layer = document.getElementById('backgroundLayer');
            const labels = document.getElementById('backgroundLabels');
            if (layer) layer.innerHTML = '';
            if (labels) labels.innerHTML = '';
            if (typeof renderLabels === 'function') renderLabels();
            if (!isLoadingSetup && typeof saveCurrentOpstillingToStorage === 'function') {
                saveCurrentOpstillingToStorage();
            }
        }
        
        function renderBackground() {
            const layer = document.getElementById('backgroundLayer');
            if (layer) layer.innerHTML = '';
            return;
        }
        
        function renderLabels() {
            const container = document.getElementById('backgroundLabels');
            container.innerHTML = '';
            
            if (currentBackground === 'none') return;
            
            const labels = backgroundLabels[currentBackground];
            if (!labels) return;
            
            if (currentBackground === 'har_onsker') {
                createLabel(container, 'topLeft', labels.topLeft, '25%', '10%');
                createLabel(container, 'topRight', labels.topRight, '75%', '10%');
                createLabel(container, 'bottomLeft', labels.bottomLeft, '25%', '90%');
                createLabel(container, 'bottomRight', labels.bottomRight, '75%', '90%');
            }
            else if (currentBackground === 'xy_axes') {
                createLabel(container, 'xLabel', labels.xLabel, '50%', '95%');
                createLabel(container, 'yLabel', labels.yLabel, '5%', '50%');
            }
            else if (currentBackground === 'timeline') {
                createLabel(container, 'title', labels.title, '50%', '95%');
                createLabel(container, 'start', labels.start, '15%', '95%');
                createLabel(container, 'end', labels.end, '85%', '95%');
            }
            else if (currentBackground === 'for_imod') {
                createLabel(container, 'left', labels.left, '25%', '10%');
                createLabel(container, 'right', labels.right, '75%', '10%');
            } 
            else if (currentBackground === 'drama_trekant') {
                createLabel(container, 'offer', labels.offer, '50%', '10%');
                createLabel(container, 'hjaelper', labels.hjaelper, '15%', '85%');
                createLabel(container, 'boeddel', labels.boeddel, '85%', '85%');
            }else if (currentBackground === 'mandala') 
			{
				createLabel(container, 'kerne', labels.kerne, '61%', '32%');
				createLabel(container, 'primaer', labels.primaer, '69%', '24%');
				createLabel(container, 'sekundaer', labels.sekundaer, '77%', '16%');
				createLabel(container, 'periferi', labels.periferi, '85%', '8%');
}
        }
        
        function createLabel(container, key, text, left, top) {
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'label-input';
            input.value = text;
            input.style.left = left;
            input.style.top = top;
            
            input.addEventListener('change', function() {
                backgroundLabels[currentBackground][key] = this.value;
                saveCurrentOpstillingToStorage();
            });
            
            container.appendChild(input);
        }
        
        // Part management functions (updated for multi-background)
        function selectPart(e) { /* selection disabled */ }
        
        function changeGroupColor(groupNumber) {
            const colorBtn = document.getElementById(`groupColor${groupNumber}`);
            openColorPicker(colorBtn);
            refreshPartsForGroup(String(groupNumber));
            updateGroupDropdown();
            if (!isLoadingSetup) {
                saveCharactersToShared();
            }
         }
        
       function handleGroupSelection(selectElement) {
		if (selectedPart) {
			const index = selectElement.value;
			if (index) {
				const groupName = getGroupNameByIndex(index);
				selectedPart.setAttribute('data-group-index', index);
				selectedPart.setAttribute('data-group', groupName);
				applyGroupStylingToPart(selectedPart, index);
			} else {
				selectedPart.setAttribute('data-group-index', '');
				selectedPart.setAttribute('data-group', '');
				clearGroupStyling(selectedPart);
			}
		}

		if (!isLoadingSetup) {
			saveCharactersToShared();
		}
	}
        
        function updateGroupDropdown() {
            const dropdown = document.getElementById('partGroupSelect');
            dropdown.innerHTML = '<option value="">Vælg gruppe...</option>';
            
            for (let i = 1; i <= 6; i++) {
                const groupInput = document.getElementById(`group${i}`);
                const groupName = groupInput.value.trim();
                if (groupName) {
                    const option = document.createElement('option');
                    option.value = String(i);
                    option.textContent = groupName;
                    dropdown.appendChild(option);
                }
            }
        }
        
        function updateGroupsDisplay() { /* selection UI disabled */ }
        
        function updatePartKeywords(part) {
            const keywordsAbove = part.querySelector('.keywords-above');
            const keywordsBelow = part.querySelector('.keywords-below');
            
            const above = [];
            for (let i = 1; i <= 3; i++) {
                const keyword = part.getAttribute(`data-keyword${i}`);
                if (keyword && keyword.trim()) {
                    above.push(keyword.trim());
                }
            }
            
            const below = [];
            for (let i = 4; i <= 6; i++) {
                const keyword = part.getAttribute(`data-keyword${i}`);
                if (keyword && keyword.trim()) {
                    below.push(keyword.trim());
                }
            }
            
            keywordsAbove.innerHTML = above.join('<br>');
            keywordsBelow.innerHTML = below.join('<br>');
            
            // Always show keywords (keywords toggle removed)
            keywordsAbove.style.display = 'block';
            keywordsBelow.style.display = 'block';
        }
        
        function addPart(name = null, x = null, y = null, skipPopup = false, disableAnimations = false) {
            try {
                // Allow empty names or just whitespace - use the value as-is (trimmed or empty)
                const partName = name !== null ? name : (document.getElementById('partName').value.trim() || '');
                // No validation - allow empty names
                
                const workspace = document.getElementById('workspace');
                const workspaceContent = workspace.querySelector('.workspace-content');
                const part = document.createElement('div');
                part.className = 'part';
                if (disableAnimations) {
                    part.classList.add('no-initial-animation');
                    part.style.animation = 'none';
                    part.style.opacity = '1';
                }
                partCounter++;
                
                let posX, posY;
                if (x !== null && y !== null) {
                    // Use provided coordinates
                    posX = x;
                    posY = y;
                } else {
                    // Calculate position within visible viewport
                    const visibleWidth = workspace.clientWidth;
                    const visibleHeight = workspace.clientHeight;
                    const scrollLeft = workspace.scrollLeft;
                    const scrollTop = workspace.scrollTop;
                    
                    // Calculate visible area bounds in workspace-content coordinates
                    const visibleStartX = scrollLeft;
                    const visibleEndX = Math.min(scrollLeft + visibleWidth, workspaceContent.offsetWidth);
                    const visibleStartY = scrollTop;
                    const visibleEndY = Math.min(scrollTop + visibleHeight, workspaceContent.offsetHeight);
                    
                    // Add randomness within visible area, but keep part fully visible
                    // Part size is approximately 120px, so leave margin
                    const margin = 60; // Half of part size
                    const minX = Math.max(visibleStartX + margin, 0);
                    const maxX = Math.min(visibleEndX - margin - 120, workspaceContent.offsetWidth - 120);
                    const minY = Math.max(visibleStartY + margin, 0);
                    const maxY = Math.min(visibleEndY - margin - 120, workspaceContent.offsetHeight - 120);
                    
                    // Ensure valid range
                    if (maxX > minX && maxY > minY) {
                        posX = minX + Math.random() * (maxX - minX);
                        posY = minY + Math.random() * (maxY - minY);
                    } else {
                        // Fallback to center of visible area if calculation fails
                        posX = visibleStartX + (visibleWidth / 2) - 60;
                        posY = visibleStartY + (visibleHeight / 2) - 60;
                    }
                }
                
                part.style.left = posX + 'px';
                part.style.top = posY + 'px';
                
                const existingParts = document.querySelectorAll('.part');
                // Find max current layer to avoid duplicates if there are gaps or collisions
                let maxLayer = 0;
                existingParts.forEach(p => {
                    const l = parseInt(p.getAttribute('data-layer')) || 0;
                    if (l > maxLayer) maxLayer = l;
                });
                const newLayer = maxLayer + 1;
                part.style.zIndex = newLayer + 10;
                
                const assignedColor = partColors[colorIndex % partColors.length];
				const borderColor = borderColors[colorIndex % borderColors.length];

				
                
                part.setAttribute('data-color-index', colorIndex.toString());
                // per-part notes removed
                part.setAttribute('data-layer', newLayer.toString());
                part.setAttribute('data-group', '');
				part.setAttribute('data-part-scale', '1');
                part.setAttribute('data-keyword1', '');
                part.setAttribute('data-keyword2', '');
                part.setAttribute('data-keyword3', '');
                part.setAttribute('data-keyword4', '');
                part.setAttribute('data-keyword5', '');
                part.setAttribute('data-keyword6', '');
                part.setAttribute('data-custom-color', assignedColor);
                part.setAttribute('data-custom-border', borderColor);
                part.style.transform = 'scale(1)';
                
                colorIndex++;
                
                part.innerHTML = `
                    <div class="keywords-above part-keywords"></div>
						<div class="keywords-below part-keywords"></div>
						
						<div class="body">
							<div class="head">
								<span class="part-name">${partName}</span>
							</div>
							<div class="torso"></div>
							
							<!-- Venstre arm hierarki -->
							<div class="skulder_translate_left">
								<div class="skulder_rotate_left">
									<div class="arm_geo_left">
										<div class="albue_rotate_left">
											<div class="albue_geo_left"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Højre arm hierarki -->
							<div class="skulder_translate_right">
								<div class="skulder_rotate_right">
									<div class="arm_geo_right">
										<div class="albue_rotate_right">
											<div class="albue_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Venstre ben hierarki -->
							<div class="hofte_translate_left">
								<div class="hofte_rotate_left">
									<div class="laar_geo_left">
										<div class="knae_rotate_left">
											<div class="skinneben_geo_left"></div>
										</div>
									</div>
								</div>
							</div>

							<!-- Højre ben hierarki -->
							<div class="hofte_translate_right">
								<div class="hofte_rotate_right">
									<div class="laar_geo_right">
										<div class="knae_rotate_right">
											<div class="skinneben_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
						</div>
					
					<button class="control-btn delete-btn" title="Slet del">×</button>
                    
                    <button class="control-btn layer-up" title="Bring frem">↑</button>
                    <button class="control-btn layer-down" title="Send bagud">↓</button>
                    <button class="control-btn size-plus" title="Gør større">+</button>
                    <button class="control-btn size-minus" title="Gør mindre">−</button>
                    <button class="control-btn color-btn" title="Skift farve">C</button>
					<button class="control-btn pose-btn" title="Skift pose">P</button>
					<button class="control-btn note-btn" title="Rediger navn">N</button>
                `;
				
				// Name is only editable via the "N" button
				
				// Set colors on body parts
				const head = part.querySelector('.head');
				const torso = part.querySelector('.torso');
				const armParts = part.querySelectorAll('.arm_geo_left, .arm_geo_right, .albue_geo_left, .albue_geo_right');
				const legParts = part.querySelectorAll('.laar_geo_left, .laar_geo_right, .skinneben_geo_left, .skinneben_geo_right');

				// Funktion til at gøre farver mørkere
				function darkenColor(hex, factor = 0.92) {
					const r = parseInt(hex.slice(1, 3), 16);
					const g = parseInt(hex.slice(3, 5), 16);
					const b = parseInt(hex.slice(5, 7), 16);
					
					const newR = Math.round(r * factor);
					const newG = Math.round(g * factor);
					const newB = Math.round(b * factor);
					
					return `rgb(${newR}, ${newG}, ${newB})`;
				}

				const darkerColor = darkenColor(assignedColor, 0.92);

				if (head) {
					head.style.background = assignedColor;
					//head.style.border = `4px solid ${borderColor}`; -ingen border
				}
				if (torso) torso.style.background = assignedColor;
				armParts.forEach(arm => arm.style.background = darkerColor);
				legParts.forEach(leg => leg.style.background = darkerColor);
                
                part.addEventListener('pointerdown', startDrag);
                // selection disabled
                part.addEventListener('dragstart', (e) => e.preventDefault());
                
                const deleteBtn = part.querySelector('.delete-btn');
                
                const layerUpBtn = part.querySelector('.layer-up');
                const layerDownBtn = part.querySelector('.layer-down');
                const sizePlusBtn = part.querySelector('.size-plus');
                const sizeMinusBtn = part.querySelector('.size-minus');
                const colorBtn = part.querySelector('.color-btn');
				const poseBtn = part.querySelector('.pose-btn');
				const noteBtn = part.querySelector('.note-btn');
                
                deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deletePart(deleteBtn); });
                
                layerUpBtn.addEventListener('click', (e) => { e.stopPropagation(); moveToFront(layerUpBtn); });
                layerDownBtn.addEventListener('click', (e) => { e.stopPropagation(); moveToBack(layerDownBtn); });
                sizePlusBtn.addEventListener('click', (e) => { e.stopPropagation(); increaseSize(sizePlusBtn); });
                sizeMinusBtn.addEventListener('click', (e) => { e.stopPropagation(); decreaseSize(sizeMinusBtn); });
                colorBtn.addEventListener('click', (e) => { e.stopPropagation(); changeColor(colorBtn); });
                poseBtn.addEventListener('click', (e) => { e.stopPropagation(); openPosePicker(poseBtn); });
				noteBtn.addEventListener('click', (e) => { e.stopPropagation(); openNoteOverlay(noteBtn); });
				
                workspaceContent.appendChild(part);
				resetPose(part);
				
				// Name editing is only available via the "N" button
				
				// Update shared data
				(async () => { await saveCharactersToShared(); })();
				
				// Save parts to Firestore immediately when part is created (no debounce)
				// This ensures parts are saved even if page is reloaded quickly
				// Use requestAnimationFrame + setTimeout to ensure part is fully in DOM and rendered
				requestAnimationFrame(() => {
					setTimeout(async () => {
						// Ensure OpstillingData exists and has active setup
						if (!OpstillingData) {
							await ensureDefaultOpstillingData();
						}
						const setup = getActiveSetup();
						if (!setup) {
							return;
						}
						// Verify part is in DOM before exporting
						const allParts = document.querySelectorAll('.part');
						if (allParts.length === 0) {
							return;
						}
						// Force save immediately - don't wait for debounce
						// Wait for save to complete before continuing
						await syncCurrentWorkspaceToActiveSetup();
					}, 300);
				});
                
                document.getElementById('partName').value = '';
                document.getElementById('partName').placeholder = "Navn på del (f.eks. Beskytteren, Den Kritiske, Det Sårede Barn...)";
                
            } catch (error) {
                console.error('Fejl i addPart:', error);
            }
        }
        
        function deletePart(btn) {
            try {
                const part = btn.closest('.part');
                const deletedLayer = parseInt(part.getAttribute('data-layer')) || 1;
                part.remove();
                
                if (selectedPart === part) {
					selectedPart = null;
					updateGroupsDisplay();
					updateNotesTitle();
					document.getElementById('partNotes').value = '';
					document.getElementById('partNotes').placeholder = 'Generelle noter til hele opstillingen...';
					for (let i = 1; i <= 6; i++) {
						document.getElementById(`keyword${i}`).value = '';
					}
				}
                
                const allParts = document.querySelectorAll('.part');
                allParts.forEach(p => {
                    const currentLayer = parseInt(p.getAttribute('data-layer')) || 1;
                    if (currentLayer > deletedLayer) {
                        const newLayer = currentLayer - 1;
                        p.setAttribute('data-layer', newLayer.toString());
                        p.style.zIndex = newLayer + 10;
                    }
                });
                // Ensure layers are unique and compact after delete
                normalizeLayers();
                // Auto-save after delete
                saveCharactersToShared();
                // Save parts to Firestore with debounce (2 seconds)
                if (partSaveDebounceTimeout) {
                    clearTimeout(partSaveDebounceTimeout);
                }
                partSaveDebounceTimeout = setTimeout(async () => {
                    await syncCurrentWorkspaceToActiveSetup();
                    partSaveDebounceTimeout = null;
                }, 2000);
                
            } catch (error) {
                console.error('Fejl i deletePart:', error);
            }
        }
        
        function moveToFront(btn) {
            try {
                const part = btn.closest('.part');
                const currentLayer = parseInt(part.getAttribute('data-layer')) || 1;
                const allParts = document.querySelectorAll('.part');
                const maxLayer = allParts.length;
                const targetLayer = currentLayer + 1;
                
                if (targetLayer > maxLayer) return;
                
                let targetPart = null;
                allParts.forEach(p => {
                    if (parseInt(p.getAttribute('data-layer')) === targetLayer) {
                        targetPart = p;
                    }
                });
                
                // If there is a gap or duplicate layers, normalize and retry
                if (!targetPart) {
                    normalizeLayers();
                    const refreshedParts = document.querySelectorAll('.part');
                    refreshedParts.forEach(p => {
                        if (parseInt(p.getAttribute('data-layer')) === currentLayer + 1) {
                            targetPart = p;
                        }
                    });
                }

                if (targetPart) {
                    part.setAttribute('data-layer', targetLayer.toString());
                    part.style.zIndex = targetLayer + 10;
                    targetPart.setAttribute('data-layer', currentLayer.toString());
                    targetPart.style.zIndex = currentLayer + 10;
                }
                // Auto-save after layer change (front)
                saveCharactersToShared();
                // Save parts to Firestore with debounce (2 seconds)
                if (partSaveDebounceTimeout) {
                    clearTimeout(partSaveDebounceTimeout);
                }
                partSaveDebounceTimeout = setTimeout(async () => {
                    await syncCurrentWorkspaceToActiveSetup();
                    partSaveDebounceTimeout = null;
                }, 2000);
            } catch (error) {
                console.error('Fejl i moveToFront:', error);
            }
        }
        
        function moveToBack(btn) {
            try {
                const part = btn.closest('.part');
                const currentLayer = parseInt(part.getAttribute('data-layer')) || 1;
                const targetLayer = currentLayer - 1;
                
                if (targetLayer < 1) return;
                
                const allParts = document.querySelectorAll('.part');
                let targetPart = null;
                allParts.forEach(p => {
                    if (parseInt(p.getAttribute('data-layer')) === targetLayer) {
                        targetPart = p;
                    }
                });
                
                // If there is a gap or duplicate layers, normalize and retry
                if (!targetPart) {
                    normalizeLayers();
                    const refreshedParts = document.querySelectorAll('.part');
                    refreshedParts.forEach(p => {
                        if (parseInt(p.getAttribute('data-layer')) === targetLayer) {
                            targetPart = p;
                        }
                    });
                }

                if (targetPart) {
                    part.setAttribute('data-layer', targetLayer.toString());
                    part.style.zIndex = targetLayer + 10;
                    targetPart.setAttribute('data-layer', currentLayer.toString());
                    targetPart.style.zIndex = currentLayer + 10;
                }
                // Auto-save after layer change (back)
                saveCharactersToShared();
                // Save parts to Firestore with debounce (2 seconds)
                if (partSaveDebounceTimeout) {
                    clearTimeout(partSaveDebounceTimeout);
                }
                partSaveDebounceTimeout = setTimeout(async () => {
                    await syncCurrentWorkspaceToActiveSetup();
                    partSaveDebounceTimeout = null;
                }, 2000);
            } catch (error) {
                console.error('Fejl i moveToBack:', error);
            }
        }

        // Ensure unique, compact layers (1..N) with matching z-index
        function normalizeLayers() {
            try {
                const parts = Array.from(document.querySelectorAll('.part'));
                // Sort by current data-layer asc; fall back to DOM order
                parts.sort((a, b) => {
                    const la = parseInt(a.getAttribute('data-layer')) || 0;
                    const lb = parseInt(b.getAttribute('data-layer')) || 0;
                    return la - lb;
                });
                parts.forEach((p, idx) => {
                    const layer = idx + 1;
                    p.setAttribute('data-layer', layer.toString());
                    p.style.zIndex = layer + 10;
                });
            } catch (error) {
                console.error('Fejl i normalizeLayers:', error);
            }
        }
        
		function increaseSize(btn) {
			try {
				const part = btn.closest('.part');
				let currentScale = parseFloat(part.getAttribute('data-part-scale')) || 1;
				
				let increment = 0.1;
				const newScale = Math.min(3, Math.round((currentScale + increment) * 10) / 10);
				part.style.transform = `scale(${newScale})`;
				part.setAttribute('data-part-scale', newScale.toString());
				
                    saveCharactersToShared();
					
					// Save parts to Firestore with debounce (2 seconds)
					if (partSaveDebounceTimeout) {
						clearTimeout(partSaveDebounceTimeout);
					}
					partSaveDebounceTimeout = setTimeout(async () => {
						await syncCurrentWorkspaceToActiveSetup();
						partSaveDebounceTimeout = null;
					}, 2000);
				
			} catch (error) {
				console.error('Fejl i increaseSize:', error);
			}
		}



		function decreaseSize(btn) {
			try {
				const part = btn.closest('.part');
				let currentScale = parseFloat(part.getAttribute('data-part-scale')) || 1;
				
				let decrement = 0.1;
				const newScale = Math.max(0.45, Math.round((currentScale - decrement) * 10) / 10);
				part.style.transform = `scale(${newScale})`;
				part.setAttribute('data-part-scale', newScale.toString());
				
                    saveCharactersToShared();
					
					// Save parts to Firestore with debounce (2 seconds)
					if (partSaveDebounceTimeout) {
						clearTimeout(partSaveDebounceTimeout);
					}
					partSaveDebounceTimeout = setTimeout(async () => {
						await syncCurrentWorkspaceToActiveSetup();
						partSaveDebounceTimeout = null;
					}, 2000);
				
				} catch (error) {
					console.error('Fejl i decreaseSize:', error);
				}
			}
				
        
        
        function updatePartSize(part, sizeMultiplier) {
		part.style.transform = `scale(${sizeMultiplier})`;
		part.setAttribute('data-part-scale', sizeMultiplier.toString());
		if (!isLoadingSetup) {
			saveCharactersToShared();
			
			// Save parts to Firestore with debounce (2 seconds)
			if (partSaveDebounceTimeout) {
				clearTimeout(partSaveDebounceTimeout);
			}
			partSaveDebounceTimeout = setTimeout(async () => {
				await syncCurrentWorkspaceToActiveSetup();
				partSaveDebounceTimeout = null;
			}, 2000);
		}
		}
        
        function startDrag(e) {
				try {
					if (e.target.classList.contains('control-btn') || e.target.classList.contains('label-input')) return;
					
					draggedElement = e.target.closest('.part');
					if (!draggedElement) return;
					
					draggedElement.classList.add('dragging');
					
					const workspace = document.getElementById('workspace');
					const workspaceRect = workspace.getBoundingClientRect();
					
					// Get current element position in workspace coordinates
					const elementLeft = parseFloat(draggedElement.style.left) || 0;
					const elementTop = parseFloat(draggedElement.style.top) || 0;
					
					// Calculate cursor position in workspace coordinates (accounting for scroll)
					const cursorX = e.clientX - workspaceRect.left + workspace.scrollLeft;
					const cursorY = e.clientY - workspaceRect.top + workspace.scrollTop;
					
					// Calculate offset in workspace coordinates
					offset.x = cursorX - elementLeft;
					offset.y = cursorY - elementTop;
					
					// Initialize simple drag state
					dragState = {
						lastX: e.clientX,
						lastY: e.clientY,
						velocityX: 0,
						isDragging: true,
						settleTimeout: null,
						currentRotation: 0,
						targetRotation: 0,
						animationId: null
					};
					
					// Start continuous animation loop
					const animate = () => {
						if (dragState && dragState.isDragging) {
							const lerpFactor = 0.3; // How fast to interpolate
							dragState.currentRotation += (dragState.targetRotation - dragState.currentRotation) * lerpFactor;
							
							const body = draggedElement.querySelector('.body');
							if (body) {
								body.style.transform = `translateX(-50%) rotate(${dragState.currentRotation}deg)`;
							}
							
							dragState.animationId = requestAnimationFrame(animate);
						}
					};
					
					dragState.animationId = requestAnimationFrame(animate);
					
                document.addEventListener('pointermove', drag, { passive: false });
                document.addEventListener('pointerup', stopDrag, { passive: false });
				} catch (error) {
					console.error('Fejl i startDrag:', error);
				}
			}
        
        function drag(e) {
            try {
                if (!draggedElement || !dragState) return;
                if (e && typeof e.preventDefault === 'function') e.preventDefault();
                
                const workspace = document.getElementById('workspace');
                const workspaceRect = workspace.getBoundingClientRect();
                
                // Calculate rotation based on movement direction
                const deltaX = e.clientX - dragState.lastX;
                dragState.velocityX = deltaX;
                dragState.lastX = e.clientX;
                dragState.lastY = e.clientY;
                
                // Clear any existing settle timeout
                if (dragState.settleTimeout) {
                    clearTimeout(dragState.settleTimeout);
                    dragState.settleTimeout = null;
                }
                
                // Calculate target rotation based on movement
                if (Math.abs(deltaX) > 0.5) {
                    dragState.targetRotation = deltaX * 1.5; // Sensitivity multiplier
                    dragState.targetRotation = Math.max(-15, Math.min(15, dragState.targetRotation)); // Clamp to ±15 degrees
                }
                
                // Set timeout to settle back to 0 after 200ms of no movement
                if (Math.abs(deltaX) > 0.5) {
                    dragState.settleTimeout = setTimeout(() => {
                        dragState.targetRotation = 0;
                        // Let the interpolation handle the smooth return
                    }, 200);
                }
                
                // Calculate cursor position in workspace coordinates (accounting for scroll)
                const cursorX = e.clientX - workspaceRect.left + workspace.scrollLeft;
                const cursorY = e.clientY - workspaceRect.top + workspace.scrollTop;
                
                // Calculate new position in workspace coordinates
                let newX = cursorX - offset.x;
                let newY = cursorY - offset.y;

                // Fixed-margin clamp based on part's top-left (independent of size)
                // Use workspace-content for size calculations to prevent workspace growth
                const workspaceContent = workspace.querySelector('.workspace-content');
                const minLeft = 1;   // target approx left edge
                const minTop  = 6;   // target approx top edge
                const rightMargin = 86; // workspace-content.width - maxLeft (≈1600-1514)
                const bottomMargin = 78; // workspace-content.height - maxTop (≈600-522)
                const maxLeft = workspaceContent.offsetWidth - rightMargin;
                const maxTop  = workspaceContent.offsetHeight - bottomMargin;

                newX = Math.max(minLeft, Math.min(newX, maxLeft));
                newY = Math.max(minTop,  Math.min(newY, maxTop));
                
                draggedElement.style.left = newX + 'px';
                draggedElement.style.top = newY + 'px';
            } catch (error) {
                console.error('Fejl i drag:', error);
            }
        }
        
        function stopDrag() {
			try {
				if (draggedElement && dragState) {
					draggedElement.classList.remove('dragging');
					
					// Clear any pending settle timeout
					if (dragState.settleTimeout) {
						clearTimeout(dragState.settleTimeout);
					}
					
					// Stop dragging flag but continue animation
					dragState.isDragging = false;
					dragState.targetRotation = 0;
					
					// Save parts to Firestore with debounce (2 seconds) when drag ends
					if (partSaveDebounceTimeout) {
						clearTimeout(partSaveDebounceTimeout);
					}
					partSaveDebounceTimeout = setTimeout(async () => {
						await syncCurrentWorkspaceToActiveSetup();
						partSaveDebounceTimeout = null;
					}, 2000);
					
					// Continue settle animation until rotation is back to 0
					const settleAnimation = () => {
						if (dragState && Math.abs(dragState.currentRotation) > 0.1) {
							const lerpFactor = 0.2; // Slower settling
							dragState.currentRotation += (dragState.targetRotation - dragState.currentRotation) * lerpFactor;
							
							const body = draggedElement.querySelector('.body');
							if (body) {
								body.style.transform = `translateX(-50%) rotate(${dragState.currentRotation}deg)`;
							}
							
							dragState.animationId = requestAnimationFrame(settleAnimation);
						} else {
							// Final cleanup when settled
							const body = draggedElement.querySelector('.body');
							if (body) {
								body.style.transform = `translateX(-50%) rotate(0deg)`;
							}
							
							// Save shared characters (updates x,y)
							saveCharactersToShared();
							
							// Save parts to Firestore with debounce (2 seconds)
							if (partSaveDebounceTimeout) {
								clearTimeout(partSaveDebounceTimeout);
							}
							partSaveDebounceTimeout = setTimeout(async () => {
								await syncCurrentWorkspaceToActiveSetup();
								partSaveDebounceTimeout = null;
							}, 2000);
							
							draggedElement = null;
							dragState = null;
						}
					};
					
					dragState.animationId = requestAnimationFrame(settleAnimation);
				}
                document.removeEventListener('pointermove', drag);
                document.removeEventListener('pointerup', stopDrag);
			} catch (error) {
				console.error('Fejl i stopDrag:', error);
			}
		}

        function loadPartFromData({
            name = '',
            x = 0,
            y = 0,
            size = 1,
            color = '',
            borderColor = '',
            layer = 1,
            notes = '',
            keywords = [],
            groupIndex = '',
            group = '',
            poseName = '',
            mirror = false
        }) {
            try {
                addPart(name, x, y, true, true);

                const newPart = document.querySelector('.part:last-child');
                if (!newPart) return;

                newPart.classList.add('suppress-transitions');
                newPart.classList.add('loaded-from-storage');
                newPart.style.transition = 'none';

                let colorIndex = partColors.findIndex(c => c && color && c.toLowerCase() === color.toLowerCase());
                if (colorIndex === -1) colorIndex = 0;

                const effectiveColor = color || partColors[colorIndex] || '#f59e0b';

                newPart.setAttribute('data-color-index', colorIndex.toString());
                newPart.setAttribute('data-custom-color', effectiveColor);
                if (borderColor) {
                    newPart.setAttribute('data-custom-border', borderColor);
                }
                newPart.setAttribute('data-layer', layer.toString());
                newPart.style.zIndex = layer + 10;
                // per-part notes removed; ignore notes from imports
                newPart.setAttribute('data-group', group);
                newPart.setAttribute('data-part-scale', size.toString());
                newPart.style.transform = `scale(${size})`;

                // keywords removed

                newPart.setAttribute('data-mirror', mirror ? 'true' : 'false');

                const head = newPart.querySelector('.head');
                const torso = newPart.querySelector('.torso');
                const armParts = newPart.querySelectorAll('.arm_geo_left, .arm_geo_right, .albue_geo_left, .albue_geo_right');
                const legParts = newPart.querySelectorAll('.laar_geo_left, .laar_geo_right, .skinneben_geo_left, .skinneben_geo_right');

                const darkenColor = (hex, factor = 0.92) => {
                    if (!hex || !hex.startsWith('#') || hex.length < 7) {
                        return hex;
                    }
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);

                    const newR = Math.round(r * factor);
                    const newG = Math.round(g * factor);
                    const newB = Math.round(b * factor);

                    return `rgb(${newR}, ${newG}, ${newB})`;
                };

                const darkerColor = darkenColor(effectiveColor, 0.92);

                if (head) head.style.background = effectiveColor;
                if (torso) torso.style.background = effectiveColor;
                armParts.forEach(arm => arm.style.background = darkerColor);
                legParts.forEach(leg => leg.style.background = darkerColor);

                // keywords and groups removed

                // Restore pose + mirror (supports both index and name)
                if (poseName) {
                    const maybeIndex = Number(poseName);
                    if (!Number.isNaN(maybeIndex)) {
                        // Stored as numeric index
                        const poseIndex = maybeIndex;
                        newPart.setAttribute('data-pose', poseIndex.toString());
                        applyPose(newPart, poseIndex, mirror);
                    } else {
                        // Stored as pose name
                        const poseIndex = poseLibrary.findIndex(p => p && p.name === poseName);
                        if (poseIndex !== -1) {
                            newPart.setAttribute('data-pose', poseIndex.toString());
                            applyPose(newPart, poseIndex, mirror);
                        } else {
                            // Unknown pose – keep attribute but reset visual pose
                            newPart.setAttribute('data-pose', poseName);
                            resetPose(newPart);
                        }
                    }
                } else {
                    newPart.setAttribute('data-pose', '');
                    resetPose(newPart);
                }

                requestAnimationFrame(() => {
                    newPart.style.opacity = '1';
                    requestAnimationFrame(() => {
                        newPart.classList.remove('suppress-transitions');
                        newPart.style.transition = '';
                        requestAnimationFrame(() => {
                            newPart.style.opacity = '';
                        });
                    });
                });

            } catch (error) {
                console.error('Fejl i loadPartFromData:', error);
            }
        }

        function loadCurrentOpstillingFromStorage() {
            const previousLoadingState = isLoadingSetup;
            try {
                const savedOpstilling = localStorage.getItem('current_opstilling');
                if (!savedOpstilling) return false;

                const lines = savedOpstilling.split('\n');
                isLoadingSetup = true;
                const success = importOpstillingFromLines(lines, 'none');
                return success;
            } catch (error) {
                console.error('Fejl ved indlæsning fra localStorage:', error);
                return false;
            } finally {
                isLoadingSetup = previousLoadingState;
            }
        }

        function clearAll() {
            try {
                // Remove all parts from workspace
                const parts = document.querySelectorAll('.part');
                parts.forEach(part => part.remove());
                
                // Clear notes
                generalNotes = '';
                const notesEl = document.getElementById('partNotes');
                if (notesEl) {
                    notesEl.value = '';
                    notesEl.placeholder = 'Generelle noter for opstillingen...';
                }
                
                // Clean up drag state
                selectedPart = null;
                draggedElement = null;
                dragState = null;
                
                // Reset color index
                colorIndex = 0;
                
                // Update the active setup in opstillingData
                syncCurrentWorkspaceToActiveSetup();
                
                // Data saved via syncCurrentWorkspaceToActiveSetup() to Firestore

            } catch (error) {
                console.error('Fejl i clearAll:', error);
            }
        }
        
        function editName(btn) {
            try {
                const part = btn.closest ? btn.closest('.part') : btn.parentElement.closest('.part');
                const nameSpan = part.querySelector('.part-name');
                const currentName = nameSpan.textContent;
                
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentName;
                input.className = 'name-input';
                input.maxLength = 30;
                
                nameSpan.style.display = 'none';
                nameSpan.parentNode.insertBefore(input, nameSpan);
                
                input.focus();
                input.select();
                
                let isFinishing = false;

				function finishEdit() {
					if (isFinishing) return;
					isFinishing = true;
					
					// Allow empty names - use trimmed value or empty string
					const newName = input.value.trim();
					nameSpan.textContent = newName;
					nameSpan.style.display = 'block';
					
					if (input.parentNode) {
						input.remove();
					}
					
					if (selectedPart && selectedPart === part) {
						const displayName = newName || '(uden navn)';
						document.getElementById('partNotes').placeholder = `Detaljerede noter til "${displayName}"`;
					}
					// Sync dataset and persist immediately
					part.setAttribute('data-name', newName);
					if (!isLoadingSetup) {
						saveCharactersToShared();
					}
				}
                
                input.addEventListener('blur', finishEdit);
                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        finishEdit();
                    }
                    if (e.key === 'Escape') {
                        nameSpan.style.display = 'block';
                        input.remove();
                    }
                });
            } catch (error) {
                console.error('Fejl i editName:', error);
            }
        }
        
        function buildOpstillingCsv() {
            const sanitize = (value) => (value ?? '').toString().replace(/;/g, ',');
            const sanitizeNotes = (value) => sanitize(value).replace(/\n/g, '\\n');
            const parts = document.querySelectorAll('.part');

            let csv = 'Navn;PosX;PosY;Størrelse;Farve;Lag;Pose;Mirror\n';

            parts.forEach(part => {
                const name = part.querySelector('.part-name')?.textContent || '';
                const posX = parseInt(part.style.left) || 0;
                const posY = parseInt(part.style.top) || 0;
                const sizeAttr = part.getAttribute('data-part-scale') || '1';
                const size = Number.parseFloat(sizeAttr) || 1;

                const colorIndexAttr = Number.parseInt(part.getAttribute('data-color-index'), 10);
                const fallbackColorIndex = Number.isNaN(colorIndexAttr) ? 0 : colorIndexAttr;
                const color = part.getAttribute('data-custom-color') || partColors[fallbackColorIndex] || '#f59e0b';

                const layer = part.getAttribute('data-layer') || '1';
                // removed: per-part notes, keywords, group index/name
                const poseAttr = part.getAttribute('data-pose') || '';
                let poseName = '';
                if (poseAttr !== '') {
                    const maybeIndex = Number(poseAttr);
                    if (!Number.isNaN(maybeIndex) && poseLibrary[maybeIndex]) {
                        poseName = poseLibrary[maybeIndex].name || '';
                    } else {
                        poseName = poseAttr;
                    }
                }

                const mirror = part.getAttribute('data-mirror') === 'true';

                const row = [
                    sanitize(name),
                    posX,
                    posY,
                    Number(size.toFixed(4)),
                    sanitize(color),
                    layer,
                    sanitize(poseName),
                    mirror ? 'true' : 'false'
                ];

                csv += row.join(';') + '\n';
            });

            // removed: group names/colors and background labels sections

            csv += '\n# Generelle Noter\n';
            csv += sanitizeNotes(generalNotes) + '\n';

            // removed: Selected Background section

            return csv;
        }

        function saveCurrentOpstillingToStorage() {
            // No-op: All data is now saved via syncCurrentWorkspaceToActiveSetup() to Firestore
            // Kept for compatibility with existing code
        }

        function saveSetup() {
            try {
                const parts = document.querySelectorAll('.part');
                if (parts.length === 0) {
                    alert('Ingen dele at gemme! Tilføj først nogle dele til opstillingen.');
                    return;
                }

                const csv = buildOpstillingCsv();
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
                const link = document.createElement('a');
                const dato = new Date().toISOString().slice(0, 10);

                const fileName = prompt('Filnavn (uden .csv):', `Opstilling_${dato}`);
                if (fileName === null || fileName.trim() === '') {
                    link.download = `Opstilling_${dato}.csv`;
                } else {
                    const cleanName = fileName.trim().replace(/[<>:"/\\|?*]/g, '_');
                    link.download = cleanName.endsWith('.csv') ? cleanName : `${cleanName}.csv`;
                }

                link.href = URL.createObjectURL(blob);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error('Fejl i saveSetup:', error);
                alert('Der opstod en fejl ved gemning af opstillingen.');
            }
        }
		
		
		
		
		
		
        
        function loadSetup() {
            try {
                const fileInput = document.getElementById('fileInput');
                if (fileInput) {
                    if (window.__fileDialogOpen) return;
                    window.__fileDialogOpen = true;
                    fileInput.click();
                } else {
                    alert('Fejl: Kan ikke finde file input element');
                }
            } catch (error) {
                console.error('Fejl i loadSetup:', error);
                alert('Der opstod en fejl ved indlæsning: ' + error.message);
            }
        }
		
		function exportAsImage() {
    try {
        const workspace = document.getElementById('workspace');
        const transparentBg = document.getElementById('transparentBackground').checked;
        const workspaceContent = workspace.querySelector('.workspace-content');
        
        // Skjul control buttons
        const controlBtns = workspace.querySelectorAll('.control-btn');
        controlBtns.forEach(btn => btn.style.display = 'none');
        
        // Skjul selection
        const wasSelected = selectedPart;
        if (selectedPart) {
            selectedPart.classList.remove('selected');
        }
        
        // Håndter transparent baggrund
        const backgroundLayer = document.getElementById('backgroundLayer');
        const backgroundLabels = document.getElementById('backgroundLabels');
        const originalBgColor = workspace.style.backgroundColor || '';
        const originalContentBg = workspaceContent ? (workspaceContent.style.backgroundColor || '') : '';
        const originalBgDisplay = backgroundLayer ? (backgroundLayer.style.display || '') : '';
        const originalLabelsDisplay = backgroundLabels ? (backgroundLabels.style.display || '') : '';
        
        if (transparentBg) {
            // Skjul baggrund og labels
            workspace.style.backgroundColor = 'transparent';
            if (workspaceContent) workspaceContent.style.backgroundColor = 'transparent';
            if (backgroundLayer) backgroundLayer.style.display = 'none';
            if (backgroundLabels) backgroundLabels.style.display = 'none';
        } else if (workspaceContent) {
            const computedBg = window.getComputedStyle(workspace).backgroundColor;
            if (computedBg && computedBg !== 'rgba(0, 0, 0, 0)') {
                workspaceContent.style.backgroundColor = computedBg;
            } else {
                workspaceContent.style.backgroundColor = '#ffffff';
            }
        }
        
        // Modern-screenshot - use workspace-content for export
        modernScreenshot.domToPng(workspaceContent, {
            width: workspaceContent.offsetWidth,
            height: workspaceContent.offsetHeight,
            scale: 2,
			quality: 1 
			
        }).then(dataUrl => {
            // Gendan UI
            controlBtns.forEach(btn => btn.style.display = '');
            if (wasSelected) {
                wasSelected.classList.add('selected');
            }
            
            // Gendan baggrund hvis den blev ændret
            if (workspaceContent) workspaceContent.style.backgroundColor = originalContentBg;
            if (transparentBg) {
                workspace.style.backgroundColor = originalBgColor || '';
                if (backgroundLayer) backgroundLayer.style.display = originalBgDisplay || '';
                if (backgroundLabels) backgroundLabels.style.display = originalLabelsDisplay || '';
            }
            
            // Download
            const link = document.createElement('a');
            const dato = new Date().toISOString().slice(0, 10);
            const bgText = transparentBg ? '_transparent' : '';
            link.download = `Opstilling-${dato}${bgText}.png`;
            link.href = dataUrl;
            link.click();
            
        }).catch(error => {
            console.error('Fejl:', error);
            
            // Gendan UI ved fejl
            controlBtns.forEach(btn => btn.style.display = '');
            if (wasSelected) {
                wasSelected.classList.add('selected');
            }
            
            if (workspaceContent) workspaceContent.style.backgroundColor = originalContentBg;
            // Gendan baggrund ved fejl
            if (transparentBg) {
                workspace.style.backgroundColor = originalBgColor || '';
                if (backgroundLayer) backgroundLayer.style.display = originalBgDisplay || '';
                if (backgroundLabels) backgroundLabels.style.display = originalLabelsDisplay || '';
            }
            
            alert('Eksport fejlede');
        });
        
    } catch (error) {
        console.error('Fejl:', error);
        alert('Modern-Screenshot ikke tilgængelig');
    }
}
        
        function handleWorkspaceClick(e) {
            try {
                const workspaceEl = document.getElementById('workspace');
                const clickedPart = e.target.closest('.part');

                if (workspaceEl.contains(e.target) && !clickedPart) {
					if (selectedPart) {
						selectedPart.classList.remove('selected');
						selectedPart = null;
						updateGroupsDisplay();

						const titleElement = document.getElementById('profileTitle');
						if (titleElement) titleElement.textContent = '';

						updateNotesTitle();

						const notesEl = document.getElementById('partNotes');
						notesEl.value = generalNotes;
						notesEl.placeholder = 'Generelle noter til hele opstillingen...';
                        for (let i = 1; i <= 6; i++) {
                            document.getElementById(`keyword${i}`).value = '';
                        }
                    }

                    const rect = workspaceEl.getBoundingClientRect();
                    const x = e.clientX - rect.left - 60;
                    const y = e.clientY - rect.top - 60;
                    const partName = document.getElementById('partName').value.trim();
                    if (partName) addPart(partName, x, y);
                }
            } catch (error) {
                console.error('Fejl i handleWorkspaceClick:', error);
            }
        }
        
        document.addEventListener('DOMContentLoaded', async function() {
            // Require login - redirect if not logged in
            // Wait for auth state to be determined (max 3 seconds)
            try {
                await Promise.race([
                    authStatePromise,
                    new Promise(resolve => setTimeout(resolve, 3000))
                ]);
            } catch (e) {
                console.warn('Auth state wait error:', e);
            }
            
            // Resolve manually if not resolved yet
            if (!authStateReady && authStateResolver) {
                authStateResolver();
                authStateResolver = null;
            }
            
            // Check if user is logged in
            if (!currentUser) {
                alert('Du skal være logget ind for at bruge denne side. Redirecter til login...');
                window.location.href = 'index.html';
                return;
            }
            
            // Wait for snapshot listener to have data (max 2 seconds extra)
            if (opstillingDataCache === undefined) {
                for (let i = 0; i < 20; i++) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    if (opstillingDataCache !== undefined) break;
                }
            }
            
            // Initialize new Opstilling data structure and load pose library in parallel
            const [loadedData] = await Promise.all([
                loadOpstillingData(),
                loadPoseLibrary() // Load pose library in parallel, not blocking
            ]);
            
            // Only update OpstillingData if we got data from Firestore
            // If data is null, only create blank structure if we're sure there's no data (opstillingDataCache === null)
            if (loadedData !== null) {
                OpstillingData = loadedData;
            } else if (opstillingDataCache === null) {
                // Confirmed no data in Firestore - create default structure
                OpstillingData = null;
            }
            // If opstillingDataCache is undefined, snapshot hasn't responded yet - wait a bit more
            if (opstillingDataCache === undefined) {
                // Wait a bit more for snapshot to respond (up to 1 more second)
                for (let i = 0; i < 10; i++) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    if (opstillingDataCache !== undefined) {
                        // Snapshot has responded
                        const firestoreData = await loadOpstillingDataFromFirestore();
                        if (firestoreData !== null) {
                            OpstillingData = firestoreData;
                        } else if (opstillingDataCache === null) {
                            OpstillingData = null;
                        }
                        break;
                    }
                }
            }
            
            // Only ensure default if OpstillingData is null (confirmed no data)
            // But first check if Firestore actually has data before creating defaults
            if (OpstillingData === null) {
                // Before creating default data, check if Firestore has data
                const firestoreCheck = await checkOpstillingDataExistsInFirestore();
                if (firestoreCheck && firestoreCheck.exists) {
                    // Firestore has data, use it instead of creating defaults
                    console.log(`[INIT] Firestore has data (${firestoreCheck.collectionsCount} collections, ${firestoreCheck.setupsCount} setups, ${firestoreCheck.partsCount} parts), using it instead of creating defaults`);
                    OpstillingData = firestoreCheck.data;
                } else {
                    // No data in Firestore, create defaults
                    console.log('[INIT] No data in Firestore, creating default structure');
                    await ensureDefaultOpstillingData();
                }
            }
            
            // Load active opstilling (from opstillingData or legacy storage)
            await loadActiveOpstilling();
            
            // Wait for parts to be loaded in DOM (1 second)
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Mark initial load as complete
            isInitialLoad = false;
            
            // Initialize history sidebar
            await renderHistory();
            // Default to collapsed (true) unless explicitly set to false in localStorage
            const savedState = localStorage.getItem('opstilling_historySidebarCollapsed');
            const isCollapsed = savedState === null || savedState === 'true';
            const sidebar = document.getElementById('historySidebar');
            if (sidebar) {
                const toggleBtns = sidebar.querySelectorAll('.collapse-toggle');
                if (isCollapsed) {
                    sidebar.classList.add('collapsed');
                    toggleBtns.forEach(btn => btn.textContent = '<');
                } else {
                    sidebar.classList.remove('collapsed');
                    toggleBtns.forEach(btn => btn.textContent = '>');
                }
            }
            
            try {
				
				
                // Initialize color picker grid
                const grid = document.getElementById('colorGrid');
                
                for(let row = 0; row < 14; row++) {
                    for(let col = 0; col < 12; col++) {
                        let hex;
                        
                        if(row === 0) {
                            const hue = Math.round(col * 360/12);
                            hex = hslToHex(hue, 95, 50);
                        } else if(row === 1) {
                            const light = Math.round(100 - (col * (100/11)));
                            hex = hslToHex(0, 0, light);
                        } else {
                            const gridRow = row - 2;
                            const hue = Math.round(col * 360/12);
                            const light = Math.round(92 - (gridRow * (84/11)));
                            const satBase = 86;
                            const sat = Math.round(satBase - Math.abs((col - 6)/ 6) * 20);
                            hex = hslToHex(hue, sat, light);
                        }
                        
                        const swatch = document.createElement('button');
                        swatch.className = 'swatch';
                        swatch.style.background = hex;
                        swatch.dataset.hex = hex;
                        swatch.title = hex;
                        swatch.setAttribute('aria-label', `Farve ${hex}`);
                        swatch.tabIndex = 0;
                        
                        swatch.addEventListener('click', () => selectColor(hex));
                        
                        grid.appendChild(swatch);
                    }
                }
                
                // Color picker modal event listener - close when clicking on backdrop
                const colorPickerModal = document.getElementById('colorPickerModal');
                if (colorPickerModal) {
                    colorPickerModal.addEventListener('click', function(e) {
                        // Only close if clicking directly on the modal (backdrop), not on picker
                        if (e.target === this) {
                            closeColorPicker();
                        }
                    });
                }
                
                // Initialize group colors (only if not already set)
                for (let i = 1; i <= 6; i++) {
                    const colorBtn = document.getElementById(`groupColor${i}`);
                    if (colorBtn && !colorBtn.getAttribute('data-custom-color')) {
                        const colorIndex = parseInt(colorBtn.getAttribute('data-color-index')) || 0;
                        colorBtn.style.backgroundColor = groupColors[colorIndex];
                    }
                }
				
				
				// Pose picker modal event listener
				document.getElementById('posePickerModal').addEventListener('click', function(e) {
					if (e.target === this) {
						closePosePicker();
					}
				});
				
				// Note overlay - close when clicking outside
				document.addEventListener('click', function(e) {
					const noteOverlay = document.getElementById('noteOverlay');
					if (noteOverlay && noteOverlay.classList.contains('show')) {
						// Close if clicking outside the overlay
						if (!noteOverlay.contains(e.target)) {
							closeNoteOverlay();
						}
					}
				});
				
				// Prevent clicks inside note overlay from closing it
				const noteOverlay = document.getElementById('noteOverlay');
				if (noteOverlay) {
					noteOverlay.addEventListener('click', function(e) {
						e.stopPropagation();
					});
				}
				
				// Keywords popup modal event listener
				document.getElementById('keywordsPopupModal').addEventListener('click', function(e) {
					if (e.target === this) {
						closeKeywordsPopup();
					}
				});
				
                
                // Add event listeners
                const partNameInput = document.getElementById('partName');
                partNameInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        addPart();
                    }
                });
                
                const partNotesTextarea = document.getElementById('partNotes');
                let partNotesDebounceTimeout = null;
				partNotesTextarea.addEventListener('input', function() {
					generalNotes = this.value;
					
					// Clear previous timeout
					if (partNotesDebounceTimeout) {
						clearTimeout(partNotesDebounceTimeout);
					}
					
					// Debounce: wait 2 seconds after last input
					partNotesDebounceTimeout = setTimeout(() => {
						saveCurrentOpstillingToStorage();
						partNotesDebounceTimeout = null;
					}, 2000);
				});
                
                // Removed keyword inputs (#keyword1..#keyword6) – no listeners needed
                
                const workspace = document.getElementById('workspace');
                workspace.addEventListener('click', handleWorkspaceClick);
                
                const fileInput = document.getElementById('fileInput');
                if (fileInput) {
                    fileInput.addEventListener('change', function(event) {
                        const file = event.target.files[0];
                        // reset guard regardless of pick/cancel
                        window.__fileDialogOpen = false;
                        if (!file) return;
                        
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            isLoadingSetup = true;
                            try {
                                const csv = e.target.result;
                                const lines = csv.split('\n');
                                const loadSuccess = importOpstillingFromLines(lines, 'none');

                                isLoadingSetup = false;
                                if (loadSuccess) {
                                    try { saveCharactersToShared(); } catch (_) {}
                                } else {
                                    alert('Der opstod en fejl ved indlæsning af filen. Kontroller at det er en gyldig CSV-fil.');
                                }
                            } catch (error) {
                                console.error('Fejl ved indlæsning af fil:', error);
                                alert('Der opstod en fejl ved indlæsning af filen. Kontroller at det er en gyldig CSV-fil.');
                                isLoadingSetup = false;
                            }
                        };
                        reader.readAsText(file);
                        event.target.value = '';
                        // Skip auto-save during CSV load; final save happens after load completes
                    });
                }
                
                // removed: keywordsVisible and bodiesVisible checkboxes and listeners
                
                updateGroupsDisplay();
                
                // Removed group inputs (#group1..#group6) – no listeners needed
                
                // Initialize background
                renderBackground();
                renderLabels();
                
            } catch (error) {
                console.error('Fejl ved initialisering:', error);
            }
            
            // Initial sync to persistent opstilling model
            try { 
                (async () => {
                    await syncCurrentWorkspaceToActiveSetup();
                })();
            } catch(_) {}
        });
        
        // Firestore-only mode - no initialization needed beyond what's in DOMContentLoaded
        
        document.addEventListener('dragover', (e) => e.preventDefault());
        document.addEventListener('drop', (e) => e.preventDefault());
		
		// toggleAllBodies removed; bodies are always visible
		
		// Navigation overlay toggle function
		function toggleNavBox() {
			const navBox = document.getElementById('navBox');
			const navToggleBtn = document.querySelector('.nav-toggle-btn');
			
			if (navBox && navToggleBtn) {
				const isShowing = navBox.classList.contains('show');
				if (isShowing) {
					navBox.classList.remove('show');
				} else {
					// Position nav-box at top-left corner of toggle button
					const rect = navToggleBtn.getBoundingClientRect();
					navBox.style.top = rect.top + 'px';
					navBox.style.left = rect.left + 'px';
					navBox.classList.add('show');
				}
			}
		}
		
		// Initialize navigation overlay on page load - optimized with event delegation
		document.addEventListener('DOMContentLoaded', function() {
			const navBox = document.getElementById('navBox');
			const navToggleBtn = document.querySelector('.nav-toggle-btn');
			
			if (navBox) {
				// Mark current page as active
				const currentPage = 'opstilling_01.html';
				const navButtons = document.querySelectorAll('.nav-button');
				navButtons.forEach(btn => {
					if (btn.getAttribute('href') === currentPage || btn.textContent.trim() === 'Opstilling') {
						btn.classList.add('active');
					}
				});
				
				// Close overlays on Escape key
				document.addEventListener('keydown', (e) => {
					if (e.key === 'Escape') {
						if (samlingColorPickerModalEl && samlingColorPickerModalEl.classList.contains('show')) {
							closeSamlingColorPicker();
						} else if (samlingManagerOverlayEl && samlingManagerOverlayEl.classList.contains('show')) {
							closeSamlingManager();
						}
					}
				});
				
				// Close color picker on backdrop click
				document.addEventListener('mousedown', (e) => {
					if (!samlingColorPickerModalEl || !samlingColorPickerModalEl.classList.contains('show')) return;
					if (e.target.closest('.samling-color-picker')) return;
					if (e.target.closest('.samling-action-btn.color')) return;
					closeSamlingColorPicker();
				});
				
				// Use event delegation for nav button clicks (only one listener instead of multiple)
				navBox.addEventListener('click', function(e) {
					const navButton = e.target.closest('.nav-button');
					if (navButton) {
						e.stopPropagation();
						navBox.classList.remove('show');
						const href = navButton.getAttribute('href');
						if (href) {
							window.location.href = href;
						}
					}
				});
			}
			
			// Close nav box when clicking outside - single listener
			document.addEventListener('click', function(e) {
				if (navBox && navBox.classList.contains('show')) {
					if (!navBox.contains(e.target) && e.target !== navToggleBtn && !navToggleBtn?.contains(e.target)) {
						navBox.classList.remove('show');
					}
				}
			});
		});

        function importOpstillingFromLines(lines, defaultBackground = 'none') {
            const body = document.body;
            let addedLoadingClass = false;
            if (body && !body.classList.contains('loading-opstilling')) {
                body.classList.add('loading-opstilling');
                addedLoadingClass = true;
            }
            try {
                let selectedBackgroundFromFile = null;
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].trim() === '# Selected Background') {
                        for (let j = i + 1; j < lines.length; j++) {
                            const candidate = lines[j].trim();
                            if (candidate === '' || candidate.startsWith('#')) continue;
                            selectedBackgroundFromFile = candidate;
                            break;
                        }
                        break;
                    }
                }

                const workspace = document.getElementById('workspace');
                const workspaceContent = workspace.querySelector('.workspace-content');
                workspaceContent.innerHTML = `
                    <div class="background-layer" id="backgroundLayer"></div>
                    <div class="background-labels" id="backgroundLabels"></div>
                `;

                selectedPart = null;
                generalNotes = '';
                draggedElement = null;
                dragState = null;

                updateGroupsDisplay();
                const partNotesField = document.getElementById('partNotes');
                if (partNotesField) {
                    partNotesField.value = '';
                    partNotesField.placeholder = 'Generelle noter for opstillingen';
                }

                // keywords and background labels removed
                renderBackground();
                colorIndex = 0;
                // labels rendering removed

                for (let line of lines) {
                    if (line.trim() === '' || line.startsWith('#') || line.includes('Navn;PosX')) continue;

                    const parts = line.split(';');

                    const potentialIndex = (parts[13] || '').trim();
                    const isNewFormat = parts.length >= 17 && /^[1-6]$/.test(potentialIndex);

                    if (isNewFormat) {
                        const keywords = [];
                        for (let i = 0; i < 6; i++) {
                            keywords.push(parts[8 + i] || '');
                        }

                        loadPartFromData({
                            name: parts[0],
                            x: parseInt(parts[1]) || 0,
                            y: parseInt(parts[2]) || 0,
                            size: parseFloat(parts[3]) || 1,
                            color: parts[4] || '',
                            borderColor: parts[5] || '',
                            layer: parseInt(parts[6]) || 1,
                            notes: (parts[7] || '').replace(/\n/g, '\n'),
                            keywords,
                            groupIndex: potentialIndex,
                            group: parts[14] || '',
                            poseName: parts[15] || '',
                            mirror: (parts[16] || '').toLowerCase() === 'true'
                        });

                        if (!selectedBackgroundFromFile) {
                            selectedBackgroundFromFile = 'none';
                        }
                    } else if (parts.length >= 16) {
                        const keywords = [];
                        for (let i = 0; i < 6; i++) {
                            keywords.push(parts[7 + i] || '');
                        }

                        loadPartFromData({
                            name: parts[0],
                            x: parseInt(parts[1]) || 0,
                            y: parseInt(parts[2]) || 0,
                            size: parseFloat(parts[3]) || 1,
                            color: parts[4] || '',
                            layer: parseInt(parts[5]) || 1,
                            notes: (parts[6] || '').replace(/\n/g, '\n'),
                            keywords,
                            groupIndex: '',
                            group: parts[13] || '',
                            poseName: parts[14] || '',
                            mirror: (parts[15] || '').toLowerCase() === 'true'
                        });
                    }
                }

                // Ignore any saved group names/colors in import

                // Ignore applying any group-based borders

                // Ignore any saved background labels in import

                // Load general notes
                let inNotesSection = false;
                let notesContent = '';
                for (let line of lines) {
                    const trimmedLine = line.trim();
                    if (trimmedLine === '# Generelle Noter') {
                        inNotesSection = true;
                        continue;
                    }
                    if (inNotesSection) {
                        if (trimmedLine === '# Selected Background') {
                            break;
                        }
                        notesContent += line.replace(/\\n/g, '\n') + '\n';
                    }
                }
                generalNotes = notesContent.trim();
                if (partNotesField) {
                    partNotesField.value = generalNotes;
                    partNotesField.placeholder = 'Generelle noter til hele opstillingen...';
                }

                // Force no background regardless of saved data
                const backgroundSelect = document.getElementById('backgroundSelect');
                if (backgroundSelect) {
                    backgroundSelect.value = 'none';
                }
                currentBackground = 'none';
                changeBackground();

                document.querySelectorAll('.part').forEach(part => {
                    const partGroup = part.getAttribute('data-group');
                    if (partGroup) {
                        for (let i = 1; i <= 6; i++) {
                            const groupInput = document.getElementById(`group${i}`);
                            if (groupInput && groupInput.value.trim() === partGroup) {
                                const colorBtn = document.getElementById(`groupColor${i}`);
                                const groupColor = colorBtn.getAttribute('data-custom-color') || colorBtn.style.backgroundColor;
                                if (groupColor) {
                                    const head = part.querySelector('.head');
                                    if (head) {
                                        head.style.border = `4px solid ${groupColor}`;
                                    }
                                }
                                break;
                            }
                        }
                    }
                });

                normalizeLayers();
                return true;
            } catch (error) {
                console.error('Fejl i importOpstillingFromLines:', error);
                return false;
            } finally {
                if (addedLoadingClass && body) {
                    requestAnimationFrame(() => body.classList.remove('loading-opstilling'));
                }
            }
        }

        function findGroupIndexByName(name) {
            if (!name) return '';
            const target = name.trim().toLowerCase();
            for (let i = 1; i <= 6; i++) {
                const groupInput = document.getElementById(`group${i}`);
                if (groupInput && groupInput.value.trim().toLowerCase() === target) {
                    return String(i);
                }
            }
            return '';
        }
        
        function getGroupNameByIndex(index) {
            if (!index) return '';
            const groupInput = document.getElementById(`group${index}`);
            return groupInput ? groupInput.value.trim() : '';
        }
        
        function getGroupColorByIndex(index) {
            if (!index) return '';
            const colorBtn = document.getElementById(`groupColor${index}`);
            if (colorBtn) {
                return colorBtn.getAttribute('data-custom-color') || colorBtn.style.backgroundColor || groupColors[Number(index) - 1] || '';
            }
            return groupColors[Number(index) - 1] || '';
        }
        
        function applyGroupStylingToPart(part, index) {
            const head = part.querySelector('.head');
            const color = getGroupColorByIndex(index);
            if (head && color) {
                head.style.border = `4px solid ${color}`;
            } else if (head) {
                head.style.border = '';
            }
        }
        
        function clearGroupStyling(part) {
            const head = part.querySelector('.head');
            if (head) {
                head.style.border = '';
            }
        }
        
        function getPartGroupName(part) {
            const index = part.getAttribute('data-group-index');
            if (index) {
                return getGroupNameByIndex(index) || part.getAttribute('data-group') || '';
            }
            return part.getAttribute('data-group') || '';
        }

        function refreshPartsForGroup(index) {
            const parts = document.querySelectorAll(`.part[data-group-index="${index}"]`);
            const groupName = getGroupNameByIndex(index);
            parts.forEach(part => {
                part.setAttribute('data-group-index', index);
                part.setAttribute('data-group', groupName);
                if (groupName) {
                    applyGroupStylingToPart(part, index);
                } else {
                    clearGroupStyling(part);
                }
            });
        }

        function assignGroupIndicesByName() {
            document.querySelectorAll('.part').forEach(part => {
                if (!part.getAttribute('data-group-index')) {
                    const name = (part.getAttribute('data-group') || '').trim();
                    const index = findGroupIndexByName(name);
                    if (index) {
                        part.setAttribute('data-group-index', index);
                        part.setAttribute('data-group', getGroupNameByIndex(index));
                        applyGroupStylingToPart(part, index);
                    } else {
                        clearGroupStyling(part);
                    }
                }
            });
        }
    </script>
    <!-- Navigation overlay -->
    <div class="nav-overlay" id="navOverlay"></div>

</body>
</html>
                
                