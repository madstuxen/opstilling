<!DOCTYPE html>
<html lang="da">
<head>
    <!-- Firebase App (the core Firebase SDK) -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <!-- Firebase Authentication -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <!-- Firestore -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="imagefiles/apple-touch-icon.png">
    <title>Dialog - V</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            padding: 0px;
        }
        
        .dialog-container {
            width: 100%;
            max-width: 1600px;
            margin: 0 auto;
            min-height: 600px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 0px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            overflow-x: hidden;
            overflow-y: visible;
        }
        
        .header {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            padding: 16px 24px;
            text-align: center;
            border-radius: 0px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .header h1 {
            font-size: 2.0em;
            margin-bottom: 0px;
            font-weight: 300;
            width: 100%;
            text-align: center;
        }
        
        .header .nav-controls {
            position: absolute;
            top: 16px;
            left: 24px;
            display: inline-flex;
            flex-direction: column;
            gap: 0;
            align-items: flex-start;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .controls-bar {
            background: #f8fafc;
            padding: 12px 20px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .dropdown-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .dropdown-label {
            font-size: 14px;
            font-weight: 500;
            color: #374151;
            white-space: nowrap;
        }
        
        .participant-dropdown {
            padding: 8px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 15px;
            font-family: inherit;
            background: white;
            min-width: 160px;
            color: #374151;
            transition: all 0.3s ease;
        }
        
        .participant-dropdown:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        .participant-dropdown:disabled {
            background: #f3f4f6;
            color: #9ca3af;
            cursor: not-allowed;
        }
        
        .controls-divider {
            width: 1px;
            height: 30px;
            background: #e2e8f0;
            margin: 0 8px;
            flex-shrink: 0;
        }
        
        /* Navigation overlay */
        .nav-toggle-btn {
            width: 35px;
            height: 35px;
            padding: 5px 8px;
            border: none;
            border-radius: 12px;
            background: #e5e7eb;
            color: #374151;
            box-shadow: 0 12px 26px rgba(15, 23, 42, 0.16);
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            cursor: pointer;
            transition: all 0.25s ease;
        }
        
        .nav-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(107, 114, 128, 0.3);
        }
        
        .nav-toggle-btn span {
            width: 16px;
            height: 2px;
            border-radius: 999px;
            background: #374151;
        }
        
        .nav-overlay {
            display: none !important;
        }
        
        .nav-box {
            position: fixed;
            top: 0;
            left: 0;
            background: white;
            border-radius: 20px;
            padding: 20px 25px;
            z-index: 9999;
            display: none;
            flex-direction: column;
            gap: 10px;
            min-width: 200px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        
        .nav-box.show {
            display: flex;
        }
        
        .nav-button {
            padding: 8px 16px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            text-align: center;
            display: block;
            min-width: auto;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
        }
        
        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }
        
        .nav-button.active {
            background: #9ca3af !important;
            cursor: default;
            pointer-events: none;
        }
        .nav-button.nav-checkin {
            background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);
        }
        .nav-button.nav-checkin:hover:not(.active) {
            background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
            box-shadow: 0 5px 15px rgba(124, 58, 237, 0.3);
        }
        
        .nav-button:nth-child(1) {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        
        .nav-button:nth-child(1):hover:not(.active) {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }
        
        .nav-button:nth-child(2) {
            background: linear-gradient(135deg, #E6B94F 0%, #d97706 100%);
        }
        
        .nav-button:nth-child(2):hover:not(.active) {
            background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
            box-shadow: 0 5px 15px rgba(245, 158, 11, 0.3);
        }
        
        .nav-button:nth-child(3) {
            background: linear-gradient(135deg, #3368AE 0%, #1e40af 100%);
        }
        
        .nav-button:nth-child(3):hover:not(.active) {
            background: linear-gradient(135deg, #1e40af 0%, #1e3a8a 100%);
            box-shadow: 0 5px 15px rgba(37, 99, 235, 0.3);
        }
        
        .nav-button:nth-child(4) {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
        }
        
        .nav-button:nth-child(4):hover:not(.active) {
            background: linear-gradient(135deg, #db2777 0%, #be185d 100%);
            box-shadow: 0 5px 15px rgba(236, 72, 153, 0.3);
        }
        
        .nav-button:nth-child(5) {
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
        }
        
        .nav-button:nth-child(5):hover:not(.active) {
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
            box-shadow: 0 5px 15px rgba(71, 85, 105, 0.3);
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .new-dialog-btn { background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%); color: white; }
        
        .start-btn { background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; }
        .continue-btn { background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%); color: white; }
        .play-btn { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; }
        .pause-btn { background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; }
        .step-btn { background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white; }
        .clear-btn { background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; }
        .back-btn { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; }
        
        .btn:disabled { 
            background: #9ca3af !important; 
            cursor: not-allowed; 
            transform: none !important;
        }
        .btn:hover:not(:disabled) { transform: translateY(-1px); }
        
        .participants-section {
            background: #f8fafc;
            padding: 0;
            border-bottom: 2px solid #e2e8f0;
            height: 250px;
            flex-shrink: 0;
            overflow: visible;
            position: relative;
        }
        
        .participants-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
            max-width: 700px;
            margin: 0 auto;
            gap: 75px;
            height: 100%;
            overflow: visible;
            position: relative;
        }

        /* Prevent external scripts/overlays from shrinking dialog participants */
        .dialog-container .participants-container {
            max-width: 700px !important;
        }
        
        .participant {
            flex: 0 0 200px;
			margin-top: -160px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            position: relative;
            overflow: visible;
			transform-origin: center center;
            min-width: 200px;
        }
        
        .participant-circle {
    width: 72px;
    height: 72px;
    border-radius: 50%;
    background: transparent;  
    border: none;  
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    font-size: 10px;
    text-align: center;
    
    position: relative;
    padding: 5px;
    line-height: 1.1;
    z-index: 10;
}

/* New Advanced Figure Structure */
.participant-body {
    position: absolute;
    top: 76px;
    
    transform-origin: 50px -40px;
    z-index: 5;
    pointer-events: none;
    width: 100px;
    height: 200px;
}
/* Head */
.head {
    position: absolute;
    top: -78px;
    left: 50%;
    transform: translateX(-50%);
    width: 72px;
    height: 72px;
    border-radius: 50%;
    background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    font-size: 10px;
    text-align: center;
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    padding: 10px;
    line-height: 1.2;
    z-index: 5;
    pointer-events: auto;
	opacity: 1 !important;
}

.head span {
    font-size: 12px;
}

/* Torso */
.participant-torso {
    position: absolute;
    width: 55px;
    height: 80px;
    background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
    border-radius: 22px 22px 15px 15px;
    box-shadow: 0 3px 12px rgba(0,0,0,0.15);
    top: -2px;
	left: 50%;
    transform: translateX(-50%);
    z-index: 8;
}

/* Højre arm hierarki */
.skulder_translate_right {
    position: absolute;
    top: 0px;
    left: 62px;
    width: 15px;
    height: 15px;
    background: rgba(59, 130, 246, 0.0);
    z-index: 3;
}

.skulder_translate_right.front-arm {
    z-index: 15;
}

.skulder_rotate_right {
    width: 100%;
    height: 100%;
    background: rgba(239, 68, 68, 0.0);
    transform-origin: center center;
}

.arm_geo_right {
    width: 50px;
    height: 18px;
    background: #f59e0b;
    border-radius: 9px;
    position: relative;
    top: -1px;
    left: -1px;
}

.albue_rotate_right {
    position: relative;
    top: 1px;
    left: 34px;
    width: 15px;
    height: 15px;
    background: rgba(16, 185, 129, 0.0);
    transform-origin: center center;
}

.albue_geo_right {
    position: relative;
    top: -1px;
    left: 1px;
    width: 50px;
    height: 18px;
    background: #f59e0b;
    border-radius: 9px;
    z-index: 4;
}

.albue_geo_right.front {
    z-index: 20 !important;
    position: relative;
}

/* Venstre arm hierarki */
.skulder_translate_left {
    position: absolute;
    top: 0px;
    left: 22px;
    width: 15px;
    height: 15px;
    background: rgba(59, 130, 246, 0.0);
    z-index: 3;
}

.skulder_translate_left.front-arm {
    z-index: 15;
}

.skulder_rotate_left {
    width: 100%;
    height: 100%;
    background: rgba(239, 68, 68, 0.0);
    transform-origin: center center;
}

.arm_geo_left {
    width: 50px;
    height: 18px;
    background: #f59e0b;
    border-radius: 9px;
    position: relative;
    top: -1px;
    left: -34px;
}

.albue_rotate_left {
    position: relative;
    top: 1px;
    left: 0px;
    width: 15px;
    height: 15px;
    background: rgba(16, 185, 129, 0.0);
    transform-origin: center center;
}

.albue_geo_left {
    position: relative;
    top: -1px;
    left: -33px;
    width: 50px;
    height: 18px;
    background: #f59e0b;
    border-radius: 9px;
    z-index: 4;
}

.albue_geo_left.front {
    z-index: 20 !important;
    position: relative;
}

/* Højre ben hierarki */
.hofte_translate_right {
    position: absolute;
    top: 68px;
    left: 58px;
    width: 15px;
    height: 15px;
    background: rgba(59, 130, 246, 0.0);
}

.hofte_rotate_right {
    width: 100%;
    height: 100%;
    background: rgba(239, 68, 68, 0.0);
    transform-origin: center center;
}

.laar_geo_right {
    width: 18px;
    height: 55px;
    background: #f59e0b;
    border-radius: 9px;
    position: relative;
    top: -1px;
    left: -1px;
}

.knae_rotate_right {
    position: relative;
    top: 38px;
    left: 1px;
    width: 15px;
    height: 15px;
    background: rgba(16, 185, 129, 0.0);
    transform-origin: center center;
}

.skinneben_geo_right {
    position: relative;
    top: -1px;
    left: -1px;
    width: 18px;
    height: 50px;
    background: #f59e0b;
    border-radius: 9px;
}

/* Venstre ben hierarki */
.hofte_translate_left {
    position: absolute;
    top: 68px;
    left: 26px;
    width: 15px;
    height: 15px;
    background: rgba(59, 130, 246, 0.0);
}

.hofte_rotate_left {
    width: 100%;
    height: 100%;
    background: rgba(239, 68, 68, 0.0);
    transform-origin: center center;
}

.laar_geo_left {
    width: 18px;
    height: 55px;
    background: #f59e0b;
    border-radius: 9px;
    position: relative;
    top: -1px;
    left: -1px;
}

.knae_rotate_left {
    position: relative;
    top: 38px;
    left: 1px;
    width: 15px;
    height: 15px;
    background: rgba(16, 185, 129, 0.0);
    transform-origin: center center;
}

.skinneben_geo_left {
    position: relative;
    top: -1px;
    left: -1px;
    width: 18px;
    height: 50px;
    background: #f59e0b;
    border-radius: 9px;
}





        
        .participant-circle span[contenteditable] {
            outline: none;
            border-radius: 4px;
            padding: 2px;
            transition: all 0.2s ease;
            cursor: default;
			display: inline-block;  
			max-width: 100%;
			word-break: break-word;
			overflow-wrap: break-word;
			hyphens: auto;
        }
        
        #leftName, #rightName {
            pointer-events: auto;
            font-size: 12px;
            display: inline-block;
            min-width: 20px;
            min-height: 16px;
            padding: 2px 4px;
            word-break: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        
        .participant-circle span[contenteditable]:focus {
            background-color: white;
            color: black;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.5);
        }

        .color-circle-btn {
            position: absolute;
            bottom: 0px;
            right: 0px;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #a855f7;
            border: 2px solid white;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: bold;
            color: white;
            transition: all 0.3s ease;
            z-index: 150;
            opacity: 0;
        }
        
        .color-circle-btn:hover {
            transform: scale(1.1);
            background: #9333ea;
        }
        
        .participant-circle:hover .color-circle-btn {
            display: flex;
            opacity: 1;
        }
        
        .note-circle-btn {
            position: absolute;
            bottom: 0px;
            left: 0px;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #f97316;
            border: 2px solid white;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: bold;
            color: white;
            transition: all 0.3s ease;
            z-index: 150;
            opacity: 0;
        }
        
        .note-circle-btn:hover {
            transform: scale(1.1);
            background: #ea580c;
        }
        
        .participant-circle:hover .note-circle-btn {
            display: flex;
            opacity: 1;
        }
        
        /* Name Editor Overlay Styles */
        .note-overlay {
            position: fixed;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            border: 3px solid rgba(226, 232, 240, 0.5);
            z-index: 10000;
            width: 105px;
            display: none;
        }
        
        .note-overlay.show {
            display: block;
        }
        
        .note-overlay textarea {
            width: 100%;
            height: auto;
            min-height: auto;
            max-height: 110px;
            padding: 6px 10px;
            border: 3px solid rgba(226, 232, 240, 0.8);
            border-radius: 6px;
            font-size: 16px;
            font-family: 'Arial', sans-serif;
            resize: none;
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.9);
            color: #374151;
            line-height: 1.4;
            overflow-y: auto;
            word-break: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        
        .note-overlay textarea:focus {
            outline: none;
            border-color: #f97316;
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.1);
        }
        
.speech-bubble {
    position: absolute;
    background: #93c5fd;
    border-radius: 15px;
    padding: 15px;
    min-width: 180px;
    max-width: 300px;
    max-height: 1000px;
    overflow: visible;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    display: none;
    opacity: 0.0;
    transform: scale(0.85);
    /* transition: transform 0.25s ease-out, opacity 0.25s ease-out; */
	transition: all 0.35s cubic-bezier(0.4, 1.3, 0.7, 1);
    z-index: 9999;
	pointer-events: none; 
}

        
        .speech-bubble::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-style: solid;
            top: 50%;
            transform: translateY(-50%);
        }
		
		.speech-bubble.visible {
			opacity: 1;
			transform: scale(1);
			
		}

        
       .speech-bubble.left {
			background: #93c5fd;
			transform-origin: left center;
		}
        
        .speech-bubble.left::after {
            left: -15px;
            border-width: 15px 15px 15px 0;
            border-color: transparent #93c5fd transparent transparent;
        }
        
        .speech-bubble.right {
			background: #86efac;
			transform-origin: right center;
            z-index: 1;
		}
        
        .speech-bubble.right::after {
            right: -15px;
            border-width: 15px 0 15px 15px;
            border-color: transparent transparent transparent #86efac;
        }
        
        .speech-textarea {
            width: 100%;
            border: none;
            outline: none;
            background: transparent;
            font-size: 14px;
            font-family: inherit;
            color: #1f2937;
            font-weight: 500;
            resize: none;
            overflow: visible;
            min-height: 20px;
            max-height: 1000px;
            line-height: 1.4;
			pointer-events: auto;  
        }
        
        .speech-textarea::placeholder {
            color: #6b7280;
        }
        
        .blinking-dots {
            display: inline-block;
            animation: blink 1.5s infinite;
            color: #6b7280;
            font-size: 14px;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        
        .transcript-section {
            min-height: 500px;
            background: white;
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        
        .dialog-layout {
            position: relative;
            display: block;
            overflow-x: hidden;
            overflow-y: visible;
            width: 100%;
            max-width: 100%;
            max-height: 800px;
        }
        
        .dialog-primary {
            flex: 1;
            width: 100%;
            max-width: 100%;
            padding-right: 0px;
            overflow-x: hidden;
            box-sizing: border-box;
        }
        
        .dialog-collapse-toggle {
            position: absolute;
            left: 0px;
            top: 10px;
            background: #4f46e5;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.3s ease;
            z-index: 100;
            padding: 0;
        }
        
        .dialog-collapse-toggle-bottom {
            top: auto;
            bottom: 10px;
        }
        
        .dialog-collapse-toggle:hover {
            background: #4338ca;
            transform: scale(1.1);
        }
        
        .dialog-history-sidebar {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 240px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 18px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            box-shadow: 0 20px 40px rgba(15, 23, 42, 0.18);
            z-index: 5;
        }
        
        .dialog-history-sidebar.collapsed {
            transform: translateX(215px);
        }
        
        .dialog-history-header {
            background: #e2e8f0;
            padding: 14px 16px 14px 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-weight: 600;
            color: #374151;
            position: relative;
            flex-shrink: 0;
        }
        
        .dialog-history-sidebar.collapsed .dialog-history-header {
            justify-content: center;
        }
        
        .dialog-history-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            height: 100%;
        }
        
        .dialog-history-navigation {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0px 12px 0px 12px;
            background: #e2e8f0;
            border-bottom: 1px solid #d1d5db;
            flex-shrink: 0;
        }
        
        .dialog-nav-btn-group {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            justify-content: space-between;
        }
        
        .dialog-nav-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: white;
            cursor: pointer;
            font-size: 0;
            position: relative;
            transition: all 0.2s ease;
            padding: 0;
        }
        
        .dialog-nav-btn::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        #dialogHistoryNewer::before {
            border-bottom: 12px solid #111827;
        }
        
        #dialogHistoryOlder::before {
            border-top: 12px solid #111827;
        }
        
        .dialog-nav-btn:hover {
            background: #f3f4f6;
        }
        
        .dialog-nav-btn:disabled {
            background: #d1d5db;
            cursor: not-allowed;
        }
        
        .dialog-history-list {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 12px;
            overflow-y: auto;
            background: white;
        }
        
        .dialog-history-item {
            width: 100%;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 10px 12px;
            background: #ffffff;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            text-align: left;
            position: relative;
            touch-action: manipulation;
        }
        
        .dialog-history-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(15, 23, 42, 0.12);
            border-color: #cbd5f5;
        }
        
        .dialog-history-item.active {
            box-shadow: 0 10px 24px rgba(15, 23, 42, 0.25);
        }
        
        .dialog-history-item-title {
            display: flex;
            align-items: center;
            padding: 2px 12px;
            border-radius: 999px;
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 6px;
            max-width: 100%;
            overflow: hidden;
        }

        .dialog-history-item-title-input {
            width: 100%;
            flex: 1;
            border: none;
            background: transparent;
            outline: none;
            font: inherit;
            font-weight: 600;
            color: #ffffff;
            padding: 0;
            margin: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Make it clear when title is editable on active item */
        .dialog-history-item.active .dialog-history-item-title-input {
            padding: 2px 12px;
            margin: -2px -12px;
            cursor: text;
            transition: background 0.15s ease, box-shadow 0.15s ease;
            white-space: normal;
            border-radius: 999px;
        }
        
        .dialog-history-item.active .dialog-history-item-title-input:hover,
        .dialog-history-item.active .dialog-history-item-title-input:focus {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5);
        }
        
        /* Non-active items look read-only */
        .dialog-history-item .dialog-history-item-title-input[readonly] {
            cursor: default;
            opacity: 0.95;
        }
        
        .dialog-history-item-meta {
            display: flex;
            flex-direction: column;
            font-size: 16px;
            opacity: 0.85;
            gap: 4px;
        }
        
        .dialog-history-item-meta-line {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        
        .dialog-history-item-time,
        .dialog-history-item-messages,
        .dialog-history-item-participants {
            white-space: nowrap;
        }
        
        .dialog-history-empty {
            font-size: 13px;
            color: #9ca3af;
            font-style: italic;
        }

        .dialog-history-item-delete {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: none;
            background: #ef4444;
            color: #ffffff;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            padding: 0;
            z-index: 10;
            pointer-events: none;
        }

        .dialog-history-item:hover .dialog-history-item-delete,
        .dialog-history-item.active .dialog-history-item-delete {
            opacity: 1;
            pointer-events: auto;
        }

        .dialog-history-item-delete:hover {
            background: #dc2626;
            transform: scale(1.05);
        }

        .dialog-history-item-color-btn {
            position: absolute;
            top: 6px;
            right: 32px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: none;
            background: #e5e7eb;
            color: #374151;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            z-index: 10;
            pointer-events: none;
        }

        .dialog-history-item:hover .dialog-history-item-color-btn,
        .dialog-history-item.active .dialog-history-item-color-btn {
            opacity: 1;
            pointer-events: auto;
        }

        .dialog-history-item-color-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(15, 23, 42, 0.2);
        }
        
        /* Samling Manager Overlay (from opstilling_01.html) */
        .samling-manager-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 5000;
        }
        
        .samling-manager-overlay.show {
            display: flex;
        }
        
        .samling-manager-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.45);
            backdrop-filter: blur(4px);
        }
        
        .samling-manager-panel {
            position: relative;
            width: min(520px, 90vw);
            max-height: 80vh;
            background: #ffffff;
            border-radius: 18px;
            box-shadow: 0 25px 60px rgba(15, 23, 42, 0.25);
            padding: 24px 28px;
            display: flex;
            flex-direction: column;
            gap: 18px;
            z-index: 1;
        }
        
        .samling-manager-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        
        .samling-manager-header h2 {
            font-size: 1.25rem;
            color: #111827;
        }
        
        .samling-manager-close {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 10px;
            background: #e2e8f0;
            color: #1f2937;
            font-size: 18px;
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s ease;
        }
        
        .samling-manager-close:hover {
            background: #cbd5f5;
            transform: scale(1.05);
        }
        
        .samling-manager-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            padding-right: 6px;
        }
        
        .samling-manager-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
        }
        
        .samling-name-btn {
            flex: 1;
            border: none;
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 16px;
            font-weight: 600;
            text-align: left;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            color: #1f2937;
        }
        
        .samling-name-input {
            flex: 1;
            border-radius: 10px;
            border: 1px solid #cbd5f5;
            padding: 10px 14px;
            font-size: 16px;
            font-weight: 600;
            transition: box-shadow 0.2s ease;
            color: #1f2937;
            background: #f8fafc;
        }
        
        .samling-name-input:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.18);
        }
        
        .samling-name-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 18px rgba(15, 23, 42, 0.18);
        }
        
        .samling-item-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .samling-action-btn {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            border: none;
            color: #ffffff;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .samling-action-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(15, 23, 42, 0.18);
        }
        
        .samling-action-btn.delete {
            background: linear-gradient(135deg, #f87171 0%, #ef4444 100%);
        }
        
        .samling-action-btn.color {
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
        }
        
        .samling-manager-divider {
            height: 1px;
            background: #e2e8f0;
            margin: 4px 0;
        }
        
        .samling-manager-new {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
        }
        
        .samling-manager-new input {
            flex: 1;
            border: none;
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 16px;
            font-weight: 600;
            color: #1f2937;
            background: #f8fafc;
            box-shadow: 0 0 0 1px rgba(99, 102, 241, 0.18);
            transition: box-shadow 0.2s ease, transform 0.2s ease;
        }
        
        .samling-manager-new input:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.18);
            transform: translateY(-1px);
        }
        
        .samling-manager-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .samling-color-select {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            color: #ffffff;
        }
        
        .samling-color-select:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(99, 102, 241, 0.25);
        }
        
        .samling-color-select span[aria-hidden="true"] {
            color: inherit;
            font-weight: 700;
            font-size: 16px;
        }
        
        .samling-manager-new .samling-create-btn {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
            color: white;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .samling-manager-new .samling-create-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.25);
        }
        
        .samling-color-picker-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(15, 23, 42, 0.35);
            z-index: 5001;
        }
        
        .samling-color-picker-modal.show {
            display: flex;
        }
        
        .samling-color-picker {
            width: calc(32px * 6 + 8px * 5 + 16px * 2);
            background: #ffffff;
            border-radius: 14px;
            padding: 16px;
            box-shadow: 0 18px 45px rgba(15, 23, 42, 0.25);
            border: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .samling-color-grid {
            display: grid;
            grid-template-columns: repeat(6, 32px);
            gap: 8px;
            justify-content: center;
        }
        
        .samling-color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 1px solid rgba(15, 23, 42, 0.08);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .samling-color-swatch:hover {
            transform: scale(1.08);
            box-shadow: 0 6px 14px rgba(15, 23, 42, 0.2);
        }
        
        /* History Item Color Picker */
        .history-color-picker-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(15, 23, 42, 0.35);
            z-index: 5001;
        }

        .history-color-picker-modal.show {
            display: flex;
        }

        .history-color-picker {
            width: calc(32px * 6 + 8px * 5 + 16px * 2);
            background: #ffffff;
            border-radius: 14px;
            padding: 16px;
            box-shadow: 0 18px 45px rgba(15, 23, 42, 0.25);
            border: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .history-color-picker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-color-picker-header h3 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: #1f2937;
        }

        .history-color-grid {
            display: grid;
            grid-template-columns: repeat(6, 32px);
            gap: 8px;
            justify-content: center;
        }

        .history-color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 1px solid rgba(15, 23, 42, 0.08);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .history-color-swatch:hover {
            transform: scale(1.08);
            box-shadow: 0 6px 14px rgba(15, 23, 42, 0.2);
        }

        .history-remove-color-btn {
            padding: 8px 16px;
            background: #f3f4f6;
            color: #6b7280;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .history-remove-color-btn:hover {
            background: #e5e7eb;
            color: #374151;
        }
        
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        .transcript-header {
            background: #f1f5f9;
            padding: 10px 20px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .transcript-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 15px 50px;
            background: #fafafa;
			min-height: 400px;
        }
        
        .message-left {
            background: #e3f2fd;
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 15px;
            position: relative;
            max-width: 60%;
            margin-right: auto;
        }
        
        .message-right {
            background: #e8f5e8;
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 15px;
            position: relative;
            max-width: 60%;
            margin-left: auto;
        }
        
        .speaker {
            font-weight: bold;
            font-size: 12px;
            color: #374151;
            margin-bottom: 4px;
            position: relative;
        }
        
        .timestamp {
            position: absolute;
            right: 0;
            top: 0;
            font-size: 10px;
            color: #9ca3af;
            font-weight: normal;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
            white-space: nowrap;
        }
        
        .speaker:hover .timestamp {
            opacity: 1;
        }
        
        .text {
            color: #4b5563;
            font-size: 14px;
            line-height: 1.4;
            cursor: text;
            padding: 4px;
            border-radius: 4px;
            border: 1px solid transparent;
            transition: all 0.2s ease;
        }
        
        .text:hover {
            background: white;
            border-color: #d1d5db;
        }
        
        .text:focus {
            outline: none;
            background: white;
            border-color: #3b82f6;
        }
        
        .delete-circle {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ef4444;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            display: none;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }
        
        .delete-circle:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        .message-left:hover .delete-circle,
        .message-right:hover .delete-circle {
            display: flex;
        }
        
        .empty {
            text-align: center;
            color: #9ca3af;
            font-style: italic;
            padding: 30px;
        }
        
        .status {
            text-align: center;
            color: #6b7280;
            font-size: 12px;
            padding: 5px;
        }


        /* Color Picker Styles */
        .color-picker-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }
        
        .color-picker-modal.show {
            display: flex;
        }
        
        .picker {
            width: 224px;
            background: #ffffff;
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border: 1px solid #e2e8f0;
        }
        
        .swatch {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            border: 1px solid rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .swatch:hover {
            transform: scale(1.2);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 10;
        }
        
        .color-grid {
            display: grid;
            grid-template-columns: repeat(12, 15px);
            grid-template-rows: repeat(14, 15px);
            gap: 2px;
            background: transparent;
        }
        
        .swatch:focus {
            outline: 2px solid #4f46e5;
            outline-offset: 1px;
        }
        
		/* Pose Picker Styles */
.pose-picker-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: transparent;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 3000;
}

.pose-picker-modal.show {
    display: flex;
}

.pose-picker {
    width: 280px;
    background: #ffffff;
    padding: 15px;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    border: 1px solid #e2e8f0;
}

.pose-mirror-section {
    text-align: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #e2e8f0;
}

.pose-mirror-label {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    font-size: 14px;
    font-weight: 500;
    color: #374151;
    cursor: pointer;
}

.pose-mirror-label input[type="checkbox"] {
    width: 16px;
    height: 16px;
    transform: scale(1.2);
}

.pose-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
}

.pose-button {
    padding: 8px 12px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    background: white;
    color: #374151;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
}

.pose-button:hover {
    border-color: #3b82f6;
    background: #f0f9ff;
    color: #1d4ed8;
}

.pose-button.active {
    border-color: #3b82f6;
    background: #3b82f6;
    color: white;
}
		
#leftPoseBtn, #rightPoseBtn {
    position: absolute;
    bottom: 0px;
    right: 0px;
    width: 25px;
    height: 25px;
    border-radius: 50%;
    background: #06b6d4;
    border: 2px solid white;
    cursor: pointer;
    display: none;
    align-items: center;
    justify-content: center;
    font-size: 9px;
    font-weight: bold;
    color: white;
    transition: all 0.3s ease;
    z-index: 150;
    opacity: 0;
    transform: translate(0px, -25px);
}

#leftPoseBtn:hover, #rightPoseBtn:hover {
    transform: translate(0px, -25px) scale(1.1);
    background: #0891b2;
}	
		
.left-participant-circle:hover #leftPoseBtn,
.left-participant-circle:hover #leftColorBtn,
.right-participant-circle:hover #rightPoseBtn,
.right-participant-circle:hover #rightColorBtn,
.participant-circle:hover #leftPoseBtn,
.participant-circle:hover #leftColorBtn,
.participant-circle:hover #rightPoseBtn,
.participant-circle:hover #rightColorBtn {
    display: flex !important;
    opacity: 1;
}		

/* Mini action controls (two small C buttons) */
.mini-controls-wrapper {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 200;
}

.mini-controls {
    display: flex;
    align-items: center;
    gap: 12px;
}

.mini-c-btn {
    min-width: 32px;
    height: 32px;
    border-radius: 0;
    border: 2px solid white;
    color: white;
    font-size: 12px;
    font-weight: bold;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    transition: all 0.2s ease;
}

.mini-c-btn:hover {
    transform: translateY(-1px);
    filter: brightness(1.05);
}
		
		
    
    /* Touch devices adjustments */
    @media (hover: none) and (pointer: coarse) {
        body { padding: 0px; }
        .header { padding: 5px; }
        .header h1 { font-size: 2.0em; margin-bottom: 0; }
        .dialog-container { border-radius: 20px; }
        .controls-bar { padding: 8px 12px; gap: 10px; }
        .participant-dropdown { font-size: 13px; padding: 6px 10px; border-radius: 8px; }
        .btn { padding: 6px 12px; font-size: 13px; border-radius: 8px; }
    }
    </style>
</head>
<body>
    <div class="dialog-container">
        <div class="header">
            <div class="nav-controls">
                <button class="nav-toggle-btn" onclick="toggleNavBox()" title="Navigation">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <div class="nav-box" id="navBox">
                    <a href="opstilling_01.html" class="nav-button">Opstilling</a>
                    <a href="dialog_01.html" class="nav-button">Dialog</a>
                    <a href="compare_01.html" class="nav-button">Ligheder</a>
                    <a href="bodymap_01.html" class="nav-button">BodyMap</a>
                    <a href="logbog_01.html" class="nav-button">Logbog</a>
                    <a href="checkin.html" class="nav-button nav-checkin">Check in</a>
                </div>
            </div>
            <h1>Dialog</h1>
        </div>
        
        
        <div class="controls-bar">
            <div class="controls-divider"></div>
            
            <div class="dropdown-group">
                <select class="participant-dropdown" id="leftDropdown"></select>
            </div>
            
            <div class="dropdown-group">
                <select class="participant-dropdown" id="rightDropdown"></select>
            </div>
            
            <div class="controls-divider"></div>
            
            <button class="btn new-dialog-btn" id="newDialogBtn">Ny Dialog</button>
            <button class="btn start-btn" id="startBtn" disabled>Start Dialog</button>
            <button class="btn continue-btn" id="continueBtn" disabled>Fortsæt</button>
            <button class="btn play-btn" id="playBtn" disabled>Afspil</button>
            <button class="btn pause-btn" id="pauseBtn" disabled style="display: none;">Pause</button>
            <button class="btn step-btn" id="nextBtn" disabled>Næste</button>
            <button class="btn" id="copyBtn" disabled style="background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%); color: white;">Kopier</button>
            <button class="btn clear-btn" id="clearBtn">Ryd Alt</button>
        </div>
        
        <div class="status" id="status">Vælg to dele og start dialog</div>
        
        <div class="participants-section">
            <div class="participants-container">
			
                <div class="participant">
                    <div class="participant-circle" id="leftCircle" style="display: none;">
					<button class="color-circle-btn" id="leftPoseBtn" title="Skift pose">P</button>
					<button class="color-circle-btn" id="leftColorBtn" title="Skift farve">C</button>
					<button class="note-circle-btn" id="leftNoteBtn" title="Rediger navn">N</button>
					
					<div class="participant-body">
						<div class="head">
							<span id="leftName"></span>
						</div>
							<div class="participant-torso"></div>
							
							<!-- Venstre arm hierarki -->
							<div class="skulder_translate_left">
								<div class="skulder_rotate_left">
									<div class="arm_geo_left">
										<div class="albue_rotate_left">
											<div class="albue_geo_left"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Højre arm hierarki -->
							<div class="skulder_translate_right">
								<div class="skulder_rotate_right">
									<div class="arm_geo_right">
										<div class="albue_rotate_right">
											<div class="albue_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Venstre ben hierarki -->
							<div class="hofte_translate_left">
								<div class="hofte_rotate_left">
									<div class="laar_geo_left">
										<div class="knae_rotate_left">
											<div class="skinneben_geo_left"></div>
										</div>
									</div>
								</div>
							</div>

							<!-- Højre ben hierarki -->
							<div class="hofte_translate_right">
								<div class="hofte_rotate_right">
									<div class="laar_geo_right">
										<div class="knae_rotate_right">
											<div class="skinneben_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
						</div>
						
						
						
					</div>
					<div class="speech-bubble left" id="leftBubble">
							<textarea class="speech-textarea" id="leftTextarea" placeholder="Skriv besked..."></textarea>
							<span class="blinking-dots" id="leftDots">...</span>
						</div>
                </div>
                
                <div class="participant">
                    <div class="participant-circle" id="rightCircle" style="display: none;">
						<button class="color-circle-btn" id="rightPoseBtn" title="Skift pose">P</button>
						<button class="color-circle-btn" id="rightColorBtn" title="Skift farve">C</button>
						<button class="note-circle-btn" id="rightNoteBtn" title="Rediger navn">N</button>
						
						<div class="participant-body">
							<div class="head">
								<span id="rightName"></span>
							</div>
							<div class="participant-torso"></div>
							
							<!-- Venstre arm hierarki -->
							<div class="skulder_translate_left">
								<div class="skulder_rotate_left">
									<div class="arm_geo_left">
										<div class="albue_rotate_left">
											<div class="albue_geo_left"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Højre arm hierarki -->
							<div class="skulder_translate_right">
								<div class="skulder_rotate_right">
									<div class="arm_geo_right">
										<div class="albue_rotate_right">
											<div class="albue_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Venstre ben hierarki -->
							<div class="hofte_translate_left">
								<div class="hofte_rotate_left">
									<div class="laar_geo_left">
										<div class="knae_rotate_left">
											<div class="skinneben_geo_left"></div>
										</div>
									</div>
								</div>
							</div>

							<!-- Højre ben hierarki -->
							<div class="hofte_translate_right">
								<div class="hofte_rotate_right">
									<div class="laar_geo_right">
										<div class="knae_rotate_right">
											<div class="skinneben_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
						</div>
						
						
					</div>
					<div class="speech-bubble right" id="rightBubble">
							<textarea class="speech-textarea" id="rightTextarea" placeholder="Skriv besked..."></textarea>
							<span class="blinking-dots" id="rightDots">...</span>
						</div>
                </div>
                
                <div class="mini-controls-wrapper" id="miniControlsWrapper" style="display: none;">
                    <div class="mini-controls">
                        <button class="mini-c-btn" id="leftMiniC">C</button>
                        <button class="mini-c-btn" id="rightMiniC">C</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="dialog-layout">
            <div class="dialog-primary">
                <div class="transcript-section">
                    <div class="transcript-header">
                        <h3 style="color: #475569; font-size: 16px;">Dialog transskript</h3>
                    </div>
                    <div class="transcript-content" id="transcriptContent">
                        <div class="empty">
                            <h4 style="margin-bottom: 15px; color: #374151;">Sådan bruger du Dialog systemet:</h4>
                            <p style="margin-bottom: 12px; text-align: left;"><strong>1. Vælg dele:</strong> Brug dropdown-menuerne til at vælge to indre dele der skal tale sammen.</p>
                            <p style="margin-bottom: 12px; text-align: left;"><strong>2. Start dialog:</strong> Klik "Ny Dialog" for at begynde samtalen.</p>
                            <p style="margin-bottom: 12px; text-align: left;"><strong>3. Skriv beskeder:</strong> En speech bubble vises ved den aktive del. Skriv din besked og tryk Enter for at skifte til den anden del.</p>
                            <p style="margin-bottom: 12px; text-align: left;"><strong>4. Afspil dialog:</strong> Brug "Afspil" for automatisk gennemgang eller "Næste" for manuel kontrol.</p>
                            <p style="margin-bottom: 12px; text-align: left;"><strong>5. Fortsæt dialog:</strong> Efter pause eller afspilning kan du fortsætte med at tilføje nye beskeder via "Fortsæt Dialog".</p>
                            <p style="margin-bottom: 12px; text-align: left;"><strong>6. Rediger beskeder:</strong> Beskeder kan redigeres i transskriptet ved at klikke på dem.</p>
                            <p style="margin-top: 15px; font-style: italic; color: #6b7280;">Du kan bruge det til en samtale med en indre del eller til at øve dig på en svær samtale.</p>
                        </div>
                    </div>
                </div>
            </div>
            <aside class="dialog-history-sidebar" id="dialogHistorySidebar">
                <div class="dialog-history-header">
                    <button class="dialog-collapse-toggle" onclick="toggleDialogHistorySidebar()" title="Fold historik">></button>
                </div>
                <div class="dialog-history-content">
                    <div class="dialog-history-navigation">
                        <div class="dialog-nav-btn-group">
                            <button type="button" class="dialog-nav-btn" id="dialogHistoryNewer" onclick="navigateDialogHistory(-1)" title="Nyere"></button>
                            <button type="button" class="dialog-nav-btn" id="dialogHistoryOlder" onclick="navigateDialogHistory(1)" title="Ældre"></button>
                        </div>
                    </div>
                    <div class="dialog-history-list" id="dialogHistoryList"></div>
                </div>
                <button class="dialog-collapse-toggle dialog-collapse-toggle-bottom" onclick="toggleDialogHistorySidebar()" title="Fold historik">></button>
            </aside>
        </div>
    </div>

    <!-- Color Picker Modal -->
    <div class="color-picker-modal" id="colorPickerModal">
        <div class="picker">
            <div class="color-grid" id="colorGrid"></div>
        </div>
    </div>
	
	<!-- Pose Picker Modal -->
	<div class="pose-picker-modal" id="posePickerModal">
		<div class="pose-picker">
			<div class="pose-mirror-section">
				<label class="pose-mirror-label">
					<input type="checkbox" id="posePickerMirror" onchange="togglePosePickerMirror()">
					<span>Spejl</span>
				</label>
			</div>
			<div class="pose-grid" id="poseGrid"></div>
		</div>
	</div>
	
	<!-- Note Overlay -->
	<div class="note-overlay" id="noteOverlay">
		<textarea id="noteTextarea" placeholder="Navn..." maxlength="24"></textarea>
	</div>
	
	<!-- History Item Color Picker Modal -->
	<div class="history-color-picker-modal" id="historyColorPickerModal">
		<div class="history-color-picker">
			<div class="history-color-picker-header">
				<h3>Vælg farve</h3>
			</div>
			<div class="history-color-grid" id="historyColorGrid"></div>
			<button class="history-remove-color-btn" id="historyRemoveColorBtn">Fjern farve</button>
		</div>
	</div>
	
	

    <script src="coaching_engine.js"></script>
    <script src="coaching_overlay_complete.js"></script>
    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCl6ZYtkfYx3kFF9329eGpeazsmJAPMKzA",
            authDomain: "relationer-fe5fe.firebaseapp.com",
            projectId: "relationer-fe5fe",
            storageBucket: "relationer-fe5fe.firebasestorage.app",
            messagingSenderId: "156720560629",
            appId: "1:156720560629:web:1a138e4e89f02a131f88bc",
            measurementId: "G-K5W7J8JHZG"
        };
        
        // Initialize Firebase
        let auth = null;
        let db = null;
        let currentUser = null;
        
        // Global cache of all user-related Firestore data (shared via window)
        // {
        //   bodymapData,
        //   dialogData,
        //   opstillingData,
        //   compareData,
        //   logbogData,
        //   forside_checkin_data
        // }
        window.allUserData = window.allUserData || null;
        window.allDataLoadingPromise = window.allDataLoadingPromise || null;
        
        // Flags for race condition protection
        
        // Initialize Firebase immediately (before DOM is ready) for faster auth state detection
        try {
            firebase.initializeApp(firebaseConfig);
            auth = firebase.auth();
            db = firebase.firestore();
        } catch (error) {
            console.error('Firebase initialization error:', error);
        }
        
		let currentPosePart = null;
        let dialogActive = false;
        let currentSpeaker = 'left';
        let transcript = [];
        let lastSpeaker = null;
        let currentIndex = 0;
        let isAutoPlaying = false;
        let autoTimeout = null;
        let leftColor = null;
        let rightColor = null;
        let leftLightColor = null;
        let rightLightColor = null;
const DIALOG_STORAGE_KEY = 'dialogData';
const DIALOG_COACHING_KEY = 'dialogCoachingData';
const DIALOG_HISTORY_COLLAPSED_KEY = 'dialog_historySidebarCollapsed';
let dialogHistoryCollapsed = true; // Default to collapsed
        let activeDialogId = null; // Used in legacy functions and writeDialogData
        
        // New dialogData structure (flat, no collections)
        let DialogData = null; // { version, updated, activeDialogId, dialogs: [...] }
        
        // Color presets for collections (from opstilling)
        const DIALOG_COLLECTION_COLOR_PRESETS = [
            '#ef4444', '#f97316', '#fbbf24', '#10b981', '#14b8a6', '#0ea5e9',
            '#3b82f6', '#6366f1', '#a855f7', '#ec4899', '#f472b6', '#94a3b8'
        ];
        
        // Standard farve for alle history items (dialogs)
        const DEFAULT_HISTORY_COLOR = '#b8735e'; // Varm rødlig brun som standard
        
        // Color presets for history items
        const HISTORY_COLOR_PRESETS = [
            '#ef4444', '#f97316', '#fbbf24', '#10b981', '#14b8a6', '#0ea5e9',
            '#3b82f6', '#6366f1', '#a855f7', '#ec4899', '#f472b6', '#94a3b8'
        ];
        
        let historyColorPickerTarget = null; // { dialogId } for the target dialog
        let historyColorPickerModal = null;
        let historyColorPickerGrid = null;
        
        // Check auth state - this should run before DOMContentLoaded loads data
        let authStateReady = false;
        let authStateResolver = null;
        const authStatePromise = new Promise(resolve => {
            authStateResolver = resolve;
        });
        
        if (auth) {
            // Set up auth state listener immediately - Firebase usually resolves auth state very quickly
            auth.onAuthStateChanged(user => {
                currentUser = user;
                
                // Mark auth as ready and resolve promise immediately
                if (!authStateReady) {
                    authStateReady = true;
                    if (authStateResolver) {
                        authStateResolver();
                        authStateResolver = null;
                    }
                }
            });
        }
        
        let currentColorTarget = null;
        let currentColorSide = null;
		
		let isLoadingDialog = false;
        let newlyCreatedTitleInput = null;
        
        const partsData = {
    lav_ny_left: { 
        name: "Lav Ny Del", 
        keywords: ["", "", "", "", "", ""], 
        color: "#10b981",
        pose: "",
        mirror: false
    },
    lav_ny_right: { 
        name: "Lav Ny Del", 
        keywords: ["", "", "", "", "", ""], 
        color: "#3b82f6",
        pose: "",
        mirror: false
    },
    beskytter: { 
        name: "Beskytteren", 
        keywords: ["Sikkerhed", "Kontrol", "Forsigtig", "Ansvarlig", "", ""], 
        color: "#fbbf24",
        pose: "stærk",
        mirror: false
    },
    kritiker: { 
        name: "Den Kritiske", 
        keywords: ["Perfektionisme", "Standards", "Aldrig godt nok", "Selvkritik", "", ""], 
        color: "#ef4444",
        pose: "vred",
        mirror: false
    },
    manager: { 
        name: "Manager-delen", 
        keywords: ["Produktivitet", "Mål", "Effektivitet", "Præstation", "", ""], 
        color: "#3b82f6",
        pose: "tænke",
        mirror: false
    },
    perfektionist: { 
        name: "Den Perfektionistiske", 
        keywords: ["Fejlfri", "Detaljer", "Aldrig færdig", "Høje krav", "", ""], 
        color: "#8b5cf6",
        pose: "lukket",
        mirror: false
    },
    barn: { 
        name: "Det Indre Barn", 
        keywords: ["Leg", "Spontanitet", "Nysgerrig", "Kreativ", "", ""], 
        color: "#10b981",
        pose: "Leg",
        mirror: false
    },
    saaret: { 
        name: "Det Sårede Barn", 
        keywords: ["Sorg", "Ensomhed", "Har brug for trøst", "Bange", "", ""], 
        color: "#06b6d4",
        pose: "trist",
        mirror: false
    },
    kreativ: { 
        name: "Den Kreative", 
        keywords: ["Fantasi", "Inspiration", "Fri udtryk", "Innovation", "", ""], 
        color: "#f97316",
        pose: "flyver",
        mirror: false
    },
    glade: { 
        name: "Den Glade", 
        keywords: ["Optimisme", "Humor", "Positivitet", "Smil", "", ""], 
        color: "#84cc16",
        pose: "hej",
        mirror: false
    }
};
		
        // Firestore functions
        // Load all user data (cached) for this page, shared via window
        async function loadAllUserData(forceRefresh = false) {
            if (!currentUser || !db) return null;
            
            if (!forceRefresh && window.allUserData) {
                return window.allUserData;
            }
            
            if (!forceRefresh && window.allDataLoadingPromise) {
                return window.allDataLoadingPromise;
            }
            
            window.allDataLoadingPromise = (async () => {
                try {
                    const userDocRef = db.collection('users').doc(currentUser.uid);
                    const doc = await userDocRef.get();
                    const raw = doc.exists ? (doc.data() || {}) : {};
                    const data = {
                        bodymapData: raw.bodymapData || null,
                        dialogData: raw.dialogData || null,
                        opstillingData: raw.opstillingData || null,
                        compareData: raw.compareData || null,
                        logbogData: Array.isArray(raw.logbogData) ? raw.logbogData : null,
                        forside_checkin_data: Array.isArray(raw.forside_checkin_data) ? raw.forside_checkin_data : null
                    };
                    window.allUserData = data;
                    return data;
                } catch (error) {
                    console.error('[LOAD] Error loading all user data in dialog_01.html:', error);
                    window.allUserData = null;
                    return null;
                } finally {
                    window.allDataLoadingPromise = null;
                }
            })();
            
            return window.allDataLoadingPromise;
        }
        
        // Load data from Firestore via cached user document
        async function loadDialogDataFromFirestore() {
            if (!currentUser || !db) return null;
            
            try {
                const data = await loadAllUserData();
                return data ? data.dialogData || null : null;
            } catch (error) {
                console.error('[LOAD] Error:', error);
                return null;
            }
        }
        
        async function saveDialogDataToFirestore() {
            if (!currentUser || !db) return false;
            if (!DialogData) return false;
            
            DialogData.updated = new Date().toISOString();
            
            try {
                const userDocRef = db.collection('users').doc(currentUser.uid);
                await userDocRef.set({
                    dialogData: DialogData,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
                
                // Refresh cache after successful save so other pages can reuse updated data
                await loadAllUserData(true);
                
                console.log('[SAVE] Success');
                return true;
            } catch (error) {
                console.error('[SAVE] Error:', error);
                return false;
            }
        }
        
        async function loadDialogData() {
            if (!currentUser || !db) {
                console.error('[LOAD] User not logged in - cannot load data');
                return null;
            }
            
            const firestoreData = await loadDialogDataFromFirestore();
            return firestoreData;
        }
        
        function migrateLegacyDialogData(legacyData) {
            // Migrate old sessions structure to new flat dialogs structure
            const sessions = Array.isArray(legacyData.sessions) ? legacyData.sessions : [];
            const dialogs = [];
            
            if (sessions.length > 0) {
                sessions.forEach((session, idx) => {
                    const dialog = {
                        id: idx + 1,
                        name: session.name || `Dialog ${idx + 1}`,
                        color: DEFAULT_HISTORY_COLOR,
                        timestamp: session.createdAt || session.updatedAt || new Date().toISOString(),
                        updated: session.updatedAt || session.createdAt || new Date().toISOString(),
                        participants: session.participants || {
                            left: { name: 'Venstre del', color: '#3b82f6', pose: '', flipped: false, keywords: ['', '', '', '', '', ''] },
                            right: { name: 'Højre del', color: '#ef4444', pose: '', flipped: false, keywords: ['', '', '', '', '', ''] }
                        },
                        messages: Array.isArray(session.messages) ? session.messages : []
                    };
                    dialogs.push(dialog);
                });
            }
            
            return {
                version: '2.0',
                updated: new Date().toISOString(),
                activeDialogId: dialogs.length > 0 ? 1 : null,
                dialogs: dialogs
            };
        }
        
        async function saveDialogDataToLocalStorage() {
            
            if (!currentUser || !db) {
                console.error('[SAVE] User not logged in - cannot save data');
                return false;
            }
            
            try {
                if (!DialogData) return false;
                await saveDialogDataToFirestore();
                return true;
            } catch (error) {
                console.error('[SAVE] Error saving to Firestore:', error);
                return false;
            }
        }
        
        function ensureDefaultDialogData() {
            let dataWasCreated = false;
            
            if (!DialogData || !Array.isArray(DialogData.dialogs)) {
                DialogData = {
                    version: '2.0',
                    updated: new Date().toISOString(),
                    activeDialogId: 1,
                    dialogs: []
                };
                dataWasCreated = true;
            }
            if (!Array.isArray(DialogData.dialogs) || DialogData.dialogs.length === 0) {
                const now = new Date().toISOString();
                const initialDialog = {
                    id: 1,
                    name: 'Dialog 1',
                    color: DEFAULT_HISTORY_COLOR,
                    timestamp: now,
                    updated: now,
                    participants: {
                        left: { name: 'Venstre', color: '#3b82f6', pose: 'standard', flipped: false, keywords: ['', '', '', '', '', ''] },
                        right: { name: 'Højre', color: '#ef4444', pose: 'standard', flipped: false, keywords: ['', '', '', '', '', ''] }
                    },
                    messages: []
                };
                DialogData.dialogs = [initialDialog];
                DialogData.activeDialogId = 1;
                dataWasCreated = true;
            }
            // Ensure all dialogs have timestamps and colors
            DialogData.dialogs.forEach((dialog, idx) => {
                if (!dialog.timestamp) {
                    dialog.timestamp = dialog.updated || new Date().toISOString();
                }
                if (!dialog.updated) {
                    dialog.updated = dialog.timestamp || new Date().toISOString();
                }
                if (!dialog.color) {
                    dialog.color = DEFAULT_HISTORY_COLOR;
                }
            });
            // Only save if we actually created new data structure AND not during initial load
            // This prevents overwriting existing Firestore data with empty data on page load
            // Don't save during data creation - it's a load operation
        }
        
        function getActiveDialog() {
            if (!DialogData || !Array.isArray(DialogData.dialogs)) return null;
            return DialogData.dialogs.find(d => d.id === DialogData.activeDialogId) || DialogData.dialogs[0] || null;
        }
        
        // Legacy functions for backwards compatibility (will be removed later)
        function loadDialogStorage() {
            ensureDefaultDialogData();
            const activeDialog = getActiveDialog();
            return {
                version: '2.0',
                sessions: activeDialog ? [{
                    id: `${DialogData.activeDialogId}`,
                    name: activeDialog.name,
                    createdAt: activeDialog.timestamp,
                    updatedAt: activeDialog.updated,
                    participants: activeDialog.participants,
                    messages: activeDialog.messages
                }] : [],
                lastCoachingUpdate: null,
                activeDialogId: activeDialog ? `${DialogData.activeDialogId}` : null
            };
        }
        
        async function saveDialogStorage(data) {
            // This function is kept for backwards compatibility but will be replaced
            // by direct DialogData manipulation
            ensureDefaultDialogData();
            await saveDialogDataToLocalStorage();
        }
        
        // Helper functions for colors (from opstilling)
        function hexToRgba(hex, alpha) {
            if (!hex) {
                return `rgba(232, 220, 198, ${alpha})`;
            }
            const normalized = hex.replace('#', '');
            if (normalized.length === 3) {
                const r = parseInt(normalized[0] + normalized[0], 16);
                const g = parseInt(normalized[1] + normalized[1], 16);
                const b = parseInt(normalized[2] + normalized[2], 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
            if (normalized.length === 6) {
                const r = parseInt(normalized.substring(0, 2), 16);
                const g = parseInt(normalized.substring(2, 4), 16);
                const b = parseInt(normalized.substring(4, 6), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
            return hex;
        }
        
        function lightenHex(hex, amount = 0.5) {
            if (!hex) return '#f2e7d2';
            const normalized = hex.replace('#', '');
            const expand = normalized.length === 3
                ? normalized.split('').map(ch => ch + ch).join('')
                : normalized.padEnd(6, '0');
            const r = parseInt(expand.substring(0, 2), 16);
            const g = parseInt(expand.substring(2, 4), 16);
            const b = parseInt(expand.substring(4, 6), 16);
            const clampAmount = Math.max(0, Math.min(1, amount));
            const newR = Math.round(r + (255 - r) * clampAmount);
            const newG = Math.round(g + (255 - g) * clampAmount);
            const newB = Math.round(b + (255 - b) * clampAmount);
            return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
        }

        function darkenHex(hex, amount = 0.5) {
            if (!hex) return '#000000';
            const normalized = hex.replace('#', '');
            const expand = normalized.length === 3
                ? normalized.split('').map(ch => ch + ch).join('')
                : normalized.padEnd(6, '0');
            const r = parseInt(expand.substring(0, 2), 16);
            const g = parseInt(expand.substring(2, 4), 16);
            const b = parseInt(expand.substring(4, 6), 16);
            const clampAmount = Math.max(0, Math.min(1, amount));
            const newR = Math.round(r * (1 - clampAmount));
            const newG = Math.round(g * (1 - clampAmount));
            const newB = Math.round(b * (1 - clampAmount));
            return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
        }
        
        /**
         * Læser brugerens timezone fra userData (indexuserData i localStorage)
         * Fallback hierarki:
         * 1. userData.timezone
         * 2. Browser's timezone (Intl API)
         * 3. 'Europe/Copenhagen' (default)
         */
        function getUserTimezone() {
            try {
                // 1. Prøv at læse fra userData
                const userDataStr = localStorage.getItem('indexuserData');
                if (userDataStr) {
                    const userData = JSON.parse(userDataStr);
                    if (userData.timezone && isValidTimezone(userData.timezone)) {
                        return userData.timezone;
                    }
                }
            } catch (e) {
                console.warn('Kunne ikke læse timezone fra userData:', e);
            }
            
            // 2. Fallback til browser's timezone
            try {
                const browserTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                if (browserTimezone && isValidTimezone(browserTimezone)) {
                    return browserTimezone;
                }
            } catch (e) {
                console.warn('Kunne ikke læse browser timezone:', e);
            }
            
            // 3. Ultimate fallback
            return 'Europe/Copenhagen';
        }

        /**
         * Validerer om en timezone string er gyldig
         */
        function isValidTimezone(tz) {
            if (!tz || typeof tz !== 'string') return false;
            try {
                Intl.DateTimeFormat(undefined, { timeZone: tz });
                return true;
            } catch (e) {
                return false;
            }
        }

        /**
         * Konverterer Date eller ISO string til lokal dato (YYYY-MM-DD) i brugerens timezone
         * @param {Date|string|null} date - Dato at konvertere (default: nu)
         * @returns {string|null} - Dato i YYYY-MM-DD format eller null ved fejl
         */
        function getLocalDateKey(date = null) {
            const d = date ? new Date(date) : new Date();
            if (isNaN(d.getTime())) return null;
            
            const timezone = getUserTimezone();
            
            // Konverter til lokal tid ved at formatere med da-DK locale og brugerens timezone
            const localDateStr = d.toLocaleDateString('da-DK', {
                timeZone: timezone,
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });
            
            // Format er "DD.MM.YYYY" - konverter til "YYYY-MM-DD"
            const [day, month, year] = localDateStr.split('.');
            return `${year}-${month}-${day}`;
        }

        function formatDkDate(dateStr) {
            // Convert ISO date to DD-MM-YYYY for display
            if (typeof dateStr === 'string' && /^\d{4}-\d{2}-\d{2}/.test(dateStr)) {
                const datePart = dateStr.split('T')[0];
                const [y, m, d] = datePart.split('-');
                return `${d}-${m}-${y}`;
            }
            return dateStr || '';
        }
        
        // ===== HISTORY SIDEBAR FUNCTIONS (from opstilling_01.html) =====
        
        function getAllDialogsSorted() {
            if (!DialogData || !Array.isArray(DialogData.dialogs)) return [];
            const allDialogs = [];
            DialogData.dialogs.forEach(dialog => {
                // Ensure dialog has timestamp
                if (!dialog.timestamp && dialog.updated) {
                    dialog.timestamp = dialog.updated;
                } else if (!dialog.timestamp) {
                    dialog.timestamp = new Date().toISOString();
                }
                allDialogs.push({
                    dialog,
                    timestamp: new Date(dialog.timestamp)
                });
            });
            // Sort by timestamp descending (newest first)
            allDialogs.sort((a, b) => b.timestamp - a.timestamp);
            return allDialogs;
        }
        
        function getFilteredSortedDialogs() {
            return getAllDialogsSorted();
        }
        
        
        function renderDialogHistory() {
            const listEl = document.getElementById('dialogHistoryList');
            if (!listEl) return;
            listEl.innerHTML = '';
            
            if (!DialogData || !Array.isArray(DialogData.dialogs)) {
                ensureDefaultDialogData();
            }
            
            const sortedEntries = getFilteredSortedDialogs();
            const activeDialog = getActiveDialog();
            
            if (sortedEntries.length === 0) {
                listEl.innerHTML = '<div class="dialog-history-empty">Ingen gemte dialoger endnu.</div>';
                DialogData.activeDialogId = null;
                updateDialogHistoryNavState([]);
                return;
            }
            
            sortedEntries.forEach(({ dialog }) => {
                    const item = document.createElement('div');
                const isActive = dialog.id === DialogData.activeDialogId;
                item.className = `dialog-history-item ${isActive ? 'active' : ''}`;
                
                // Set simple background color (not based on collection)
                const dialogColor = dialog.color || DEFAULT_HISTORY_COLOR;
                const baseBackground = lightenHex(dialogColor, isActive ? 0.35 : 0.7);
                item.style.backgroundColor = baseBackground;
                item.style.color = '#1f2937';
                item.style.borderColor = isActive ? dialogColor : 'transparent';
                
                const titleDisplay = dialog.name || 'Dialog';
                const titleWrapper = document.createElement('div');
                titleWrapper.className = 'dialog-history-item-title';
                // Set background color to dialog's custom color or default
                titleWrapper.style.backgroundColor = dialogColor;
                titleWrapper.style.color = '#ffffff';
                titleWrapper.innerHTML = `<input type="text" class="dialog-history-item-title-input" value="${titleDisplay}" data-dialog-id="${dialog.id}" title="Rediger titel">`;
                item.appendChild(titleWrapper);
                
                const metaWrapper = document.createElement('div');
                metaWrapper.className = 'dialog-history-item-meta';
                const timestamp = dialog.timestamp || dialog.updated || new Date().toISOString();
                const dateObj = new Date(timestamp);
                const dateDk = formatDkDate(dateObj.toISOString().split('T')[0]);
                const timeStr = dateObj.toTimeString().split(' ')[0].substring(0, 5);
                const messagesCount = Array.isArray(dialog.messages) ? dialog.messages.length : 0;
                let leftName = dialog.participants?.left?.name || 'Venstre';
                let rightName = dialog.participants?.right?.name || 'Højre';
                
                // Truncate each name to 10 characters with ".."
                const truncateName = (name) => {
                    if (name.length > 10) {
                        return name.substring(0, 10) + '..';
                    }
                    return name;
                };
                leftName = truncateName(leftName);
                rightName = truncateName(rightName);
                
                const firstLine = document.createElement('div');
                firstLine.className = 'dialog-history-item-meta-line';
                firstLine.innerHTML = `
                    <span class="dialog-history-item-time">${dateDk} ${timeStr}</span>
                    <span class="dialog-history-item-messages">besk: ${messagesCount}</span>
                `;
                
                const secondLine = document.createElement('div');
                secondLine.className = 'dialog-history-item-meta-line';
                secondLine.innerHTML = `
                    <span class="dialog-history-item-participants">${leftName} & ${rightName}</span>
                `;
                
                metaWrapper.appendChild(firstLine);
                metaWrapper.appendChild(secondLine);
                item.appendChild(metaWrapper);

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'dialog-history-item-delete';
                deleteBtn.dataset.dialogId = dialog.id;
                deleteBtn.textContent = '×';
                item.appendChild(deleteBtn);
                
                // Color button
                const colorBtn = document.createElement('button');
                colorBtn.className = 'dialog-history-item-color-btn';
                colorBtn.textContent = 'C';
                colorBtn.title = 'Vælg farve';
                colorBtn.dataset.dialogId = dialog.id;
                // Set button color to show current color (lighter version)
                const btnColor = dialog.color || DEFAULT_HISTORY_COLOR;
                colorBtn.style.background = lightenHex(btnColor, 0.3);
                colorBtn.style.color = '#ffffff';
                
                // Color button handlers - both touch and click for mobile compatibility
                const handleColorClick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    openHistoryColorPicker(dialog.id);
                };
                colorBtn.addEventListener('click', handleColorClick);
                colorBtn.addEventListener('touchend', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    handleColorClick(e);
                }, { passive: false });
                
                item.appendChild(colorBtn);
                
                // Shared handler function for both touch and click
                const handleItemActivation = async (e) => {
                    // Don't handle clicks on delete button or color button
                    if (e.target.classList.contains('dialog-history-item-delete')) return;
                    if (e.target.classList.contains('dialog-history-item-color-btn')) return;
                    
                    // Check current active state
                    const currentlyActive = dialog.id === DialogData.activeDialogId;
                    
                    // If clicking directly on input field of active item, allow normal editing
                    if (e.target.classList.contains('dialog-history-item-title-input') && currentlyActive) {
                        // Let the input handle focus normally
                        return;
                    }
                    
                    // First click/touch: If item is not active, activate it
                    if (!currentlyActive) {
                        e.preventDefault();
                        e.stopPropagation();
                        DialogData.activeDialogId = dialog.id;
                        loadSavedDialogFromNewStructure(dialog);
                        renderDialogHistory();
                    } else {
                        // Second click/touch: Item is already active, focus the input field
                        e.preventDefault();
                        e.stopPropagation();
                        const titleInput = item.querySelector('.dialog-history-item-title-input');
                        if (titleInput) {
                            // Use setTimeout to ensure focus happens after any re-renders
                            setTimeout(() => {
                                titleInput.focus();
                                titleInput.select(); // Select all text for easy editing
                            }, 0);
                        }
                    }
                };
                
                // Handle touch events for mobile (fires immediately, no delay)
                let touchStartTime = 0;
                item.addEventListener('touchstart', (e) => {
                    touchStartTime = Date.now();
                    // Mark that we're handling touch (stored on item to persist across handlers)
                    item.dataset.touchHandled = 'false';
                }, { passive: true });
                
                item.addEventListener('touchend', (e) => {
                    // Don't handle touches on delete button or textarea - they have their own handlers
                    if (e.target.classList.contains('dialog-history-item-delete') || 
                        e.target.classList.contains('dialog-history-item-title-input')) {
                        return;
                    }
                    
                    // Only handle if it was a quick tap (not a scroll)
                    const touchDuration = Date.now() - touchStartTime;
                    if (touchDuration < 300) { // Quick tap, not a scroll
                        handleItemActivation(e);
                        // Mark that touch was handled to prevent click event
                        item.dataset.touchHandled = 'true';
                        // Prevent click event from firing after touch
                        e.preventDefault();
                    }
                });
                
                // Handle click events for desktop (only if touch wasn't handled)
                item.addEventListener('click', (e) => {
                    // Check if touch was already handled (on mobile)
                    if (item.dataset.touchHandled !== 'true') {
                        handleItemActivation(e);
                    }
                    // Reset for next interaction
                    item.dataset.touchHandled = 'false';
                });
                
                const titleInput = item.querySelector('.dialog-history-item-title-input');
                if (!isActive) {
                    titleInput.readOnly = true;
                    titleInput.tabIndex = -1;
                } else {
                    titleInput.readOnly = false;
                    titleInput.tabIndex = 0;
                }
                titleInput.addEventListener('focus', (e) => {
                    // Check current active state
                    const currentlyActive = dialog.id === DialogData.activeDialogId;
                    // If not active, prevent focus and activate item instead
                    if (!currentlyActive) {
                        e.preventDefault();
                        e.stopPropagation();
                        // Activate the item (first click behavior)
                        DialogData.activeDialogId = dialog.id;
                        loadSavedDialogFromNewStructure(dialog);
                        renderDialogHistory();
                        return;
                    }
                    // If active, allow normal focus for editing
                });
                titleInput.addEventListener('change', async (e) => {
                    const dialogId = parseFloat(e.target.dataset.dialogId);
                    const dialog = DialogData.dialogs.find(d => d.id === dialogId);
                    if (dialog) {
                        dialog.name = e.target.value;
                        await saveDialogDataToLocalStorage();
                        renderDialogHistory();
                    }
                });
                
                // Delete button handlers - both touch and click for mobile compatibility
                const handleDelete = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    const dialogId = parseFloat(deleteBtn.dataset.dialogId);
                    deleteDialogFromNewStructure(dialogId);
                };
                
                deleteBtn.addEventListener('click', handleDelete);
                deleteBtn.addEventListener('touchend', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    handleDelete(e);
                }, { passive: false });
                
                // Textarea touch handler for mobile - allow direct focus on touch
                titleInput.addEventListener('touchend', (e) => {
                    // Check current active state
                    const currentlyActive = dialog.id === DialogData.activeDialogId;
                    
                    if (!currentlyActive) {
                        // If not active, activate first, then focus
                        e.stopPropagation();
                        e.preventDefault();
                        DialogData.activeDialogId = dialog.id;
                        loadSavedDialogFromNewStructure(dialog);
                        renderDialogHistory();
                        // After re-render, focus the input
                        setTimeout(() => {
                            const newInput = document.querySelector(`.dialog-history-item-title-input[data-dialog-id="${dialog.id}"]`);
                            if (newInput) {
                                newInput.focus();
                            }
                        }, 100);
                    } else {
                        // If already active, just allow normal focus
                        // Don't prevent default - let the input handle it
                    }
                }, { passive: false });
                
                listEl.appendChild(item);
            });
            
            const navUp = document.getElementById('dialogHistoryNewer');
            const navDown = document.getElementById('dialogHistoryOlder');
            const canNavigate = sortedEntries.length > 1;
            if (navUp) navUp.disabled = !canNavigate;
            if (navDown) navDown.disabled = !canNavigate;
        }
        
        function updateDialogHistoryNavState(sortedEntries) {
            const newerBtn = document.getElementById('dialogHistoryNewer');
            const olderBtn = document.getElementById('dialogHistoryOlder');
            if (!newerBtn || !olderBtn) return;
            
            if (!sortedEntries || !sortedEntries.length) {
                newerBtn.disabled = true;
                olderBtn.disabled = true;
                return;
            }
            
            const currentPos = sortedEntries.findIndex(entry => 
                entry.dialog.id === DialogData.activeDialogId && 
                entry.collection.id === DialogData.activeCollectionId
            );
            const atNewest = currentPos <= 0;
            const atOldest = currentPos === sortedEntries.length - 1 || currentPos === -1;
            
            newerBtn.disabled = atNewest;
            olderBtn.disabled = atOldest;
        }
        
        function updateDialogHistoryToggleUI() {
            const sidebar = document.getElementById('dialogHistorySidebar');
            const layout = document.querySelector('.dialog-layout');
            if (!sidebar || !layout) return;
            
            sidebar.classList.toggle('collapsed', dialogHistoryCollapsed);
            layout.classList.toggle('history-collapsed', dialogHistoryCollapsed);
            
            const toggles = sidebar.querySelectorAll('.dialog-collapse-toggle');
            toggles.forEach(toggle => {
                toggle.textContent = dialogHistoryCollapsed ? '<' : '>';
            });
        }
        
        function toggleDialogHistorySidebar() {
            setDialogHistoryCollapsed(!dialogHistoryCollapsed);
        }
        
        function setDialogHistoryCollapsed(value) {
            dialogHistoryCollapsed = !!value;
            updateDialogHistoryToggleUI();
            try {
                localStorage.setItem(DIALOG_HISTORY_COLLAPSED_KEY, String(dialogHistoryCollapsed));
            } catch (_) {}
        }
        
        async function navigateDialogHistory(direction) {
            const sortedEntries = getFilteredSortedDialogs();
            if (!sortedEntries.length) return;
            
            const currentPos = sortedEntries.findIndex(entry => 
                entry.dialog.id === DialogData.activeDialogId
            );
            const nextIndex = currentPos === -1
                ? (direction > 0 ? 0 : sortedEntries.length - 1)
                : (direction < 0 ? Math.max(0, currentPos - 1) : Math.min(sortedEntries.length - 1, currentPos + 1));
            if (nextIndex !== currentPos && sortedEntries[nextIndex]) {
                const targetEntry = sortedEntries[nextIndex];
                DialogData.activeDialogId = targetEntry.dialog.id;
                // Only switch active dialog/collection – don't save when navigating history
                loadSavedDialogFromNewStructure(targetEntry.dialog);
                renderDialogHistory();
            }
        }
        
        function loadSavedDialogFromNewStructure(dialog) {
            if (!dialog) return;
            isLoadingDialog = true;
            try {
                // Clear UI without deleting the dialog
                if (autoTimeout) clearTimeout(autoTimeout);
                dialogActive = false;
                isAutoPlaying = false;
                transcript = [];
                lastSpeaker = null;
                hideAllSpeechBubbles();
                const transcriptContent = document.getElementById('transcriptContent');
                if (transcriptContent) {
                    transcriptContent.innerHTML = '<div class="empty">Alle beskeder slettet</div>';
                }
                const leftTextarea = document.getElementById('leftTextarea');
                const rightTextarea = document.getElementById('rightTextarea');
                if (leftTextarea) leftTextarea.value = '';
                if (rightTextarea) rightTextarea.value = '';
                updateAllButtons();
                
                const participants = dialog.participants || {};
                const leftParticipant = participants.left || { name: 'Venstre', color: '#3b82f6', pose: 'standard', flipped: false, keywords: ['', '', '', '', '', ''] };
                const rightParticipant = participants.right || { name: 'Højre', color: '#ef4444', pose: 'standard', flipped: false, keywords: ['', '', '', '', '', ''] };
                
                applyLoadedDialog(leftParticipant, rightParticipant, dialog.messages || []);
                
                setStatus(`Dialog "${dialog.name}" indlæst.`);
            } finally {
                isLoadingDialog = false;
            }
        }
        
        async function promptCleanupEmptyDialogsOnLoad() {
            try {
                if (!DialogData || !Array.isArray(DialogData.dialogs)) return;
                
                // Collect all empty dialogs (no messages or empty messages array)
                const emptyDialogs = [];
                DialogData.dialogs.forEach(dialog => {
                    const messages = Array.isArray(dialog.messages) ? dialog.messages : [];
                    if (messages.length === 0) {
                        emptyDialogs.push(dialog);
                    }
                });
                
                if (!emptyDialogs.length) return;
                
                // Count total dialogs
                const totalDialogs = DialogData.dialogs.length;
                
                // Do not apply cleanup if there is only one dialog total
                if (totalDialogs <= 1) return;
                
                // Sort empty dialogs by timestamp (newest first), keep the newest empty, delete the rest
                const sortedEmpty = emptyDialogs
                    .slice()
                    .sort((a, b) => {
                        const timestampA = a.timestamp || a.updated || new Date(0).toISOString();
                        const timestampB = b.timestamp || b.updated || new Date(0).toISOString();
                        return new Date(timestampB).getTime() - new Date(timestampA).getTime();
                    });
                
                const toKeep = sortedEmpty[0] ? sortedEmpty[0].id : null;
                const toDelete = sortedEmpty.filter(dialog => dialog.id !== toKeep);
                
                if (!toDelete.length) return;
                
                // Ensure we will not remove to below one total dialog
                if ((totalDialogs - toDelete.length) < 1) return;
                
                const shouldDelete = confirm('Der findes dialoger uden beskeder. Vil du slette dem?');
                if (!shouldDelete) return;
                
                // Remove empty dialogs
                const idsToDelete = toDelete.map(d => d.id);
                DialogData.dialogs = DialogData.dialogs.filter(d => !idsToDelete.includes(d.id));
                
                // If we deleted the active dialog, switch to another one
                const activeDialog = getActiveDialog();
                if (!activeDialog && DialogData.dialogs.length > 0) {
                    DialogData.activeDialogId = DialogData.dialogs[0].id;
                }
                
                await saveDialogDataToLocalStorage();
            } catch (error) {
                console.error('Fejl i promptCleanupEmptyDialogsOnLoad:', error);
            }
        }
        
        async function deleteDialogFromNewStructure(dialogId) {
            if (!DialogData || !Array.isArray(DialogData.dialogs)) return;
            
            if (DialogData.dialogs.length <= 1) {
                alert('Du kan ikke slette den sidste dialog.');
                return;
            }
            
            if (!confirm('Er du sikker på du vil slette denne dialog?')) {
                return;
            }
            
            DialogData.dialogs = DialogData.dialogs.filter(d => d.id !== dialogId);
            
            if (DialogData.activeDialogId === dialogId) {
                if (DialogData.dialogs.length > 0) {
                    DialogData.activeDialogId = DialogData.dialogs[DialogData.dialogs.length - 1].id;
                }
            }
            
            const activeDialog = getActiveDialog();
            if (activeDialog) {
                loadSavedDialogFromNewStructure(activeDialog);
            }
            await saveDialogDataToLocalStorage();
            renderDialogHistory();
        }
        
        // ===== HISTORY COLOR PICKER FUNCTIONS =====
        
        function openHistoryColorPicker(dialogId) {
            if (!historyColorPickerModal) {
                historyColorPickerModal = document.getElementById('historyColorPickerModal');
                historyColorPickerGrid = document.getElementById('historyColorGrid');
            }
            if (!historyColorPickerModal || !historyColorPickerGrid) return;
            
            historyColorPickerTarget = { dialogId };
            buildHistoryColorGrid();
            historyColorPickerModal.classList.add('show');
        }
        
        function closeHistoryColorPicker() {
            historyColorPickerTarget = null;
            if (historyColorPickerModal) {
                historyColorPickerModal.classList.remove('show');
            }
        }
        
        function buildHistoryColorGrid() {
            if (!historyColorPickerGrid) return;
            historyColorPickerGrid.innerHTML = '';
            HISTORY_COLOR_PRESETS.forEach(color => {
                const swatch = document.createElement('button');
                swatch.className = 'history-color-swatch';
                swatch.style.background = color;
                swatch.onclick = () => handleHistoryColorSelected(color);
                historyColorPickerGrid.appendChild(swatch);
            });
        }
        
        async function handleHistoryColorSelected(color) {
            if (!historyColorPickerTarget) return;
            const { dialogId } = historyColorPickerTarget;
            
            // Find and update the dialog
            const dialog = DialogData.dialogs.find(d => d.id === dialogId);
            if (!dialog) return;
            
            dialog.color = color;
            
            // Live-update the UI
            const item = document.querySelector(`.dialog-history-item button[data-dialog-id="${dialogId}"]`)?.closest('.dialog-history-item');
            if (item) {
                // Update item background color
                const isActive = item.classList.contains('active');
                item.style.backgroundColor = lightenHex(color, isActive ? 0.35 : 0.7);
                item.style.borderColor = isActive ? color : 'transparent';
                
                // Update title wrapper
                const titleWrapper = item.querySelector('.dialog-history-item-title');
                if (titleWrapper) {
                    titleWrapper.style.backgroundColor = color;
                }
                
                // Update color button
                const colorBtn = item.querySelector('.dialog-history-item-color-btn');
                if (colorBtn) {
                    colorBtn.style.background = lightenHex(color, 0.3);
                    colorBtn.style.color = '#ffffff';
                }
            }
            
            await saveDialogDataToLocalStorage();
            // Don't close picker - let user select multiple colors or click outside to close
        }
        
        async function removeHistoryColor() {
            if (!historyColorPickerTarget) return;
            const { dialogId } = historyColorPickerTarget;
            
            // Find and update the dialog
            const dialog = DialogData.dialogs.find(d => d.id === dialogId);
            if (!dialog) return;
            
            delete dialog.color;
            
            // Live-update the UI
            const item = document.querySelector(`.dialog-history-item button[data-dialog-id="${dialogId}"]`)?.closest('.dialog-history-item');
            if (item) {
                // Update item background color to default
                const isActive = item.classList.contains('active');
                item.style.backgroundColor = lightenHex(DEFAULT_HISTORY_COLOR, isActive ? 0.35 : 0.7);
                item.style.borderColor = isActive ? DEFAULT_HISTORY_COLOR : 'transparent';
                
                // Update title wrapper
                const titleWrapper = item.querySelector('.dialog-history-item-title');
                if (titleWrapper) {
                    titleWrapper.style.backgroundColor = DEFAULT_HISTORY_COLOR;
                }
                
                // Update color button
                const colorBtn = item.querySelector('.dialog-history-item-color-btn');
                if (colorBtn) {
                    colorBtn.style.background = lightenHex(DEFAULT_HISTORY_COLOR, 0.3);
                    colorBtn.style.color = '#ffffff';
                }
            }
            
            await saveDialogDataToLocalStorage();
            // Don't close picker - let user click outside to close
        }
        
        function getParticipantSnapshot(side) {
            // Check if participant is visible (works for both dropdown selection and "Ny Dialog" case)
            const circle = document.getElementById(side + 'Circle');
            const isVisible = circle && window.getComputedStyle(circle).display !== 'none';
            if (!isVisible) return null;
            
            const dropdown = document.getElementById(side + 'Dropdown');
            const selected = dropdown && dropdown.value ? dropdown.value : null;
            const partInfo = selected && partsData[selected] ? partsData[selected] : null;
            
            // Get name from UI element (this works for both dropdown and "Ny Dialog" cases)
            const nameElement = document.getElementById(side + 'Name');
            let name = nameElement ? nameElement.textContent.trim() : '';
            if (!name && partInfo) {
                name = partInfo.name || '';
            }
            if (!name) {
                // Fallback to lav_ny_left/lav_ny_right if available
                const fallbackKey = side === 'left' ? 'lav_ny_left' : 'lav_ny_right';
                if (partsData[fallbackKey] && partsData[fallbackKey].name) {
                    name = partsData[fallbackKey].name;
                }
            }
            if (!name) {
                name = side === 'left' ? 'Venstre del' : 'Højre del';
            }
            
            // Get color from UI state or partInfo
            const partColor = partInfo && partInfo.color ? partInfo.color : null;
            const defaultColor = side === 'left' ? '#3b82f6' : '#ef4444';
            const color = side === 'left'
                ? (leftColor || partColor || defaultColor)
                : (rightColor || partColor || defaultColor);
            
            // Get keywords from partInfo or fallback
            let keywords = ['', '', '', '', '', ''];
            if (partInfo && Array.isArray(partInfo.keywords)) {
                keywords = partInfo.keywords.slice(0, 6);
            } else {
                const fallbackKey = side === 'left' ? 'lav_ny_left' : 'lav_ny_right';
                if (partsData[fallbackKey] && Array.isArray(partsData[fallbackKey].keywords)) {
                    keywords = partsData[fallbackKey].keywords.slice(0, 6);
                }
            }
            
            const participantNode = circle ? circle.parentElement : null;
            const poseDropdown = document.getElementById(side + 'Pose');
            let poseName = '';
            if (poseDropdown && poseDropdown.value !== '') {
                const poseIdx = parseInt(poseDropdown.value, 10);
                if (!Number.isNaN(poseIdx) && poseLibrary[poseIdx]) {
                    poseName = poseLibrary[poseIdx].name;
                }
            } else if (participantNode && participantNode.hasAttribute('data-pose')) {
                const poseIdx = parseInt(participantNode.getAttribute('data-pose'), 10);
                if (!Number.isNaN(poseIdx) && poseLibrary[poseIdx]) {
                    poseName = poseLibrary[poseIdx].name;
                }
            }
            
            const mirrorCheckbox = document.getElementById(side + 'Mirror');
            const spejl = mirrorCheckbox ? !!mirrorCheckbox.checked : !!(participantNode && participantNode.getAttribute('data-mirror') === 'true');
            
            return {
                name,
                color,
                pose: poseName,
                spejl,
                keywords
            };
        }
        
        function getDefaultParticipant(side) {
            return {
                name: side === 'left' ? 'Venstre del' : 'Højre del',
                color: side === 'left' ? '#3b82f6' : '#ef4444',
                pose: '',
                spejl: false,
                keywords: ['', '', '', '', '', '']
            };
        }

        function enableParticipantNameEditing(side) {
            const nameEl = document.getElementById(side + 'Name');
            if (!nameEl) return;
            // Name is only editable via the "N" button
            nameEl.contentEditable = 'false';
            nameEl.style.cursor = 'default';
        }
        
        async function createNewDialogEntry() {
            ensureDefaultDialogData();
            
            // Find highest dialog ID across all dialogs
            let maxId = 0;
            if (Array.isArray(DialogData.dialogs)) {
                DialogData.dialogs.forEach(d => {
                    if (d.id > maxId) maxId = d.id;
                });
            }
            
            const newId = maxId + 1;
            const dialogName = `Dialog ${newId}`;
            
            // Create new dialog with default participants (venstre and højre)
            const now = new Date().toISOString();
            const defaultLeft = {
                name: 'Venstre',
                color: '#3b82f6',
                pose: 'standard',
                flipped: false,
                keywords: ['', '', '', '', '', '']
            };
            const defaultRight = {
                name: 'Højre',
                color: '#ef4444',
                pose: 'standard',
                flipped: false,
                keywords: ['', '', '', '', '', '']
            };
            
            const newDialog = {
                id: newId,
                name: dialogName,
                color: DEFAULT_HISTORY_COLOR,
                timestamp: now,
                updated: now,
                participants: {
                    left: defaultLeft,
                    right: defaultRight
                },
                messages: []
            };
            
            if (!Array.isArray(DialogData.dialogs)) {
                DialogData.dialogs = [];
            }
        DialogData.dialogs.push(newDialog);
        DialogData.activeDialogId = newId;
        
        // Clear UI without deleting anything
            if (autoTimeout) clearTimeout(autoTimeout);
            dialogActive = false;
            isAutoPlaying = false;
            transcript = [];
            lastSpeaker = null;
            hideAllSpeechBubbles();
            const transcriptContent = document.getElementById('transcriptContent');
            if (transcriptContent) {
                transcriptContent.innerHTML = '<div class="empty">Alle beskeder slettet</div>';
            }
            const leftTextarea = document.getElementById('leftTextarea');
            const rightTextarea = document.getElementById('rightTextarea');
            if (leftTextarea) {
                leftTextarea.value = '';
                leftTextarea.blur();
            }
            if (rightTextarea) rightTextarea.value = '';
            
            // Load the new dialog
            applyLoadedDialog(defaultLeft, defaultRight, []);
            
            resetPose('left');
            resetPose('right');
            dialogActive = false; // Dialog is not started yet, user needs to click "Start Dialog"
            currentSpeaker = 'left';
            renderDialogHistory();
            
            // Make the new history item's name editable and focus it
            requestAnimationFrame(() => {
                const newHistoryInput = document.querySelector(`.dialog-history-item.active input[data-dialog-id="${newId}"]`);
                if (newHistoryInput) {
                    newHistoryInput.readOnly = false;
                    newHistoryInput.focus();
                    newHistoryInput.select();
                }
            });
            
            const leftBubble = document.getElementById('leftBubble');
            const rightBubble = document.getElementById('rightBubble');
            if (leftBubble) {
                leftBubble.style.display = 'none';
                leftBubble.classList.remove('visible');
            }
            if (rightBubble) {
                rightBubble.style.display = 'none';
                rightBubble.classList.remove('visible');
            }
            // Update buttons after a short delay to ensure DOM is updated
            setTimeout(() => {
                updateAllButtons();
            }, 0);
            setStatus('Ny dialog klar.');
        }
        
        async function persistActiveDialogToNewStructure(updateTimestamp = true) {
            if (isLoadingDialog) return;
            if (!DialogData || !DialogData.activeDialogId) return;
            
            const dialog = getActiveDialog();
            if (!dialog) return;
            
            // Update participants
            const leftSnapshot = getParticipantSnapshot('left');
            const rightSnapshot = getParticipantSnapshot('right');
            
            dialog.participants = {
                left: leftSnapshot ? {
                    name: leftSnapshot.name,
                    color: leftSnapshot.color,
                    pose: leftSnapshot.pose || 'standard',
                    flipped: leftSnapshot.spejl || false,
                    keywords: Array.isArray(leftSnapshot.keywords) ? leftSnapshot.keywords.slice(0, 6) : ['', '', '', '', '', '']
                } : {
                    name: 'Venstre',
                    color: '#3b82f6',
                    pose: 'standard',
                    flipped: false,
                    keywords: ['', '', '', '', '', '']
                },
                right: rightSnapshot ? {
                    name: rightSnapshot.name,
                    color: rightSnapshot.color,
                    pose: rightSnapshot.pose || 'standard',
                    flipped: rightSnapshot.spejl || false,
                    keywords: Array.isArray(rightSnapshot.keywords) ? rightSnapshot.keywords.slice(0, 6) : ['', '', '', '', '', '']
                } : {
                    name: 'Højre',
                    color: '#ef4444',
                    pose: 'standard',
                    flipped: false,
                    keywords: ['', '', '', '', '', '']
                }
            };
            
            // Update messages
            dialog.messages = transcript.map(entry => ({
                speaker: entry.speaker,
                message: entry.message,
                side: entry.side,
                timestamp: entry.timestamp || ''
            }));
            
            if (updateTimestamp) {
                dialog.updated = new Date().toISOString();
            }
            
            await saveDialogDataToLocalStorage();
            renderDialogHistory();
        }

        // Legacy function for backwards compatibility
        async function persistActiveDialog(updateTimestamp = true) {
            await persistActiveDialogToNewStructure(updateTimestamp);
        }

        // Legacy function for backwards compatibility
        function loadSavedDialog(sessionId) {
            // Try to parse sessionId as "collectionId-dialogId" format
            if (sessionId && typeof sessionId === 'string' && sessionId.includes('-')) {
                // Legacy sessionId format was "collectionId-dialogId", now just "dialogId"
                const dialogId = parseFloat(sessionId);
                if (!isNaN(dialogId)) {
                    const dialog = DialogData.dialogs.find(d => d.id === dialogId);
                    if (dialog) {
                        DialogData.activeDialogId = dialogId;
                        saveDialogDataToLocalStorage();
                        loadSavedDialogFromNewStructure(dialog);
                        renderDialogHistory();
                        return;
                    }
                }
            }
            
            // Fallback to legacy structure if not found in new structure
            if (!sessionId) return;
            if (isLoadingDialog && sessionId === activeDialogId) return;
            const store = loadDialogStorage();
            const session = store.sessions.find(s => s.id === sessionId);
            if (!session) {
                alert('Kunne ikke finde dialogen.');
                return;
            }
            isLoadingDialog = true;
            try {
                clearAll();
                const participants = session.participants || {};
                const leftParticipant = participants.left || { name: 'Venstre del', color: '#3b82f6', pose: '', spejl: false, keywords: ['', '', '', '', '', ''] };
                const rightParticipant = participants.right || { name: 'Højre del', color: '#ef4444', pose: '', spejl: false, keywords: ['', '', '', '', '', ''] };
                
                applyLoadedDialog(
                    leftParticipant,
                    rightParticipant,
                    session.messages || []
                );
                
                activeDialogId = sessionId;
                renderDialogHistory();
                setStatus(`Dialog "${session.name}" indlæst.`);
            } finally {
                isLoadingDialog = false;
            }
            // Don't save - it's a load operation
        }
		///// animations bibliotek
		
		let animationsLibrary = {};
		
		// Load animations from JSON files - dynamically loads from manifest.json
        async function loadAnimations() {
            // Try to load manifest.json first (most reliable method)
            try {
                const manifestResponse = await fetch('Animations/manifest.json');
                if (manifestResponse.ok) {
                    const manifest = await manifestResponse.json();
                    if (manifest.files && Array.isArray(manifest.files)) {
                        for (const fileName of manifest.files) {
                            try {
                                const fileResponse = await fetch(`Animations/${fileName}`);
                                if (fileResponse.ok) {
                                    const animationData = await fileResponse.json();
                                    const animName = fileName.replace('.json', '');
                                    animationsLibrary[animName] = animationData;
                                }
                            } catch (error) {
                                console.error(`Failed to load animation ${fileName}:`, error);
                            }
                        }
                        return; // Successfully loaded from manifest
                    }
                }
            } catch (error) {
                // Manifest not available, try directory listing
            }
            
            // Fallback: Try directory listing
            try {
                const response = await fetch('Animations/');
                if (response.ok) {
                    const html = await response.text();
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const links = doc.querySelectorAll('a[href$=".json"]');
                    const jsonFiles = Array.from(links)
                        .map(link => link.getAttribute('href'))
                        .filter(file => file !== 'manifest.json'); // Exclude manifest itself
                    
                    if (jsonFiles.length > 0) {
                        for (const fileName of jsonFiles) {
                            try {
                                const fileResponse = await fetch(`Animations/${fileName}`);
                                if (fileResponse.ok) {
                                    const animationData = await fileResponse.json();
                                    const animName = fileName.replace('.json', '');
                                    animationsLibrary[animName] = animationData;
                                }
                            } catch (error) {
                                console.error(`Failed to load animation ${fileName}:`, error);
                            }
                        }
                        return; // Successfully loaded from directory listing
                    }
                }
            } catch (error) {
                // Directory listing not available
            }
        }
		
		
		
		
		
// Pose Library - loaded from external JSON file
let poseLibrary = [];

// Load pose library from external JSON file
async function loadPoseLibrary() {
    try {
        const response = await fetch('Standard_new_poses.json');
        if (response.ok) {
            poseLibrary = await response.json();
            (window.__APP_DEBUG__ && console.log('Loaded pose library with', poseLibrary.length, 'poses'));
        } else {
            console.error('Failed to load pose library');
            // Fallback to basic poses
            poseLibrary = [
                {
                    "name": "standard",
                    "pose": {
                        "translate_x_left": -3,
                        "translate_y_left": 0,
                        "skulder_rot_left": -70,
                        "albue_rot_left": 0,
                        "translate_x": 3,
                        "translate_y": 0,
                        "skulder_rot": 70,
                        "albue_rot": 0,
                        "translate_x_left_leg": 0,
                        "translate_y_left_leg": 0,
                        "hofte_rot_left": 6,
                        "knae_rot_left": 0,
                        "translate_x_right_leg": 0,
                        "translate_y_right_leg": 0,
                        "hofte_rot_right": -6,
                        "knae_rot_right": 0,
                        "left_arm_front": false,
                        "right_arm_front": false,
                        "duration": 0.3
                    }
                }
            ];
        }
    } catch (error) {
        console.error('Error loading pose library:', error);
        // Fallback to basic poses
        poseLibrary = [
            {
                "name": "standard",
                "pose": {
                    "translate_x_left": -3,
                    "translate_y_left": 0,
                    "skulder_rot_left": -70,
                    "albue_rot_left": 0,
                    "translate_x": 3,
                    "translate_y": 0,
                    "skulder_rot": 70,
                    "albue_rot": 0,
                    "translate_x_left_leg": 0,
                    "translate_y_left_leg": 0,
                    "hofte_rot_left": 6,
                    "knae_rot_left": 0,
                    "translate_x_right_leg": 0,
                    "translate_y_right_leg": 0,
                    "hofte_rot_right": -6,
                    "knae_rot_right": 0,
                    "left_arm_front": false,
                    "right_arm_front": false,
                    "duration": 0.3
                }
            }
        ];
    }
}	

function openPosePicker(btn) {
    // Find the participant container (not just the circle)
    const participantCircle = btn.closest('.participant-circle');
    currentPosePart = participantCircle.parentElement; // Dette er .participant div'en
    
    const modal = document.getElementById('posePickerModal');
    const picker = modal.querySelector('.pose-picker');
    
    // Get current pose and mirror from the participant element
    const currentPose = currentPosePart.getAttribute('data-pose') || '';
	const currentMirror = currentPosePart.getAttribute('data-mirror') === 'true';
    
    // Set mirror checkbox in picker
    document.getElementById('posePickerMirror').checked = currentMirror;
    
    // Populate pose grid (this will highlight the current pose)
    populatePoseGrid();
    
    // Show modal and position it
    const btnRect = btn.getBoundingClientRect();
    modal.classList.add('show');
    
    picker.style.position = 'absolute';
    picker.style.left = (btnRect.right + 10) + 'px';
    picker.style.top = (btnRect.top - 20) + 'px';
    
    // Adjust if goes off screen
    const pickerRect = picker.getBoundingClientRect();
    if (pickerRect.right > window.innerWidth) {
        picker.style.left = (btnRect.left - pickerRect.width - 10) + 'px';
    }
    if (pickerRect.bottom > window.innerHeight) {
        picker.style.top = (btnRect.bottom - pickerRect.height - 10) + 'px';
    }
}

function populatePoseGrid() {
    const grid = document.getElementById('poseGrid');
    grid.innerHTML = '';
    
    // Get current pose from the DOM element
    const currentPose = currentPosePart.getAttribute('data-pose') || '';
    const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
    
    // Add all poses from library (including "standard")
    poseLibrary.forEach((pose, index) => {
        const btn = document.createElement('button');
        btn.className = 'pose-button';
        btn.textContent = pose.name;
        btn.onclick = () => selectPose(index);
        
        if (currentPose === index.toString() || (currentPose === '' && index === standardIndex)) {
            btn.classList.add('active');
        }
        
        grid.appendChild(btn);
    });
}

function selectPose(poseIndex) {
    if (!currentPosePart) return;
    
    const mirror = document.getElementById('posePickerMirror').checked;
    
    // Find out which side by checking if it contains leftCircle or rightCircle
    const hasLeftCircle = currentPosePart.querySelector('#leftCircle');
    const side = hasLeftCircle ? 'left' : 'right';
    
    // Use the existing applyPose function from dialog system
    applyPose(side, poseIndex, mirror);
    
    // Update active button
    populatePoseGrid();
}

function togglePosePickerMirror() {
    if (!currentPosePart) return;
    
    // Find out which side by checking if it contains leftCircle or rightCircle
    const hasLeftCircle = currentPosePart.querySelector('#leftCircle');
    const side = hasLeftCircle ? 'left' : 'right';
    
    const posePickerMirrorCheckbox = document.getElementById('posePickerMirror');
    
    const mirror = posePickerMirrorCheckbox.checked;
    
    // Update partsData immediately
    const key = side === 'left' ? 'lav_ny_left' : 'lav_ny_right';
    if (partsData[key]) {
        partsData[key].mirror = mirror;
    }
    
    const currentPoseAttr = currentPosePart.getAttribute('data-pose');
    const poseIndex = currentPoseAttr != null ? currentPoseAttr : '';
    applyPose(side, poseIndex, mirror);
    
    populatePoseGrid();
}

async function closePosePicker() {
    // Save pose and flipped state when overlay closes
    await persistActiveDialogToNewStructure(false);
    document.getElementById('posePickerModal').classList.remove('show');
    currentPosePart = null;
}
	
	
	function runAnimation(side, animName) {
		const animation = animationsLibrary[animName];
		if (!animation || !animation.slides) {
			(window.__APP_DEBUG__ && console.log(`Animation "${animName}" not found`));
			return;
		}
		
		// Add smooth transitions to all animated elements
		const circle = document.getElementById(side + 'Circle');
		const animatedElements = circle.querySelectorAll(
			'.skulder_translate_left, .skulder_rotate_left, .albue_rotate_left, ' +
			'.skulder_translate_right, .skulder_rotate_right, .albue_rotate_right, ' +
			'.hofte_translate_left, .hofte_rotate_left, .knae_rotate_left, ' +
			'.hofte_translate_right, .hofte_rotate_right, .knae_rotate_right'
		);
		
		let slideIndex = 0;
		
		function playNextSlide() {
			if (slideIndex < animation.slides.length) {
				const slide = animation.slides[slideIndex];
				
				// Set transition duration for this slide
				animatedElements.forEach(element => {
					element.style.transition = `transform ${slide.duration}s cubic-bezier(0.25, 0.1, 0.25, 1)`;
				});
				
				applyDirectSlideData(side, slide);
				slideIndex++;
				setTimeout(playNextSlide, slide.duration * 1000);
			} else {
				// Remove transitions when animation is done
				animatedElements.forEach(element => {
					element.style.transition = '';
				});
			}
		}
		
		playNextSlide();
	}

function applyDirectSlideData(side, slideData) {
    // Temporarily set pose dropdowns to empty and apply data directly
    const poseDropdown = document.getElementById(side + 'Pose');
    const currentValue = poseDropdown.value;
    poseDropdown.value = '';
    
    // Apply the transform directly like your applyPose function does
    const fakeEvent = { target: { value: '' } };
    applyPose(side, ''); // Reset first
    
    // Then manually apply all the transforms from slideData
    const circle = document.getElementById(side + 'Circle');
    const skulderLeft = circle.querySelector('.skulder_translate_left');
    const skulderRight = circle.querySelector('.skulder_translate_right');
    const hofteLeft = circle.querySelector('.hofte_translate_left');
    const hofteRight = circle.querySelector('.hofte_translate_right');
    
    if (skulderLeft) {
        skulderLeft.style.transform = `translate(${slideData.translate_x_left || 0}px, ${slideData.translate_y_left || 0}px)`;
        const skulderRotLeft = skulderLeft.querySelector('.skulder_rotate_left');
        if (skulderRotLeft) {
            skulderRotLeft.style.transform = `rotate(${slideData.skulder_rot_left || 0}deg)`;
            const albueRotLeft = skulderRotLeft.querySelector('.albue_rotate_left');
            if (albueRotLeft) {
                albueRotLeft.style.transform = `rotate(${slideData.albue_rot_left || 0}deg)`;
            }
        }
    }
    
    if (skulderRight) {
        skulderRight.style.transform = `translate(${slideData.translate_x || 0}px, ${slideData.translate_y || 0}px)`;
        const skulderRotRight = skulderRight.querySelector('.skulder_rotate_right');
        if (skulderRotRight) {
            skulderRotRight.style.transform = `rotate(${slideData.skulder_rot || 0}deg)`;
            const albueRotRight = skulderRotRight.querySelector('.albue_rotate_right');
            if (albueRotRight) {
                albueRotRight.style.transform = `rotate(${slideData.albue_rot || 0}deg)`;
            }
        }
    }
    
    if (hofteLeft) {
        hofteLeft.style.transform = `translate(${slideData.translate_x_left_leg || 0}px, ${slideData.translate_y_left_leg || 0}px)`;
        const hofteRotLeft = hofteLeft.querySelector('.hofte_rotate_left');
        if (hofteRotLeft) {
            hofteRotLeft.style.transform = `rotate(${slideData.hofte_rot_left || 0}deg)`;
            const knaeRotLeft = hofteRotLeft.querySelector('.knae_rotate_left');
            if (knaeRotLeft) {
                knaeRotLeft.style.transform = `rotate(${slideData.knae_rot_left || 0}deg)`;
            }
        }
    }
    
    if (hofteRight) {
        hofteRight.style.transform = `translate(${slideData.translate_x_right_leg || 0}px, ${slideData.translate_y_right_leg || 0}px)`;
        const hofteRotRight = hofteRight.querySelector('.hofte_rotate_right');
        if (hofteRotRight) {
            hofteRotRight.style.transform = `rotate(${slideData.hofte_rot_right || 0}deg)`;
            const knaeRotRight = hofteRotRight.querySelector('.knae_rotate_right');
            if (knaeRotRight) {
                knaeRotRight.style.transform = `rotate(${slideData.knae_rot_right || 0}deg)`;
            }
        }
    }
    
    // Handle arm layering
    if (slideData.left_arm_front) {
        skulderLeft?.classList.add('front-arm');
    } else {
        skulderLeft?.classList.remove('front-arm');
    }
    
    if (slideData.right_arm_front) {
        skulderRight?.classList.add('front-arm');
    } else {
        skulderRight?.classList.remove('front-arm');
    }
}
	
	
		
		
		
				function initializePoseDropdowns() {
			const leftDropdown = document.getElementById('leftPose');
			const rightDropdown = document.getElementById('rightPose');
			if (!leftDropdown || !rightDropdown) {
				return;
			}
			
			// Clear existing options; if standard exists, we won't add a placeholder
			const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
			if (standardIndex !== -1) {
				leftDropdown.innerHTML = '';
				rightDropdown.innerHTML = '';
			} else {
				leftDropdown.innerHTML = '<option value="">Standard pose</option>';
				rightDropdown.innerHTML = '<option value="">Standard pose</option>';
			}
			
			// Add poses to dropdowns
			poseLibrary.forEach((pose, index) => {
				const leftOption = document.createElement('option');
				leftOption.value = index;
				leftOption.textContent = pose.name;
				leftDropdown.appendChild(leftOption);
				
				const rightOption = document.createElement('option');
				rightOption.value = index;
				rightOption.textContent = pose.name;
				rightDropdown.appendChild(rightOption);
			});
		}
		
		
		function applyPose(side, poseIndex, mirrorOverride) {
    const circle = document.getElementById(side + 'Circle');
    if (!circle) {
        return;
    }

    let resolvedIndex = poseIndex;
    if (resolvedIndex === '' || resolvedIndex === undefined || resolvedIndex === null) {
        const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
        if (standardIndex !== -1) {
            resolvedIndex = standardIndex;
        } else {
            return;
        }
    }
    if (typeof resolvedIndex === 'string') {
        resolvedIndex = parseInt(resolvedIndex, 10);
    }
    if (Number.isNaN(resolvedIndex) || resolvedIndex < 0) {
        return;
    }

    const mirrorCheckbox = document.getElementById(side + 'Mirror');
    const participantNode = circle.parentElement;

    let mirrorActive;
    if (typeof mirrorOverride === 'boolean') {
        mirrorActive = mirrorOverride;
    } else if (mirrorCheckbox) {
        mirrorActive = !!mirrorCheckbox.checked;
    } else if (participantNode && participantNode.hasAttribute('data-mirror')) {
        mirrorActive = participantNode.getAttribute('data-mirror') === 'true';
    } else {
        mirrorActive = false;
    }
    if (mirrorCheckbox) {
        mirrorCheckbox.checked = mirrorActive;
    }

    const pose = poseLibrary[resolvedIndex];
    if (!pose || !pose.pose) return;

    // Add smooth transitions to all animated elements
    const animatedElements = circle.querySelectorAll(
        '.skulder_translate_left, .skulder_rotate_left, .albue_rotate_left, ' +
        '.skulder_translate_right, .skulder_rotate_right, .albue_rotate_right, ' +
        '.hofte_translate_left, .hofte_rotate_left, .knae_rotate_left, ' +
        '.hofte_translate_right, .hofte_rotate_right, .knae_rotate_right'
    );
    
    animatedElements.forEach(element => {
        element.style.transition = 'transform 0.8s cubic-bezier(0.25, 0.1, 0.25, 1)';
    });

    let poseData = pose.pose;

    // If mirror is active, create mirrored version
    if (mirrorActive) {
        poseData = {
            translate_x_left: -(pose.pose.translate_x || 0),
            translate_x: -(pose.pose.translate_x_left || 0),
            translate_y_left: pose.pose.translate_y || 0,
            translate_y: pose.pose.translate_y_left || 0,
            translate_x_left_leg: -(pose.pose.translate_x_right_leg || 0),
            translate_y_left_leg: pose.pose.translate_y_right_leg || 0,
            translate_x_right_leg: -(pose.pose.translate_x_left_leg || 0),
            translate_y_right_leg: pose.pose.translate_y_left_leg || 0,
            skulder_rot_left: -(pose.pose.skulder_rot || 0),
            albue_rot_left: -(pose.pose.albue_rot || 0),
            skulder_rot: -(pose.pose.skulder_rot_left || 0),
            albue_rot: -(pose.pose.albue_rot_left || 0),
            hofte_rot_left: -(pose.pose.hofte_rot_right || 0),
            knae_rot_left: -(pose.pose.knae_rot_right || 0),
            hofte_rot_right: -(pose.pose.hofte_rot_left || 0),
            knae_rot_right: -(pose.pose.knae_rot_left || 0),
            left_arm_front: pose.pose.right_arm_front,
            right_arm_front: pose.pose.left_arm_front,
            duration: pose.pose.duration || 0.3
        };
    }

    const skulderLeft = circle.querySelector('.skulder_translate_left');
    const skulderRight = circle.querySelector('.skulder_translate_right');
    const hofteLeft = circle.querySelector('.hofte_translate_left');
    const hofteRight = circle.querySelector('.hofte_translate_right');
    
    if (skulderLeft) {
        skulderLeft.style.transform = `translate(${poseData.translate_x_left || 0}px, ${poseData.translate_y_left || 0}px)`;
        const skulderRotLeft = skulderLeft.querySelector('.skulder_rotate_left');
        if (skulderRotLeft) {
            skulderRotLeft.style.transform = `rotate(${poseData.skulder_rot_left || 0}deg)`;
            const albueRotLeft = skulderRotLeft.querySelector('.albue_rotate_left');
            if (albueRotLeft) {
                albueRotLeft.style.transform = `rotate(${poseData.albue_rot_left || 0}deg)`;
            }
        }
    }
    
    if (skulderRight) {
        skulderRight.style.transform = `translate(${poseData.translate_x || 0}px, ${poseData.translate_y || 0}px)`;
        const skulderRotRight = skulderRight.querySelector('.skulder_rotate_right');
        if (skulderRotRight) {
            skulderRotRight.style.transform = `rotate(${poseData.skulder_rot || 0}deg)`;
            const albueRotRight = skulderRotRight.querySelector('.albue_rotate_right');
            if (albueRotRight) {
                albueRotRight.style.transform = `rotate(${poseData.albue_rot || 0}deg)`;
            }
        }
    }
    
    if (hofteLeft) {
        hofteLeft.style.transform = `translate(${poseData.translate_x_left_leg || 0}px, ${poseData.translate_y_left_leg || 0}px)`;
        const hofteRotLeft = hofteLeft.querySelector('.hofte_rotate_left');
        if (hofteRotLeft) {
            hofteRotLeft.style.transform = `rotate(${poseData.hofte_rot_left || 0}deg)`;
            const knaeRotLeft = hofteRotLeft.querySelector('.knae_rotate_left');
            if (knaeRotLeft) {
                knaeRotLeft.style.transform = `rotate(${poseData.knae_rot_left || 0}deg)`;
            }
        }
    }
    
    if (hofteRight) {
        hofteRight.style.transform = `translate(${poseData.translate_x_right_leg || 0}px, ${poseData.translate_y_right_leg || 0}px)`;
        const hofteRotRight = hofteRight.querySelector('.hofte_rotate_right');
        if (hofteRotRight) {
            hofteRotRight.style.transform = `rotate(${poseData.hofte_rot_right || 0}deg)`;
            const knaeRotRight = hofteRotRight.querySelector('.knae_rotate_right');
            if (knaeRotRight) {
                knaeRotRight.style.transform = `rotate(${poseData.knae_rot_right || 0}deg)`;
            }
        }
    }
    
    // Handle arm layering
    if (poseData.left_arm_front) {
        skulderLeft.classList.add('front-arm');
    } else {
        skulderLeft.classList.remove('front-arm');
    }
    
    if (poseData.right_arm_front) {
        skulderRight.classList.add('front-arm');
    } else {
        skulderRight.classList.remove('front-arm');
    }
	
	
	const participant = circle.parentElement;
	if (participantNode) {
		participantNode.setAttribute('data-pose', String(resolvedIndex));
		participantNode.setAttribute('data-mirror', mirrorActive ? 'true' : 'false');
	}
    const key = side === 'left' ? 'lav_ny_left' : 'lav_ny_right';
    if (partsData[key]) {
        const poseName = poseLibrary[resolvedIndex] ? poseLibrary[resolvedIndex].name : '';
        partsData[key].pose = poseName;
        partsData[key].mirror = mirrorActive;
    }
    // Don't save here - will be saved when pose picker overlay closes
}


function toggleMirror(side) {
    const circle = document.getElementById(side + 'Circle');
    if (!circle) return;
    const participantNode = circle ? circle.parentElement : null;
    if (!participantNode) return;
    const currentPoseAttr = participantNode.getAttribute('data-pose');
    const poseIndex = currentPoseAttr != null ? currentPoseAttr : '';
    const currentMirror = participantNode.getAttribute('data-mirror') === 'true';
    const newMirror = !currentMirror;
    
    // Update partsData immediately
    const key = side === 'left' ? 'lav_ny_left' : 'lav_ny_right';
    if (partsData[key]) {
        partsData[key].mirror = newMirror;
    }
    
    applyPose(side, poseIndex, newMirror);
    
    // Check if pose picker is open - if so, don't save (will save when overlay closes)
    const posePickerModal = document.getElementById('posePickerModal');
    if (posePickerModal && posePickerModal.classList.contains('show')) {
        // Pose picker is open - don't save, will save when overlay closes
        return;
    }
    
    // Pose picker is not open - this is a direct mirror toggle, save immediately
    persistActiveDialogToNewStructure(false);
}

function resetPose(side) {
    const circle = document.getElementById(side + 'Circle');
    if (!circle) return;
    // If standard exists, apply that index and persist state on participant
    const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
    if (standardIndex !== -1) {
        const participant = circle.parentElement;
        if (participant) {
            participant.setAttribute('data-pose', standardIndex.toString());
            participant.setAttribute('data-mirror', 'false');
        }
        applyPose(side, standardIndex, false);
        return;
    }
    
    // Fallback relaxed default pose
    const relaxedPose = {
        translate_x_left: -3,
        translate_y_left: 0,
        skulder_rot_left: -70,
        albue_rot_left: 0,
        translate_x: 3,
        translate_y: 0,
        skulder_rot: 70,
        albue_rot: 0,
        translate_x_left_leg: 0,
        translate_y_left_leg: 0,
        hofte_rot_left: 6,
        knae_rot_left: 0,
        translate_x_right_leg: 0,
        translate_y_right_leg: 0,
        hofte_rot_right: -6,
        knae_rot_right: 0,
        left_arm_front: false,
        right_arm_front: false
    };
	// Add smooth transitions
    const animatedElements = circle.querySelectorAll(
        '.skulder_translate_left, .skulder_rotate_left, .albue_rotate_left, ' +
        '.skulder_translate_right, .skulder_rotate_right, .albue_rotate_right, ' +
        '.hofte_translate_left, .hofte_rotate_left, .knae_rotate_left, ' +
        '.hofte_translate_right, .hofte_rotate_right, .knae_rotate_right'
    );
    
    const poseData = relaxedPose;
    
    // Apply the relaxed pose using same logic as applyPose
    const skulderLeft = circle.querySelector('.skulder_translate_left');
    const skulderRight = circle.querySelector('.skulder_translate_right');
    const hofteLeft = circle.querySelector('.hofte_translate_left');
    const hofteRight = circle.querySelector('.hofte_translate_right');
    
    if (skulderLeft) {
        skulderLeft.style.transform = `translate(${poseData.translate_x_left}px, ${poseData.translate_y_left}px)`;
        const skulderRotLeft = skulderLeft.querySelector('.skulder_rotate_left');
        if (skulderRotLeft) {
            skulderRotLeft.style.transform = `rotate(${poseData.skulder_rot_left}deg)`;
            const albueRotLeft = skulderRotLeft.querySelector('.albue_rotate_left');
            if (albueRotLeft) {
                albueRotLeft.style.transform = `rotate(${poseData.albue_rot_left}deg)`;
            }
        }
    }
    
    if (skulderRight) {
        skulderRight.style.transform = `translate(${poseData.translate_x}px, ${poseData.translate_y}px)`;
        const skulderRotRight = skulderRight.querySelector('.skulder_rotate_right');
        if (skulderRotRight) {
            skulderRotRight.style.transform = `rotate(${poseData.skulder_rot}deg)`;
            const albueRotRight = skulderRotRight.querySelector('.albue_rotate_right');
            if (albueRotRight) {
                albueRotRight.style.transform = `rotate(${poseData.albue_rot}deg)`;
            }
        }
    }
    
    if (hofteLeft) {
        hofteLeft.style.transform = `translate(${poseData.translate_x_left_leg}px, ${poseData.translate_y_left_leg}px)`;
        const hofteRotLeft = hofteLeft.querySelector('.hofte_rotate_left');
        if (hofteRotLeft) {
            hofteRotLeft.style.transform = `rotate(${poseData.hofte_rot_left}deg)`;
            const knaeRotLeft = hofteRotLeft.querySelector('.knae_rotate_left');
            if (knaeRotLeft) {
                knaeRotLeft.style.transform = `rotate(${poseData.knae_rot_left}deg)`;
            }
        }
    }
    
    if (hofteRight) {
        hofteRight.style.transform = `translate(${poseData.translate_x_right_leg}px, ${poseData.translate_y_right_leg}px)`;
        const hofteRotRight = hofteRight.querySelector('.hofte_rotate_right');
        if (hofteRotRight) {
            hofteRotRight.style.transform = `rotate(${poseData.hofte_rot_right}deg)`;
            const knaeRotRight = hofteRotRight.querySelector('.knae_rotate_right');
            if (knaeRotRight) {
                knaeRotRight.style.transform = `rotate(${poseData.knae_rot_right}deg)`;
            }
        }
    }
    
    // Reset arm layering
    skulderLeft?.classList.remove('front-arm');
    skulderRight?.classList.remove('front-arm');
    persistActiveDialog(false);
}
		
		
		
		function autoResizeTextarea(textarea) {
		textarea.style.height = 'auto';
		textarea.style.height = textarea.scrollHeight + 'px';
		}

		

		function updateBodyColors(side, color) {
			const circle = document.getElementById(side + 'Circle');
			if (!circle) return;
			
			// Convert hex to RGB to darken it
			function hexToRgb(hex) {
				const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
				return result ? {
					r: parseInt(result[1], 16),
					g: parseInt(result[2], 16),
					b: parseInt(result[3], 16)
				} : null;
			}
			
			function darkenColor(hex, factor = 0.8) {
				const rgb = hexToRgb(hex);
				if (!rgb) return hex;
				
				const r = Math.round(rgb.r * factor);
				const g = Math.round(rgb.g * factor);
				const b = Math.round(rgb.b * factor);
				
				return `rgb(${r}, ${g}, ${b})`;
			}
			
			const darkerColor = darkenColor(color, 0.92); // 15% mørkere
			
			const torso = circle.querySelector('.participant-torso');
			const armParts = circle.querySelectorAll('.arm_geo_left, .arm_geo_right, .albue_geo_left, .albue_geo_right');
			const legParts = circle.querySelectorAll('.laar_geo_left, .laar_geo_right, .skinneben_geo_left, .skinneben_geo_right');
			
			// Torso og hoved beholder original farve
			if (torso) torso.style.background = color;
			
			// Arme og ben får mørkere farve
			armParts.forEach(part => part.style.background = darkerColor);
			legParts.forEach(part => part.style.background = darkerColor);
            
		}


        function hslToHex(h,s,l){
            s /= 100; l /= 100;
            const k = n => (n + h/30) % 12;
            const a = s * Math.min(l, 1 - l);
            const f = n => {
                const color = l - a * Math.max(Math.min(k(n) - 3, 9 - k(n), 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }
        
        function openColorPicker(btn, side) {
            currentColorTarget = btn;
            currentColorSide = side;
            
            const modal = document.getElementById('colorPickerModal');
            const picker = modal.querySelector('.picker');
            const btnRect = btn.getBoundingClientRect();
            
            modal.classList.add('show');
            picker.style.position = 'absolute';
            picker.style.left = (btnRect.right + 10) + 'px';
            picker.style.top = (btnRect.top - 20) + 'px';

            const pickerRect = picker.getBoundingClientRect();
            if (pickerRect.right > window.innerWidth) {
                picker.style.left = (btnRect.left - pickerRect.width - 10) + 'px';
            }
            if (pickerRect.bottom > window.innerHeight) {
                picker.style.top = (btnRect.bottom - pickerRect.height - 10) + 'px';
            }
        }
        
        async function closeColorPicker() {
            // Save color when overlay closes
            await persistActiveDialog(false);
            document.getElementById('colorPickerModal').classList.remove('show');
            currentColorTarget = null;
            currentColorSide = null;
        }
        
        function selectColor(hex) {
			if (currentColorSide) {
				if (currentColorSide === 'left') {
					leftColor = hex;
					leftLightColor = lightenColor(hex, 0.6);
				} else {
					rightColor = hex;
					rightLightColor = lightenColor(hex, 0.6);
				}
				
				const circle = document.getElementById(currentColorSide + 'Circle');
				const head = circle.querySelector('.head');
				if (head) {
					head.style.background = `linear-gradient(135deg, ${hex}, ${hex})`;
					
				}
				
				// Update body colors
				updateBodyColors(currentColorSide, hex);
				
				const key = currentColorSide === 'left' ? 'lav_ny_left' : 'lav_ny_right';
				if (partsData[key]) {
					partsData[key].color = hex;
				}

				// Refresh mini C button colors immediately
				const leftBtn = document.getElementById('leftMiniC');
				const rightBtn = document.getElementById('rightMiniC');
				if (leftBtn) leftBtn.style.background = leftColor || '#3b82f6';
				if (rightBtn) rightBtn.style.background = rightColor || '#ef4444';
			}
		}

        let currentNotePart = null;
        
        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            const scrollHeight = textarea.scrollHeight;
            const lineHeight = parseFloat(getComputedStyle(textarea).lineHeight) || 22.4;
            const minHeight = lineHeight + 12;
            textarea.style.height = Math.max(scrollHeight, minHeight) + 'px';
        }
        
        function openNoteOverlay(btn) {
            const participantCircle = btn.closest('.participant-circle');
            const side = participantCircle.id === 'leftCircle' ? 'left' : 'right';
            currentNotePart = { side, circle: participantCircle };
            
            const overlay = document.getElementById('noteOverlay');
            const textarea = document.getElementById('noteTextarea');
            const nameElement = document.getElementById(side + 'Name');
            
            // Load existing name
            const existingName = nameElement ? nameElement.textContent.trim() : '';
            textarea.value = existingName;
            
            // Auto-resize textarea to fit content
            autoResizeTextarea(textarea);
            
            // Position overlay near the button or over the participant circle
            const btnRect = btn.getBoundingClientRect();
            const circleRect = participantCircle.getBoundingClientRect();
            
            let overlayLeft = btnRect.right + 10;
            let overlayTop = btnRect.top;
            
            overlay.classList.add('show');
            const overlayRect = overlay.getBoundingClientRect();
            
            if (overlayLeft + overlayRect.width > window.innerWidth) {
                overlayLeft = circleRect.left + (circleRect.width / 2) - (overlayRect.width / 2);
                overlayTop = circleRect.top + (circleRect.height / 2) - (overlayRect.height / 2);
            }
            
            if (overlayLeft < 10) overlayLeft = 10;
            if (overlayLeft + overlayRect.width > window.innerWidth) overlayLeft = window.innerWidth - overlayRect.width - 10;
            if (overlayTop < 10) overlayTop = 10;
            if (overlayTop + overlayRect.height > window.innerHeight) overlayTop = window.innerHeight - overlayRect.height - 10;
            
            overlay.style.left = overlayLeft + 'px';
            overlay.style.top = overlayTop + 'px';
            
            // Remove previous input listener and add new one
            const newTextarea = textarea.cloneNode(true);
            newTextarea.value = textarea.value;
            textarea.parentNode.replaceChild(newTextarea, textarea);
            newTextarea.addEventListener('input', function() {
                autoResizeTextarea(newTextarea);
            });
            
            // Close overlay on Enter key
            newTextarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    closeNoteOverlay();
                }
            });
            
            setTimeout(() => {
                newTextarea.focus();
                newTextarea.select();
            }, 50);
        }
        
        function closeNoteOverlay() {
            const overlay = document.getElementById('noteOverlay');
            const textarea = document.getElementById('noteTextarea');
            
            if (currentNotePart && currentNotePart.side) {
                const nameText = textarea.value.trim();
                const nameElement = document.getElementById(currentNotePart.side + 'Name');
                if (nameElement) {
                    nameElement.textContent = nameText;
                    
                    // Update partsData
                    const key = currentNotePart.side === 'left' ? 'lav_ny_left' : 'lav_ny_right';
                    if (partsData[key]) {
                        partsData[key].name = nameText;
                    }
                    
                    // Save
                    persistActiveDialog(false);
                }
            }
            
            overlay.classList.remove('show');
            currentNotePart = null;
        }

        function initializeDropdowns() {
            // If shared characters exist, map them into partsData first
            try {
                const raw = localStorage.getItem('relationsSetupData');
                if (raw) {
                    const parsed = JSON.parse(raw);
                    if (parsed && Array.isArray(parsed.characters) && parsed.characters.length > 0) {
                        const sharedParts = {};
                        parsed.characters.forEach((c, idx) => {
                            if (!c || !c.name) return;
                            sharedParts['shared_' + idx] = {
                                name: c.name,
                                keywords: Array.isArray(c.keywords) ? c.keywords.slice(0,6) : ["","","","","",""],
                                color: c.color || '#10b981',
                                pose: c.pose || '',
                                mirror: !!c.mirror
                            };
                        });
                        if (Object.keys(sharedParts).length > 0) {
                            updatePartsData(sharedParts);
                        }
                    }
                }
            } catch(_) {}
            buildDropdownMenus();
        }
        
        function handleStorageUpdate() {
            (window.__APP_DEBUG__ && console.log('Handling storage update...'));
            
            // Store current selections
            const leftDropdown = document.getElementById('leftDropdown');
            const rightDropdown = document.getElementById('rightDropdown');
            const currentLeftSelected = leftDropdown.value;
            const currentRightSelected = rightDropdown.value;
            
            // Reinitialize dropdowns with new data
            initializeDropdowns();
            
            // Check if current selections still exist and are valid (exclude lav_ny_left/lav_ny_right)
            const leftStillValid = currentLeftSelected && currentLeftSelected !== 'lav_ny_left' && partsData[currentLeftSelected];
            const rightStillValid = currentRightSelected && currentRightSelected !== 'lav_ny_right' && partsData[currentRightSelected];
            
            // Restore selections if they're still valid, otherwise clear them
            if (leftStillValid) {
                leftDropdown.value = currentLeftSelected;
            } else {
                leftDropdown.value = '';
                // Hide left participant if it was selected but no longer exists
                if (currentLeftSelected) {
                    document.getElementById('leftCircle').style.display = 'none';
                    document.getElementById('leftColorBtn').style.display = 'none';
                }
            }
            
            if (rightStillValid) {
                rightDropdown.value = currentRightSelected;
            } else {
                rightDropdown.value = '';
                // Hide right participant if it was selected but no longer exists
                if (currentRightSelected) {
                    document.getElementById('rightCircle').style.display = 'none';
                    document.getElementById('rightColorBtn').style.display = 'none';
                }
            }
            
            // Update participant displays if they're still valid
            if (leftStillValid) {
                updateParticipant('left');
            }
            if (rightStillValid) {
                updateParticipant('right');
            }
            
            // Update button states
            updateAllButtons();
            
            // Show status message
            const updatedCount = Object.keys(partsData).length - 2; // Subtract the two "lav_ny" entries
            setStatus(`Dropdowns opdateret - ${updatedCount} karakterer tilgængelige`);
            
            // Log what happened for debugging
            (window.__APP_DEBUG__ && console.log('Storage update handled:', {
                leftWasValid: leftStillValid,
                rightWasValid: rightStillValid,
                leftSelected: leftDropdown.value,
                rightSelected: rightDropdown.value,
                availableCharacters: updatedCount
            }));
        }

        

        function buildDropdownMenus() {
            const leftDropdown = document.getElementById('leftDropdown');
            const rightDropdown = document.getElementById('rightDropdown');
            
            const leftSelected = leftDropdown.value;
            const rightSelected = rightDropdown.value;
            
            (window.__APP_DEBUG__ && console.log('Building dropdown menus, current selections:', leftSelected, rightSelected));
            
            leftDropdown.innerHTML = '';
            rightDropdown.innerHTML = '';
            
            [leftDropdown, rightDropdown].forEach((dropdown, index) => {
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = index === 0 ? 'Venstre deltager...' : 'Højre deltager...';
                dropdown.appendChild(defaultOption);
            });
            
            Object.keys(partsData).forEach(key => {
                if (key === 'lav_ny_left' || key === 'lav_ny_right') return;
                
                const partData = partsData[key];
                
                [leftDropdown, rightDropdown].forEach(dropdown => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = partData.name;
                    dropdown.appendChild(option);
                });
            });
            
            if (leftSelected && partsData[leftSelected] && leftSelected !== 'lav_ny_left') {
                leftDropdown.value = leftSelected;
            }
            if (rightSelected && partsData[rightSelected] && rightSelected !== 'lav_ny_right') {
                rightDropdown.value = rightSelected;
            }
        }

        function updatePartsData(newPartsData) {
            Object.keys(partsData).forEach(key => {
                if (key !== 'lav_ny_left' && key !== 'lav_ny_right') {
                    delete partsData[key];
                }
            });
            
            Object.assign(partsData, newPartsData);
            buildDropdownMenus();
        }

        function lightenColor(color, factor) {
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            
            const newR = Math.round(r + (255 - r) * factor);
            const newG = Math.round(g + (255 - g) * factor);
            const newB = Math.round(b + (255 - b) * factor);
            
            return `rgb(${newR}, ${newG}, ${newB})`;
        }
        
        function updateParticipant(side) {
    const dropdown = document.getElementById(side + 'Dropdown');
    const circle = document.getElementById(side + 'Circle');
    const name = document.getElementById(side + 'Name');
    const colorBtn = document.getElementById(side + 'ColorBtn');
    const selectedValue = dropdown.value;
    
    if (selectedValue && partsData[selectedValue]) {
        const partData = partsData[selectedValue];
        circle.style.display = 'flex';
        
        if (side === 'left') {
            leftColor = partData.color;
            leftLightColor = lightenColor(partData.color, 0.6);
        } else {
            rightColor = partData.color;
            rightLightColor = lightenColor(partData.color, 0.6);
        }
        
        if (selectedValue === 'lav_ny_' + side) {
            if (!name.hasAttribute('data-edited')) {
                name.textContent = partData.name;
            }
        } else {
            name.textContent = partData.name;
            name.removeAttribute('data-edited');
        }
        
        if (partData.keywords && Array.isArray(partData.keywords)) {
            partsData[selectedValue].keywords = partData.keywords.slice(0, 6);
        }
        
        enableParticipantNameEditing(side);
        
        const head = circle.querySelector('.head');
		if (head) {
			head.style.background = `linear-gradient(135deg, ${partData.color}, ${partData.color})`;
			
		}
        colorBtn.style.display = 'flex';
        updateBodyColors(side, partData.color);
        // Keep mini C button colors in sync when selecting parts
        const leftBtn = document.getElementById('leftMiniC');
        const rightBtn = document.getElementById('rightMiniC');
        if (leftBtn) leftBtn.style.background = leftColor || '#3b82f6';
        if (rightBtn) rightBtn.style.background = rightColor || '#ef4444';
        
        // Apply saved pose immediately from partData
        if (partData.pose || partData.mirror !== undefined) {
            applyParticipantPose(side, partData.pose || '', partData.mirror || false);
        } else {
            resetPose(side);
        }
        
        // Play welcome animation after pose is applied
        setTimeout(() => {
            runAnimation(side, 'vinke');
        }, 200);
        
        const bubble = document.getElementById(side + 'Bubble');
        if (!dialogActive) {
            if (bubble) {
                bubble.style.display = 'none';
            }
        }
    } else {
        circle.style.display = 'none';
        
        if (side === 'left') {
            leftColor = null;
            leftLightColor = null;
        } else {
            rightColor = null;
            rightLightColor = null;
        }
        
        const customKey = 'lav_ny_' + side;
        if (partsData[customKey] && Array.isArray(partsData[customKey].keywords)) {
            partsData[customKey].keywords = ['', '', '', '', '', ''];
        }
        
        colorBtn.style.display = 'none';
        
        const bubble = document.getElementById(side + 'Bubble');
        if (bubble) {
            bubble.style.display = 'none';
        }
    }
    updateAllButtons();
    persistActiveDialog();
}
        
        function startDialog() {
            // Check if both participants are visible (this handles both dropdown selection and "Ny Dialog" case)
            const leftCircle = document.getElementById('leftCircle');
            const rightCircle = document.getElementById('rightCircle');
            const leftVisible = leftCircle && window.getComputedStyle(leftCircle).display !== 'none';
            const rightVisible = rightCircle && window.getComputedStyle(rightCircle).display !== 'none';
            
            if (!leftVisible || !rightVisible) {
                setStatus('Vælg begge deltagere først');
                return;
            }
            
            dialogActive = true;
            currentSpeaker = 'left';
            transcript = [];
            currentIndex = 0;
            lastSpeaker = null;
            
            document.getElementById('transcriptContent').innerHTML = '';
            showSpeechBubble('left');
            updateAllButtons();
            setStatus('Dialog startet - skriv beskeder');
            persistActiveDialog();
        }

        // Save mini C button payload to localStorage as "dialogCoachingData"
        async function writeDialogData(side) {
            try {
                const youSide = side;
                const otherSide = side === 'left' ? 'right' : 'left';
                const youNameEl = document.getElementById(youSide + 'Name');
                const otherNameEl = document.getElementById(otherSide + 'Name');
                const youName = youNameEl ? youNameEl.textContent : '';
                const otherName = otherNameEl ? otherNameEl.textContent : '';
                
                // Color
                const youColor = (youSide === 'left') ? (leftColor || '#3b82f6') : (rightColor || '#ef4444');
                
                // Pose and mirror - read from data-pose attribute (more reliable than dropdown)
                let youPoseIndex = 0;
                let youPoseFlipped = false;
                const youCircle = document.getElementById(youSide + 'Circle');
                if (youCircle) {
                    const youParticipant = youCircle.parentElement;
                    if (youParticipant) {
                        const dataPose = youParticipant.getAttribute('data-pose');
                        if (dataPose !== null && dataPose !== '') {
                            youPoseIndex = Number(dataPose);
                        }
                        const dataMirror = youParticipant.getAttribute('data-mirror');
                        youPoseFlipped = dataMirror === 'true';
                    }
                }
                
                const payload = {
                    Other: otherName,
                    You: youName,
                    You_color: youColor,
                    You_pose: youPoseIndex,
                    You_pose_flipped: youPoseFlipped
                };
                try {
                    localStorage.setItem(DIALOG_COACHING_KEY, JSON.stringify(payload));
                    console.log('Gemmer dialogCoachingData:', payload);
                } catch (err) {
                    console.warn('Kunne ikke opdatere dialogCoachingData:', err);
                }
                const storage = loadDialogStorage();
                storage.lastCoachingUpdate = new Date().toISOString();
                await saveDialogStorage(storage);
                setStatus('dialogCoachingData opdateret for ' + youName);
                
                // Open coaching overlay with dialog_coaching.json
                openCoachingOverlayFromFile('coaching_templates/dialog_coaching.json');
            } catch(e) {
                console.error('writeDialogData error:', e);
            }
        }

        function continueDialog() {
            // Check if both participants are visible (this handles both dropdown selection and "Ny Dialog" case)
            const leftCircle = document.getElementById('leftCircle');
            const rightCircle = document.getElementById('rightCircle');
            const leftVisible = leftCircle && window.getComputedStyle(leftCircle).display !== 'none';
            const rightVisible = rightCircle && window.getComputedStyle(rightCircle).display !== 'none';
            
            if (!leftVisible || !rightVisible) {
                setStatus('Begge deltagere skal være synlige');
                return;
            }
            
            dialogActive = true;
            
            // Determine next speaker based on last speaker
            if (lastSpeaker === 'left') {
                currentSpeaker = 'right';
            } else if (lastSpeaker === 'right') {
                currentSpeaker = 'left';
            } else {
                currentSpeaker = 'left';
            }
            
            currentIndex = transcript.length;
            showSpeechBubble(currentSpeaker);
            updateAllButtons();
            setStatus('Dialog fortsat - skriv nye beskeder');
        }

        function showSpeechBubble(side) {
    hideAllSpeechBubbles();
	// Scale den talende part op
    const circle = document.getElementById(side + 'Circle');
    if (!circle) return;
    const activeParticipant = circle.parentElement;
    if (!activeParticipant) return;
    activeParticipant.style.transform = 'scale(1.035)';
    activeParticipant.style.transition = 'transform 0.45s ease';
    
    // Scale den anden part ned til normal
    const otherSide = side === 'left' ? 'right' : 'left';
    const otherCircle = document.getElementById(otherSide + 'Circle');
    if (otherCircle) {
        const otherParticipant = otherCircle.parentElement;
        if (otherParticipant) {
            otherParticipant.style.transform = 'scale(1.0)';
            otherParticipant.style.transition = 'transform 0.45s ease';
        }
    }
	
    
    const bubble = document.getElementById(side + 'Bubble');
    if (!bubble) return;
    const textarea = document.getElementById(side + 'Textarea');
    const dots = document.getElementById(side + 'Dots');
    
    const lightColor = side === 'left' ? leftLightColor : rightLightColor;
    
    if (lightColor) {
        bubble.style.backgroundColor = lightColor;
        
        const style = document.createElement('style');
        if (side === 'left') {
            style.textContent = '.speech-bubble.left::after { border-color: transparent ' + lightColor + ' transparent transparent !important; }';
        } else {
            style.textContent = '.speech-bubble.right::after { border-color: transparent transparent transparent ' + lightColor + ' !important; }';
        }
        document.head.appendChild(style);
    }
    
    if (side === 'left') {
        bubble.style.left = '150px';
        bubble.style.right = 'auto';
        bubble.style.transformOrigin = 'left center';
    } else {
        bubble.style.right = '150px';
        bubble.style.left = 'auto';
        bubble.style.transformOrigin = 'right center';
    }
    bubble.style.top = '50%';
    bubble.style.transform = 'translateY(-50%) scale(0.85)';
    
    textarea.style.display = 'inline';
    dots.style.display = 'inline';
    textarea.value = '';
    
    // Vis boblen og start animationen
    bubble.style.display = 'block';
	
	setTimeout(() => {
    bubble.style.transform = bubble.style.transform.replace('scale(0.85)', 'scale(1)');
    bubble.style.opacity = '1';
	}, 10);
    
    // Force reflow og start animation
    bubble.offsetHeight;
    bubble.classList.add('visible');
	
    
    textarea.focus();
    autoResizeTextarea(textarea);
}

        function handleInput(event, side) {
            if (event.key === 'Enter' && !event.shiftKey && event.target.value.trim()) {
                event.preventDefault();
                const message = event.target.value.trim();
                
                // Check if dialog is active
                if (!dialogActive) return;
                
                // Check if this is the current speaker
                if (currentSpeaker !== side) return;
                
                // Check if participant is visible
                const circle = document.getElementById(side + 'Circle');
                const isVisible = circle && window.getComputedStyle(circle).display !== 'none';
                
                if (!isVisible) return;
                
                // Get participant data - check dropdown first, then fallback to lav_ny_left/lav_ny_right
                const dropdown = document.getElementById(side + 'Dropdown');
                let partData = null;
                if (dropdown && dropdown.value && dropdown.value.trim() !== '') {
                    partData = partsData[dropdown.value];
                } else {
                    // Use lav_ny_left or lav_ny_right if dropdown is empty (Ny Dialog case)
                    const fallbackKey = side === 'left' ? 'lav_ny_left' : 'lav_ny_right';
                    partData = partsData[fallbackKey];
                }
                
                if (partData) {
                    const nameElement = document.getElementById(side + 'Name');
                    const customName = nameElement ? nameElement.textContent.trim() || partData.name : partData.name;
                    
                    // Clear the textarea
                    event.target.value = '';
                    
                    addToTranscript(customName, message, side);
                    lastSpeaker = side;
                    currentSpeaker = side === 'left' ? 'right' : 'left';
                    showSpeechBubble(currentSpeaker);
                    updateAllButtons();
                    persistActiveDialog();
                }
            }
        }

        function addToTranscript(speakerName, message, side) {
            const transcriptContent = document.getElementById('transcriptContent');
            
            if (transcriptContent.querySelector('.empty')) {
                transcriptContent.innerHTML = '';
            }
            
            // Generate timestamp
            const now = new Date();
            const timestamp = now.toLocaleDateString('da-DK') + ' ' + now.toLocaleTimeString('da-DK', { 
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit'
            });
            
            const messageDiv = document.createElement('div');
            messageDiv.className = side === 'left' ? 'message-left' : 'message-right';
            
            let backgroundColor = side === 'left' ? '#e3f2fd' : '#e8f5e8';
            const originalColor = side === 'left' ? leftColor : rightColor;
            if (originalColor) {
                backgroundColor = lightenColor(originalColor, 0.7);
            }
            
            messageDiv.style.backgroundColor = backgroundColor;
            
            const speakerDiv = document.createElement('div');
            speakerDiv.className = 'speaker';
            speakerDiv.textContent = speakerName;
            
            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'timestamp';
            timestampDiv.textContent = timestamp;
            speakerDiv.appendChild(timestampDiv);
            
            const textDiv = document.createElement('div');
            textDiv.className = 'text';
            textDiv.contentEditable = true;
            textDiv.textContent = message;
            
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-circle';
            deleteBtn.textContent = '×';
            
            const messageId = Date.now() + Math.random();
            
            deleteBtn.onclick = function() {
                messageDiv.remove();
                const index = transcript.findIndex(t => t.messageId === messageId);
                if (index > -1) {
                    transcript.splice(index, 1);
                    if (transcript.length > 0) {
                        lastSpeaker = transcript[transcript.length - 1].side;
                    } else {
                        lastSpeaker = null;
                    }
                }
                
                if (!transcriptContent.querySelector('.message-left') && !transcriptContent.querySelector('.message-right')) {
                    transcriptContent.innerHTML = '<div class="empty">Alle beskeder slettet</div>';
                }
                updateAllButtons();
                persistActiveDialog();
            };
            
            textDiv.onkeydown = function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    textDiv.blur();
                }
            };
            
            textDiv.onblur = function() {
                const newText = textDiv.textContent.trim();
                const transcriptEntry = transcript.find(t => t.messageId === messageId);
                if (transcriptEntry && newText) {
                    transcriptEntry.message = newText;
                }
                persistActiveDialog(false);
            };
            
            messageDiv.appendChild(speakerDiv);
            messageDiv.appendChild(textDiv);
            messageDiv.appendChild(deleteBtn);
            transcriptContent.appendChild(messageDiv);
            
            transcriptContent.scrollTop = transcriptContent.scrollHeight;
            
            transcript.push({ 
                side: side, 
                speaker: speakerName, 
                message: message,
                messageId: messageId,
                timestamp: timestamp
            });
            updateAllButtons();
            // Don't save here - will be saved on blur when user finishes editing or presses Enter
        }




        function updateAllButtons() {
            const leftSelected = document.getElementById('leftDropdown').value;
            const rightSelected = document.getElementById('rightDropdown').value;
            const bothSelected = leftSelected && leftSelected.trim() !== '' && rightSelected && rightSelected.trim() !== '';
            
            // Check if both participants are visible
            const leftCircle = document.getElementById('leftCircle');
            const rightCircle = document.getElementById('rightCircle');
            const leftVisible = leftCircle && window.getComputedStyle(leftCircle).display !== 'none';
            const rightVisible = rightCircle && window.getComputedStyle(rightCircle).display !== 'none';
            const bothParticipantsVisible = leftVisible && rightVisible;
            
            // Check if there's content in transcript
            const hasTranscriptContent = transcript.length > 0;
            
            // If not both participants are visible, disable all buttons except "Ny Dialog"
            const participantsNotVisible = !bothParticipantsVisible;
            
            // Button logic based on transcript content
            // If no transcript content: can start dialog, but not continue/play/next/copy/save/clear
            // If has transcript content: cannot start dialog, but can continue/play/next/copy/save/clear
            document.getElementById('startBtn').disabled = participantsNotVisible || hasTranscriptContent;
            
            const continueBtn = document.getElementById('continueBtn');
            continueBtn.disabled = participantsNotVisible || !hasTranscriptContent;
            
            document.getElementById('playBtn').disabled = participantsNotVisible || !hasTranscriptContent;
            document.getElementById('nextBtn').disabled = participantsNotVisible || !hasTranscriptContent;
			document.getElementById('copyBtn').disabled = participantsNotVisible || !hasTranscriptContent;
            
            // "Ryd Alt" is enabled when there's transcript content
            document.getElementById('clearBtn').disabled = participantsNotVisible || !hasTranscriptContent;
            
            // "Ny Dialog" is always enabled (unless participants not visible)
            document.getElementById('newDialogBtn').disabled = participantsNotVisible;
            
            document.getElementById('pauseBtn').disabled = false;
            
            if (isAutoPlaying) {
                document.getElementById('playBtn').style.display = 'none';
                document.getElementById('pauseBtn').style.display = 'inline-block';
            } else {
                document.getElementById('playBtn').style.display = 'inline-block';
                document.getElementById('pauseBtn').style.display = 'none';
            }

            // Show/hide mini C buttons and apply colors
            const miniWrapper = document.getElementById('miniControlsWrapper');
            if (miniWrapper) {
                miniWrapper.style.display = bothParticipantsVisible ? 'block' : 'none';
                const leftBtn = document.getElementById('leftMiniC');
                const rightBtn = document.getElementById('rightMiniC');
                if (leftBtn) leftBtn.style.background = leftColor || '#3b82f6';
                if (rightBtn) rightBtn.style.background = rightColor || '#ef4444';
            }
        }

        function setStatus(text) {
            document.getElementById('status').textContent = text;
        }

        function clearAll() {
            // Delete the active dialog from the history
            const activeDialog = getActiveDialog();
            const activeCollection = getActiveCollection();
            
            if (activeDialog && activeCollection) {
                // deleteDialogFromNewStructure handles confirmation, deletion, and loading next dialog
                deleteDialogFromNewStructure(activeCollection.id, activeDialog.id);
            } else {
                // Fallback: if no active dialog, just clear the UI
                if (autoTimeout) clearTimeout(autoTimeout);
            dialogActive = false;
            isAutoPlaying = false;
            transcript = [];
            lastSpeaker = null;
            hideAllSpeechBubbles();
            const transcriptContent = document.getElementById('transcriptContent');
            if (transcriptContent) {
                transcriptContent.innerHTML = '<div class="empty">Alle beskeder slettet</div>';
            }
            const leftTextarea = document.getElementById('leftTextarea');
            const rightTextarea = document.getElementById('rightTextarea');
            if (leftTextarea) leftTextarea.value = '';
            if (rightTextarea) rightTextarea.value = '';
            updateAllButtons();
            setStatus('Alle beskeder slettet');
            }
        }
		
		
		
		

        function playDialog() {
            if (currentIndex >= transcript.length) {
                currentIndex = 0;
                hideAllSpeechBubbles();
            }
            
            isAutoPlaying = true;
            dialogActive = false;
            updateAllButtons();
            setStatus('Automatisk afspilning...');
            
            showCurrentMessage();
            scheduleNextMessage();
        }

        function pauseDialog() {
            isAutoPlaying = false;
            if (autoTimeout) {
                clearTimeout(autoTimeout);
                autoTimeout = null;
            }
            dialogActive = false;
            updateAllButtons();
            setStatus('Pauseret - klik "Fortsæt Dialog" for at tilføje flere beskeder');
        }

        function nextDialog() {
            dialogActive = false;
            
            if (isAutoPlaying) {
                isAutoPlaying = false;
                if (autoTimeout) {
                    clearTimeout(autoTimeout);
                    autoTimeout = null;
                }
                updateAllButtons();
            }
            
            if (currentIndex >= transcript.length) {
                currentIndex = 0;
                hideAllSpeechBubbles();
                updateAllButtons();
                setStatus('Genstartet');
                return;
            }
            
            showCurrentMessage();
            currentIndex++;
            
            if (currentIndex >= transcript.length) {
                setStatus('Dialog færdig - klik "Fortsæt Dialog" for at tilføje flere beskeder');
                dialogActive = false;
            } else {
                setStatus('Manuel: ' + currentIndex + '/' + transcript.length);
            }
            
            updateAllButtons();
        }

        function showCurrentMessage() {
    if (currentIndex >= transcript.length) return;
    
    const message = transcript[currentIndex];
    hideAllSpeechBubbles();
	// Scale den talende part op
		const activeParticipant = document.getElementById(message.side + 'Circle').parentElement;
		activeParticipant.style.transform = 'scale(1.035)';
		activeParticipant.style.transition = 'transform 0.45s ease';

		// Scale den anden part ned til normal
		const otherSide = message.side === 'left' ? 'right' : 'left';
		const otherParticipant = document.getElementById(otherSide + 'Circle').parentElement;
		otherParticipant.style.transform = 'scale(1.0)';
		otherParticipant.style.transition = 'transform 0.45s ease';
	
    
    const bubble = document.getElementById(message.side + 'Bubble');
    const textarea = document.getElementById(message.side + 'Textarea');
    const dots = document.getElementById(message.side + 'Dots');
	
	// Opdater bubble farve
	const lightColor = message.side === 'left' ? leftLightColor : rightLightColor;
	if (lightColor) {
		bubble.style.backgroundColor = lightColor;
		
		const style = document.createElement('style');
		if (message.side === 'left') {
			style.textContent = '.speech-bubble.left::after { border-color: transparent ' + lightColor + ' transparent transparent !important; }';
		} else {
			style.textContent = '.speech-bubble.right::after { border-color: transparent transparent transparent ' + lightColor + ' !important; }';
		}
		document.head.appendChild(style);
	}
    
    // Sæt indhold
    textarea.value = message.message;
    textarea.style.display = 'inline';
    dots.style.display = 'none';
    
    // Positionér boblen
    if (message.side === 'left') {
        bubble.style.left = '150px';
        bubble.style.right = 'auto';
        bubble.style.transformOrigin = 'left center';
    } else {
        bubble.style.right = '150px';
        bubble.style.left = 'auto';
        bubble.style.transformOrigin = 'right center';
    }
    bubble.style.top = '50%';
    
    // Start animation - samme som showSpeechBubble
    bubble.style.transform = 'translateY(-50%) scale(0.85)';
    bubble.style.opacity = '0';
    bubble.style.display = 'block';
    
    setTimeout(() => {
        bubble.style.transform = bubble.style.transform.replace('scale(0.85)', 'scale(1)');
        bubble.style.opacity = '1';
    }, 10);
    
    bubble.offsetHeight;
    bubble.classList.add('visible');
    
    autoResizeTextarea(textarea);
}

        function scheduleNextMessage() {
            if (!isAutoPlaying || currentIndex >= transcript.length) return;
            
            const message = transcript[currentIndex];
            const baseTime = 1500;
            const timePerWord = 400;
            const wordCount = message.message.split(' ').length;
            const displayTime = baseTime + (wordCount * timePerWord);
            
            autoTimeout = setTimeout(function() {
                currentIndex++;
                
                if (currentIndex >= transcript.length) {
                    isAutoPlaying = false;
                    dialogActive = false;
                    updateAllButtons();
                    setStatus('Dialog færdig - klik "Fortsæt Dialog" for at tilføje flere beskeder');
                } else {
                    setStatus('Auto: ' + currentIndex + '/' + transcript.length);
                    showCurrentMessage();
                    scheduleNextMessage();
                }
            }, displayTime);
        }

        function hideAllSpeechBubbles() {
    document.getElementById('leftBubble').style.display = 'none';
    document.getElementById('rightBubble').style.display = 'none';
	
	// Reset scaling
    document.getElementById('leftCircle').parentElement.style.transform = 'scale(1.0)';
    document.getElementById('rightCircle').parentElement.style.transform = 'scale(1.0)';
	
	
	
}

        // CSV Import/Export functions removed - Firestore sync is used instead
		
		// funktioner til copy til klipboard
				function copyDialog() {
			if (transcript.length === 0) {
				alert('Ingen dialog at kopiere!');
				return;
			}
			
			const dialogText = transcript.map(entry => {
				return `${entry.speaker}: ${entry.message}`;
			}).join('\n\n');
			
			// Forsøg moderne clipboard API først
			if (navigator.clipboard && window.isSecureContext) {
				navigator.clipboard.writeText(dialogText).then(() => {
					setStatus('Dialog kopieret til udklipsholderen!');
				}).catch(() => {
					fallbackCopy(dialogText);
				});
			} else {
				fallbackCopy(dialogText);
			}
		}

		function fallbackCopy(text) {
			const textArea = document.createElement('textarea');
			textArea.value = text;
			textArea.style.position = 'fixed';
			textArea.style.opacity = '0';
			document.body.appendChild(textArea);
			textArea.select();
			
			try {
				document.execCommand('copy');
				setStatus('Dialog kopieret til udklipsholderen!');
			} catch (err) {
				setStatus('Kunne ikke kopiere - prøv at markere og kopiere manuelt');
			}
			
			document.body.removeChild(textArea);
		}
		
		
		
		
		
		

        function applyLoadedDialog(leftPart, rightPart, dialogData) {
            leftColor = leftPart.color;
            rightColor = rightPart.color;
            leftLightColor = lightenColor(leftPart.color, 0.6);
            rightLightColor = lightenColor(rightPart.color, 0.6);
			updateBodyColors('left', leftPart.color);
			updateBodyColors('right', rightPart.color);
            
            // Don't set dropdown values to 'lav_ny_left'/'lav_ny_right' as they're no longer in dropdowns
            document.getElementById('leftDropdown').value = '';
            document.getElementById('rightDropdown').value = '';
            
            const leftCircle = document.getElementById('leftCircle');
            const rightCircle = document.getElementById('rightCircle');
            const leftName = document.getElementById('leftName');
            const rightName = document.getElementById('rightName');
            
            leftCircle.style.display = 'flex';
            rightCircle.style.display = 'flex';
            
            leftName.textContent = leftPart.name;
            rightName.textContent = rightPart.name;
            leftName.removeAttribute('data-edited');
            rightName.removeAttribute('data-edited');
            enableParticipantNameEditing('left');
            enableParticipantNameEditing('right');
            
            // Handle both 'spejl' (legacy) and 'flipped' (new structure)
            const leftFlipped = leftPart.flipped !== undefined ? leftPart.flipped : (leftPart.spejl || false);
            const rightFlipped = rightPart.flipped !== undefined ? rightPart.flipped : (rightPart.spejl || false);
            
            // Initialize partsData with all participant data
            partsData.lav_ny_left = {
                name: leftPart.name || 'Venstre del',
                keywords: Array.isArray(leftPart.keywords) ? leftPart.keywords.slice(0, 6) : ['', '', '', '', '', ''],
                color: leftPart.color || '#3b82f6',
                pose: leftPart.pose || '',
                mirror: leftFlipped
            };
            partsData.lav_ny_right = {
                name: rightPart.name || 'Højre del',
                keywords: Array.isArray(rightPart.keywords) ? rightPart.keywords.slice(0, 6) : ['', '', '', '', '', ''],
                color: rightPart.color || '#ef4444',
                pose: rightPart.pose || '',
                mirror: rightFlipped
            };
            
            const leftHead = leftCircle.querySelector('.head');
			const rightHead = rightCircle.querySelector('.head');

			if (leftHead) {
				leftHead.style.background = `linear-gradient(135deg, ${leftPart.color}, ${leftPart.color})`;
				
			}
			if (rightHead) {
				rightHead.style.background = `linear-gradient(135deg, ${rightPart.color}, ${rightPart.color})`;
				
			}
						
            document.getElementById('leftColorBtn').style.display = 'flex';
            document.getElementById('rightColorBtn').style.display = 'flex';
			
			// Genopret pose-indstillinger ved navn
const leftPoseDropdown = document.getElementById('leftPose');
const rightPoseDropdown = document.getElementById('rightPose');
const leftMirror = document.getElementById('leftMirror');
const rightMirror = document.getElementById('rightMirror');

// Sæt spejl-checkboxes først
if (leftMirror) leftMirror.checked = leftFlipped;
if (rightMirror) rightMirror.checked = rightFlipped;

// Set data-mirror attributes
const leftParticipant = leftCircle ? leftCircle.parentElement : null;
const rightParticipant = rightCircle ? rightCircle.parentElement : null;
if (leftParticipant) {
    leftParticipant.setAttribute('data-mirror', String(leftFlipped));
}
if (rightParticipant) {
    rightParticipant.setAttribute('data-mirror', String(rightFlipped));
}

// Derefter anvend poses (som nu vil tage højde for spejl-indstillingen)
// Use applyParticipantPose to ensure mirror is handled correctly
if (leftPart.pose) {
    const poseIndex = poseLibrary.findIndex(pose => pose.name === leftPart.pose);
    if (poseIndex !== -1 && leftPoseDropdown) {
        leftPoseDropdown.value = poseIndex;
    }
    applyParticipantPose('left', leftPart.pose, leftFlipped);
} else {
    // Reset pose if no pose is specified
    if (leftPoseDropdown) leftPoseDropdown.value = '';
    resetPose('left');
}
if (rightPart.pose) {
    const poseIndex = poseLibrary.findIndex(pose => pose.name === rightPart.pose);
    if (poseIndex !== -1 && rightPoseDropdown) {
        rightPoseDropdown.value = poseIndex;
    }
    applyParticipantPose('right', rightPart.pose, rightFlipped);
} else {
    // Reset pose if no pose is specified
    if (rightPoseDropdown) rightPoseDropdown.value = '';
    resetPose('right');
}
			
            
            transcript = [];
            document.getElementById('transcriptContent').innerHTML = '';
            
            dialogData.forEach(function(entry) {
                addToTranscriptFromFile(entry.speaker, entry.message, entry.side, entry.timestamp);
            });
            
            if (transcript.length > 0) {
                lastSpeaker = transcript[transcript.length - 1].side;
            }
            
            updateAllButtons();
            setStatus('Dialog indlæst med ' + transcript.length + ' beskeder');
        }

        function addToTranscriptFromFile(speakerName, message, side, timestamp = '') {
            const transcriptContent = document.getElementById('transcriptContent');
            
            const messageDiv = document.createElement('div');
            messageDiv.className = side === 'left' ? 'message-left' : 'message-right';
            
            let backgroundColor = side === 'left' ? '#e3f2fd' : '#e8f5e8';
            const originalColor = side === 'left' ? leftColor : rightColor;
            if (originalColor) {
                backgroundColor = lightenColor(originalColor, 0.7);
            }
            messageDiv.style.backgroundColor = backgroundColor;
            
            const speakerDiv = document.createElement('div');
            speakerDiv.className = 'speaker';
            speakerDiv.textContent = speakerName;
            
            // Add timestamp if available
            if (timestamp) {
                const timestampDiv = document.createElement('div');
                timestampDiv.className = 'timestamp';
                timestampDiv.textContent = timestamp;
                speakerDiv.appendChild(timestampDiv);
            }
            
            const textDiv = document.createElement('div');
            textDiv.className = 'text';
            textDiv.contentEditable = true;
            textDiv.textContent = message;
            
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-circle';
            deleteBtn.textContent = '×';
            
            const messageId = Date.now() + Math.random();
            
            deleteBtn.onclick = function() {
                messageDiv.remove();
                const index = transcript.findIndex(t => t.messageId === messageId);
                if (index > -1) {
                    transcript.splice(index, 1);
                    if (transcript.length > 0) {
                        lastSpeaker = transcript[transcript.length - 1].side;
                    } else {
                        lastSpeaker = null;
                    }
                }
                if (!transcriptContent.querySelector('.message-left') && !transcriptContent.querySelector('.message-right')) {
                    transcriptContent.innerHTML = '<div class="empty">Alle beskeder slettet</div>';
                }
                updateAllButtons();
                persistActiveDialog();
            };
            
            textDiv.onkeydown = function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    textDiv.blur();
                }
            };
            
            textDiv.onblur = function() {
                const newText = textDiv.textContent.trim();
                const transcriptEntry = transcript.find(t => t.messageId === messageId);
                if (transcriptEntry && newText) {
                    transcriptEntry.message = newText;
                }
                persistActiveDialog(false);
            };
            
            messageDiv.appendChild(speakerDiv);
            messageDiv.appendChild(textDiv);
            messageDiv.appendChild(deleteBtn);
            transcriptContent.appendChild(messageDiv);
            
            transcript.push({ 
                side: side, 
                speaker: speakerName, 
                message: message,
                messageId: messageId,
                timestamp: timestamp
            });
            persistActiveDialog(false);
        }

        document.addEventListener('DOMContentLoaded', async function() {
            // GUARD 1: Extend initial load period - wait for ALL
            
            // 1. Wait for auth state (max 3 seconds)
            try {
                await Promise.race([
                    authStatePromise,
                    new Promise(resolve => setTimeout(resolve, 3000))
                ]);
            } catch (e) {
                console.warn('Auth state wait error:', e);
            }
            
            // Resolve manually if not resolved yet
            if (!authStateReady && authStateResolver) {
                authStateResolver();
                authStateResolver = null;
            }
            
            // 2. Check if user is logged in - require login
            if (!currentUser) {
                alert('Du skal være logget ind for at bruge denne side. Redirecter til login...');
                window.location.href = 'index.html';
                return;
            }
            
            // 3. Load data ÉN gang
            const data = await loadDialogData();
            if (data) {
                DialogData = data;
            } else {
                // No data in Firestore, create defaults
                DialogData = null;
                ensureDefaultDialogData();
            }
            console.log('[INIT] Loaded dialog data, collections:', DialogData?.collections?.length || 0);
            
            // 5. Wait for DOM to be fully rendered
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // 6. NU FØRST: Mark initial load complete
            console.log('[INIT] Initial load complete');
            
            // Load pose library first
            await loadPoseLibrary();
            // Load animations
            await loadAnimations();
            // Initialize color picker grid
            const grid = document.getElementById('colorGrid');
            
            for(let row = 0; row < 14; row++) {
                for(let col = 0; col < 12; col++) {
                    let hex;
                    
                    if(row === 0) {
                        const hue = Math.round(col * 360/12);
                        hex = hslToHex(hue, 95, 50);
                    } else if(row === 1) {
                        const light = Math.round(100 - (col * (100/11)));
                        hex = hslToHex(0, 0, light);
                    } else {
                        const gridRow = row - 2;
                        const hue = Math.round(col * 360/12);
                        const light = Math.round(92 - (gridRow * (84/11)));
                        const satBase = 86;
                        const sat = Math.round(satBase - Math.abs((col - 6)/ 6) * 20);
                        hex = hslToHex(hue, sat, light);
                    }
                    
                    const swatch = document.createElement('button');
                    swatch.className = 'swatch';
                    swatch.style.background = hex;
                    swatch.dataset.hex = hex;
                    swatch.title = hex;
                    swatch.setAttribute('aria-label', `Farve ${hex}`);
                    swatch.tabIndex = 0;
                    
                    swatch.addEventListener('click', () => selectColor(hex));
                    
                    grid.appendChild(swatch);
                }
            }
            
            // Event listeners
            document.getElementById('colorPickerModal').addEventListener('click', function(e) {
                if (e.target === this) closeColorPicker();
            });

            

            initializeDropdowns();
			initializePoseDropdowns();
            
            // Listen for localStorage changes (cross-tab synchronization)
            window.addEventListener('storage', function(e) {
                if (e.key === 'relationsSetupData') {
                    (window.__APP_DEBUG__ && console.log('localStorage relationsSetupData updated, refreshing dropdowns...'));
                    handleStorageUpdate();
                }
            });
            
            document.getElementById('leftDropdown').addEventListener('change', () => updateParticipant('left'));
            document.getElementById('rightDropdown').addEventListener('change', () => updateParticipant('right'));
            
            document.getElementById('leftColorBtn').addEventListener('click', function(e) {
                e.stopPropagation();
                openColorPicker(this, 'left');
            });
            document.getElementById('rightColorBtn').addEventListener('click', function(e) {
                e.stopPropagation();
                openColorPicker(this, 'right');
            });

            // Initial render for mini controls in case both are preselected via load
            updateAllButtons();

            
			
			document.getElementById('leftTextarea').addEventListener('input', function() {
			autoResizeTextarea(this);
			});
			document.getElementById('rightTextarea').addEventListener('input', function() {
				autoResizeTextarea(this);
			});
			
			// Tilføj dette i din DOMContentLoaded event listener
			document.getElementById('posePickerModal').addEventListener('click', function(e) {
				if (e.target === this) {
					closePosePicker();
				}
			});
			
			document.getElementById('leftPoseBtn').addEventListener('click', function(e) {
				e.stopPropagation();
				openPosePicker(this);
			});
			document.getElementById('rightPoseBtn').addEventListener('click', function(e) {
				e.stopPropagation();
				openPosePicker(this);
			});
			
			document.getElementById('leftNoteBtn').addEventListener('click', function(e) {
				e.stopPropagation();
				openNoteOverlay(this);
			});
			document.getElementById('rightNoteBtn').addEventListener('click', function(e) {
				e.stopPropagation();
				openNoteOverlay(this);
			});
			
			// Note overlay - close when clicking outside
			document.addEventListener('click', function(e) {
				const noteOverlay = document.getElementById('noteOverlay');
				if (noteOverlay && noteOverlay.classList.contains('show')) {
					if (!noteOverlay.contains(e.target)) {
						closeNoteOverlay();
					}
				}
			});
			
			// Prevent clicks inside note overlay from closing it
			const noteOverlay = document.getElementById('noteOverlay');
			if (noteOverlay) {
				noteOverlay.addEventListener('click', function(e) {
					e.stopPropagation();
				});
			}

			// Save when mirror changes
			const leftMirror = document.getElementById('leftMirror');
			const rightMirror = document.getElementById('rightMirror');
			if (leftMirror) {
				leftMirror.addEventListener('change', function() {
					toggleMirror('left');
				});
			}
			if (rightMirror) {
				rightMirror.addEventListener('change', function() {
					toggleMirror('right');
				});
			}

            // Cleanup: ask to remove empty dialogs (no messages)
            promptCleanupEmptyDialogsOnLoad();
            
            // Load active dialog from new structure
            const activeDialog = getActiveDialog();
            if (activeDialog) {
                loadSavedDialogFromNewStructure(activeDialog);
            }
            
            // Initialize history sidebar
            // Default to collapsed (true) unless explicitly set to false in localStorage
            const savedState = localStorage.getItem(DIALOG_HISTORY_COLLAPSED_KEY);
            dialogHistoryCollapsed = savedState === null || savedState === 'true';
            updateDialogHistoryToggleUI();
            
            const newDialogBtn = document.getElementById('newDialogBtn');
            if (newDialogBtn) {
                newDialogBtn.addEventListener('click', createNewDialogEntry);
            }

            // Render history
            renderDialogHistory();
            
            // Setup history color picker event listeners
            const historyRemoveColorBtn = document.getElementById('historyRemoveColorBtn');
            if (historyRemoveColorBtn) {
                historyRemoveColorBtn.addEventListener('click', removeHistoryColor);
            }
            
            // Modal backdrop click to close history color picker
            const historyColorPickerModalEl = document.getElementById('historyColorPickerModal');
            if (historyColorPickerModalEl) {
                historyColorPickerModalEl.addEventListener('click', (e) => {
                    if (e.target === historyColorPickerModalEl) {
                        closeHistoryColorPicker();
                    }
                });
            }
            
            // Setup Escape key and backdrop click handlers for overlays
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (historyColorPickerModalEl && historyColorPickerModalEl.classList.contains('show')) {
                        closeHistoryColorPicker();
                    }
                }
            });

            // Wire mini C buttons to write dialogData
            const leftMini = document.getElementById('leftMiniC');
            const rightMini = document.getElementById('rightMiniC');
            if (leftMini) leftMini.addEventListener('click', function() { writeDialogData('left'); });
            if (rightMini) rightMini.addEventListener('click', function() { writeDialogData('right'); });
						
            document.getElementById('startBtn').addEventListener('click', startDialog);
            document.getElementById('continueBtn').addEventListener('click', continueDialog);
            document.getElementById('playBtn').addEventListener('click', playDialog);
            document.getElementById('pauseBtn').addEventListener('click', pauseDialog);
            document.getElementById('nextBtn').addEventListener('click', nextDialog);
            document.getElementById('copyBtn').addEventListener('click', copyDialog);
            document.querySelector('.clear-btn').addEventListener('click', clearAll);
            
            document.getElementById('leftTextarea').addEventListener('keypress', (event) => handleInput(event, 'left'));
            document.getElementById('rightTextarea').addEventListener('keypress', (event) => handleInput(event, 'right'));
            
            updateAllButtons();
            
            // Navigation overlay functionality - optimized with event delegation
            const navBox = document.getElementById('navBox');
            const navToggleBtn = document.querySelector('.nav-toggle-btn');
            
            if (navBox) {
                // Mark current page as active
                const currentPage = 'dialog_01.html';
                const navButtons = document.querySelectorAll('.nav-button');
                navButtons.forEach(btn => {
                    if (btn.getAttribute('href') === currentPage || btn.textContent.trim() === 'Dialog') {
                        btn.classList.add('active');
                    }
                });
                
                // Use event delegation for nav button clicks (only one listener instead of multiple)
                navBox.addEventListener('click', function(e) {
                    const navButton = e.target.closest('.nav-button');
                    if (navButton) {
                        e.stopPropagation();
                        navBox.classList.remove('show');
                        const href = navButton.getAttribute('href');
                        if (href) {
                            window.location.href = href;
                        }
                    }
                });
            }
            
            // Close nav box when clicking outside - single listener
            document.addEventListener('click', function(e) {
                if (navBox && navBox.classList.contains('show')) {
                    if (!navBox.contains(e.target) && e.target !== navToggleBtn && !navToggleBtn?.contains(e.target)) {
                        navBox.classList.remove('show');
                    }
                }
            });
        });
        
        // Navigation overlay toggle function - must be global for onclick handler
        window.toggleNavBox = function() {
            const navBox = document.getElementById('navBox');
            const navToggleBtn = document.querySelector('.nav-toggle-btn');
            
            if (navBox && navToggleBtn) {
                const isShowing = navBox.classList.contains('show');
                if (isShowing) {
                    navBox.classList.remove('show');
                } else {
                    // Position nav-box at top-left corner of toggle button
                    const rect = navToggleBtn.getBoundingClientRect();
                    navBox.style.top = rect.top + 'px';
                    navBox.style.left = rect.left + 'px';
                    navBox.classList.add('show');
                }
            }
        };

        function applyParticipantPose(side, poseName, mirror) {
            if (!poseLibrary || !poseLibrary.length) {
                return;
            }
            const circle = document.getElementById(side + 'Circle');
            const participantNode = circle ? circle.parentElement : null;
            const defaultIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
            let poseIndex = -1;
            if (poseName) {
                poseIndex = poseLibrary.findIndex(p => p && p.name === poseName);
            }
            if (poseIndex === -1) {
                if (defaultIndex !== -1) {
                    applyPose(side, defaultIndex, typeof mirror === 'boolean' ? mirror : false);
                } else {
                    resetPose(side);
                }
                return;
            }
            const mirrorValue = typeof mirror === 'boolean'
                ? mirror
                : !!(participantNode && participantNode.getAttribute('data-mirror') === 'true');
            applyPose(side, poseIndex, mirrorValue);
        }
    </script>
    <!-- Navigation overlay -->
    <div class="nav-overlay" id="navOverlay"></div>

</body>
</html>