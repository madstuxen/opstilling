<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="imagefiles/apple-touch-icon.png">
    <title>Check in</title>
    <!-- Firebase App (the core Firebase SDK) - Using v8 for compatibility -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <!-- Firebase Authentication -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <!-- Firestore -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="coaching_engine.js" defer></script>
    <script src="coaching_overlay_complete.js" defer></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: #ffffff;
            min-height: 100vh;
            margin: 0;
            padding: 0px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            position: relative;
            transition: background 0.3s ease;
        }
        
        .background-image {
            position: fixed;
            left: 56%;
            top: 31%;
            transform: translate(-50%, -50%);
            z-index: 0;
            width: 395px;
            height: auto;
            opacity: 0.8;
        }
        
        .background-image img {
            width: 100%;
            height: auto;
        }
        
        /* Main content container - holds logo, figure and nav together */
        .main-content-container {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
            width: 50%;
            max-width: 100%;
            min-width: 0;
            height: 17%;
            pointer-events: none;
        }
        
        @media (max-width: 900px) {
            .main-content-container {
                width: 70%;
            }
        }
        
        @media (max-width: 600px) {
            .main-content-container {
                width: 90%;
            }
        }
        
        .logo-container {
            width: 443px;
            position: absolute;
            left: 50%;
            top: 0;
            transform: translateX(-50%);
            z-index: 1;
            pointer-events: auto;
        }
        
        .logo-container svg {
            width: 100%;
            height: auto;
        }
        
        /* Styling af SVG elementer - du kan √¶ndre disse farver */
        .logo-blue {
            fill: #3368AE; /* Bl√• farve - f√∏rste path */
        }
        
        .logo-yellow {
            fill: #E6B94F; /* Gul farve - anden path */
        }
        
        .logo-black {
            fill: #2C2C2C; /* Sort/m√∏rkegr√• - tredje path */
        }
        
        
        /* Navigation box */
        .nav-box {
            position: absolute;
            left: 50%;
            top: 350px;
            transform: translate(0px, -100%);
            background: transparent;
            border-radius: 20px;
            padding: 20px 25px;
            z-index: 3;
            display: none;
            flex-direction: column;
            gap: 10px;
            min-width: 120px;
            pointer-events: auto;
        }
        
        .nav-box.show {
            display: flex;
        }
        
        /* Check-in button */
        .checkin-button {
            position: absolute;
            left: 65%;
            top: 250px;
            transform: translate(-50%, -50%);
            padding: 12px 32px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-family: 'Arial', sans-serif;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            z-index: 3;
            box-shadow: 0 8px 24px rgba(16, 185, 129, 0.5), 0 4px 12px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
        }
        
        .checkin-button.hidden {
            display: none;
        }
        
        .checkin-button:hover {
            transform: translate(-50%, -50%) translateY(-2px);
            box-shadow: 0 12px 32px rgba(16, 185, 129, 0.6), 0 6px 16px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
        }
        
        .checkin-button:active {
            transform: translate(-50%, -50%) translateY(0px);
            box-shadow: 0 4px 16px rgba(16, 185, 129, 0.4), 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .nav-button {
            padding: 8px 16px;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            text-align: center;
            display: block;
            min-width: 120px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
        }
        
        .nav-button:hover {
            transform: translateY(-2px);
        }
        
        .nav-button:nth-child(1) {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        
        .nav-button:nth-child(1):hover:not(.active) {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }
        
        .nav-button:nth-child(2) {
            background: linear-gradient(135deg, #E6B94F 0%, #d97706 100%);
        }
        
        .nav-button:nth-child(2):hover:not(.active) {
            background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
            box-shadow: 0 5px 15px rgba(245, 158, 11, 0.3);
        }
        
        .nav-button:nth-child(3) {
            background: linear-gradient(135deg, #3368AE 0%, #1e40af 100%);
        }
        
        .nav-button:nth-child(3):hover:not(.active) {
            background: linear-gradient(135deg, #1e40af 0%, #1e3a8a 100%);
            box-shadow: 0 5px 15px rgba(37, 99, 235, 0.3);
        }
        
        .nav-button:nth-child(4) {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
        }
        
        .nav-button:nth-child(4):hover:not(.active) {
            background: linear-gradient(135deg, #db2777 0%, #be185d 100%);
            box-shadow: 0 5px 15px rgba(236, 72, 153, 0.3);
        }
        
        .nav-button:nth-child(5) {
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
        }
        
        .nav-button:nth-child(5):hover:not(.active) {
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
            box-shadow: 0 5px 15px rgba(71, 85, 105, 0.3);
        }
        

        .night-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9990;
        }

        .night-overlay.show {
            display: flex;
        }

        .night-overlay-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
        }

        .night-overlay-panel {
            position: relative;
            z-index: 1;
            width: min(90vw, 480px);
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.18) 0%, rgba(124, 58, 237, 0.16) 100%);
            border: 1px solid rgba(124, 58, 237, 0.35);
            border-radius: 22px;
            padding: 28px 30px;
            box-shadow: 0 24px 50px rgba(15, 23, 42, 0.45);
            display: flex;
            flex-direction: column;
            gap: 18px;
            min-height: 560px;
        }

        .night-overlay-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .night-overlay-header h2 {
            font-size: 1.25rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #f472b6;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .night-overlay-header h2 img {
            width: 56px;
            height: auto;
        }

        .night-overlay-close {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: none;
            background: rgba(244, 114, 182, 0.85);
            color: #1f1026;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .night-overlay-close:hover {
            transform: scale(1.08);
            background: rgba(244, 114, 182, 1);
        }

        .night-overlay textarea {
            width: 100%;
            min-height: 450px;
            border-radius: 14px;
            border: 1px solid rgba(124, 58, 237, 0.35);
            background: rgba(23, 23, 35, 0.82);
            color: rgba(231, 214, 226, 0.72);
            padding: 18px;
            font-size: 1rem;
            line-height: 1.6;
            resize: vertical;
            font-family: 'Arial', sans-serif;
            box-shadow: inset 0 0 0 1px rgba(124, 58, 237, 0.12);
        }

        .night-overlay textarea::placeholder {
            color: rgba(226, 232, 240, 0.6);
        }

        .night-overlay textarea:focus {
            outline: none;
            border-color: rgba(167, 139, 250, 0.75);
            box-shadow: 0 0 0 4px rgba(124, 58, 237, 0.2);
            background: rgba(23, 23, 35, 0.9);
        }
        
        /* Figure container */
        .figure-container {
            position: absolute;
            left: 50%;
            top: 97px;
            transform: translate(-270px, 0);
            z-index: 2;
            width: 300px;
            height: 300px;
            pointer-events: none;
        }
        
        .part {
            position: relative;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .head {
            position: absolute;
            top: -74px;
            left: 50%;
            transform: translateX(-50%);
            width: 72px;
            height: 72px;
            border-radius: 50%;
            background: #d97706;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
            text-align: center;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            padding: 10px;
            line-height: 1.2;
            z-index: 5;
            pointer-events: auto;
        }
        
        .body {
            position: absolute;
            top: 77px;
            left: 50%;
            transform: translateX(-50%);
            transform-origin: 40px -77px;
            transition: none !important;
            z-index: -1;
            pointer-events: none;
            will-change: transform;
            backface-visibility: hidden;
        }
        
        .torso {
            width: 60px;
            height: 80px;
            background: #d97706;
            margin: 0 auto;
            border-radius: 30px 30px 20px 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            position: relative;
            z-index: 5;
        }
        
        .torso::after {
            content: '';
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 4px;
            background: #d97706;
            border-radius: 50%;
        }
        
        .skulder_translate_right {
            position: absolute;
            top: 2px;
            left: 41px;
            width: 15px;
            height: 15px;
            background: rgba(59, 130, 246, 0.0);
            z-index: 3;
        }
        
        .skulder_translate_right.front-arm {
            z-index: 15;
        }
        
        .skulder_rotate_right {
            width: 100%;
            height: 100%;
            background: rgba(239, 68, 68, 0.0);
            transform-origin: center center;
        }
        
        .arm_geo_right {
            width: 50px;
            height: 18px;
            background: #d97706;
            border-radius: 9px;
            position: relative;
            top: -1px;
            left: -1px;
        }
        
        .albue_rotate_right {
            position: relative;
            top: 1px;
            left: 34px;
            width: 15px;
            height: 15px;
            background: rgba(16, 185, 129, 0.0);
            transform-origin: center center;
        }
        
        .albue_geo_right {
            position: relative;
            top: -1px;
            left: 1px;
            width: 50px;
            height: 18px;
            background: #d97706;
            border-radius: 9px;
            z-index: 4;
        }
        
        .skulder_translate_left {
            position: absolute;
            top: 2px;
            left: 4px;
            width: 15px;
            height: 15px;
            background: rgba(59, 130, 246, 0.0);
            z-index: 3;
        }
        
        .skulder_translate_left.front-arm {
            z-index: 15;
        }
        
        .skulder_rotate_left {
            width: 100%;
            height: 100%;
            background: rgba(239, 68, 68, 0.0);
            transform-origin: center center;
        }
        
        .arm_geo_left {
            width: 50px;
            height: 18px;
            background: #d97706;
            border-radius: 9px;
            position: relative;
            top: -1px;
            left: -34px;
        }
        
        .albue_rotate_left {
            position: relative;
            top: 1px;
            left: 0px;
            width: 15px;
            height: 15px;
            background: rgba(16, 185, 129, 0.0);
            transform-origin: center center;
        }
        
        .albue_geo_left {
            position: relative;
            top: -1px;
            left: -33px;
            width: 50px;
            height: 18px;
            background: #d97706;
            border-radius: 9px;
            z-index: 4;
        }
        
        .hofte_translate_right {
            position: absolute;
            top: 68px;
            left: 40px;
            width: 15px;
            height: 15px;
            background: rgba(59, 130, 246, 0.0);
        }
        
        .hofte_rotate_right {
            width: 100%;
            height: 100%;
            background: rgba(239, 68, 68, 0.0);
            transform-origin: center center;
        }
        
        .laar_geo_right {
            width: 18px;
            height: 55px;
            background: #d97706;
            border-radius: 9px;
            position: relative;
            top: -1px;
            left: -1px;
        }
        
        .knae_rotate_right {
            position: relative;
            top: 38px;
            left: 1px;
            width: 15px;
            height: 15px;
            background: rgba(16, 185, 129, 0.0);
            transform-origin: center center;
        }
        
        .skinneben_geo_right {
            position: relative;
            top: -1px;
            left: -1px;
            width: 18px;
            height: 50px;
            background: #d97706;
            border-radius: 9px;
        }
        
        .hofte_translate_left {
            position: absolute;
            top: 68px;
            left: 4px;
            width: 15px;
            height: 15px;
            background: rgba(59, 130, 246, 0.0);
        }
        
        .hofte_rotate_left {
            width: 100%;
            height: 100%;
            background: rgba(239, 68, 68, 0.0);
            transform-origin: center center;
        }
        
        .laar_geo_left {
            width: 18px;
            height: 55px;
            background: #d97706;
            border-radius: 9px;
            position: relative;
            top: -1px;
            left: -1px;
        }
        
        .knae_rotate_left {
            position: relative;
            top: 38px;
            left: 1px;
            width: 15px;
            height: 15px;
            background: rgba(16, 185, 129, 0.0);
            transform-origin: center center;
        }
        
        .skinneben_geo_left {
            position: relative;
            top: -1px;
            left: -1px;
            width: 18px;
            height: 50px;
            background: #d97706;
            border-radius: 9px;
        }
    </style>
</head>
<body id="bodyElement">
    <div class="background-image">
        <img src="imagefiles/bag_trans.png" alt="Baggrund">
    </div>
    <div class="main-content-container">
        <div class="logo-container" id="logoContainer">
        <svg width="887" height="276" viewBox="0 0 887 276" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path class="logo-blue" d="M762.601 78.5867C762.601 78.5867 768.652 58.723 787.689 57.0008C806.726 55.2785 811.178 74.1922 811.178 74.1922C811.178 74.1922 825.362 46.9523 855.304 50.8836C885.246 54.8149 887 213.815 887 213.815L849.582 217.2C849.579 216.984 848.016 93.9925 836.477 88.6033C824.928 83.2098 817.927 98.3308 817.927 98.3308L828.283 214.298L793.491 217.445C793.493 217.207 794.041 118.186 783.537 108.082C773.021 97.9665 765.133 120.21 765.133 120.21L771.172 219.465L735.724 222.672L724.997 46.3738L760.445 43.1668L762.601 78.5867ZM612.436 19.7859C659.171 -8.40773 720.389 43.0623 713.807 110.484L605.854 131.353C627.551 225.018 699.819 142.778 699.983 142.591C705.917 152.924 720.341 183.422 720.39 183.525C692.085 213.223 676.945 225.098 641.399 222.052C612.625 219.585 593.052 196.368 581.288 164.305C569.524 132.243 565.7 47.9801 612.436 19.7859ZM445 3.69607C445.053 3.68578 523.113 -11.5066 544.903 19.7859C566.701 51.0892 565.309 179.512 544.903 204.394C524.525 229.243 448.422 219.67 448.216 219.644L445 3.69607ZM519.4 74.1717C507.758 56.7189 466.072 65.1742 465.988 65.1912L467.707 185.713C467.741 185.717 508.495 191.082 519.4 177.202C530.31 163.315 531.054 91.6422 519.4 74.1717ZM636.791 49.4832C603.268 50.5317 608.472 105.514 608.486 105.669L676.944 92.0232C676.913 91.8149 670.281 48.4361 636.791 49.4832Z"/>
            <path class="logo-yellow" d="M291.82 29.8864C319.501 -9.90187 361.99 -1.12561 407.034 6.67644V81.28C406.952 81.2568 392.296 77.1354 365.837 77.1354C365.837 50.6099 373.518 47.2935 361.647 42.32C304.39 42.32 305.088 102.831 309.976 124.383C314.863 145.935 323.242 167.488 349.776 172.462C376.296 177.432 380.495 148.454 380.5 148.423H361.647V111.121H421V165.83C407.035 208.105 378.206 227.782 344.889 224.683C309.975 217.223 298.105 212.15 280.648 165.83C263.192 119.51 264.14 69.6748 291.82 29.8864ZM87.2451 83.2243L131.425 9.99968H183.03L186 218H131.425V116.123L87.2451 160.163L49.377 120.898V215.347L0.742188 218L0 9.99968H49.377L87.2451 83.2243ZM265 217H210.581L205 9.99968H258.023L265 217Z"/>
            <path class="logo-black" d="M390.955 149.703C398.29 149.027 403.745 150.174 407.32 153.146C410.997 155.993 413.023 159.449 413.397 163.511C413.772 167.574 413.546 171.294 412.719 174.671C411.881 177.935 410.879 180.645 409.712 182.801C408.658 184.947 406.738 187.571 403.951 190.673C401.266 193.652 399.186 195.779 397.71 197.053C396.347 198.317 393.877 200.536 390.3 203.711C397.957 213.932 409.13 225.251 423.818 237.668C426.389 233.448 428.59 229.546 430.422 225.962C433.799 226.789 436.381 228.258 438.169 230.37L438.94 231.323C436.104 236.365 433.534 240.585 431.23 243.984C436.653 248.492 441.989 252.667 447.237 256.508L447.44 258.708L437.401 268.341C431.876 263.956 426.878 259.75 422.41 255.723C417.553 261.065 412.648 264.647 407.694 266.47C402.741 268.292 395.975 269.599 387.398 270.389C378.934 271.17 371.678 269.619 365.63 265.738C359.694 261.846 356.336 255.669 355.556 247.204C354.775 238.74 356.192 231.269 359.806 224.79C363.409 218.198 368.67 211.681 375.588 205.238C369.604 195.888 366.269 187.489 365.583 180.04C364.886 172.479 367.109 165.73 372.252 159.793C377.385 153.743 383.619 150.38 390.955 149.703ZM369.323 240.984C369.749 245.611 371.247 249.514 373.816 252.691C376.488 255.746 380.005 257.47 384.366 257.865L403.495 256.101C403.721 256.081 404.218 255.921 404.987 255.622C405.756 255.324 406.31 255.159 406.649 255.128C406.977 254.984 407.469 254.768 408.125 254.479C408.895 254.181 409.495 253.898 409.925 253.631C410.469 253.353 411.063 253.014 411.709 252.613C412.468 252.201 413.677 251.122 415.337 249.376C400.566 236.056 389.079 223.798 380.876 212.604C372.259 221.593 368.407 231.053 369.323 240.984ZM377.305 175.716C377.909 182.262 380.601 189.241 385.381 196.653C391.162 191.454 395.399 186.795 398.092 182.677C400.898 178.549 402.057 173.833 401.568 168.529C401.068 163.112 399.115 159.82 395.707 158.655L384.873 159.654C382.247 160.806 380.229 162.984 378.817 166.187C377.507 169.267 377.003 172.443 377.305 175.716Z"/>
        </svg>
        </div>
        
        <div class="figure-container">
            <div class="part" id="guideFigure">
                <div class="body">
                    <div class="head">Mig</div>
                    <div class="torso"></div>
                    
                    <!-- Venstre arm hierarki -->
                    <div class="skulder_translate_left">
                        <div class="skulder_rotate_left">
                            <div class="arm_geo_left">
                                <div class="albue_rotate_left">
                                    <div class="albue_geo_left"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- H√∏jre arm hierarki -->
                    <div class="skulder_translate_right">
                        <div class="skulder_rotate_right">
                            <div class="arm_geo_right">
                                <div class="albue_rotate_right">
                                    <div class="albue_geo_right"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Venstre ben hierarki -->
                    <div class="hofte_translate_left">
                        <div class="hofte_rotate_left">
                            <div class="laar_geo_left">
                                <div class="knae_rotate_left">
                                    <div class="skinneben_geo_left"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- H√∏jre ben hierarki -->
                    <div class="hofte_translate_right">
                        <div class="hofte_rotate_right">
                            <div class="laar_geo_right">
                                <div class="knae_rotate_right">
                                    <div class="skinneben_geo_right"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <button class="checkin-button" id="checkinButton">Check-in!</button>
        
        <div class="nav-box" id="navBox">
            <a href="opstilling_01.html" class="nav-button">Opstilling</a>
            <a href="dialog_01.html" class="nav-button">Dialog</a>
            <a href="compare_01.html" class="nav-button">Ligheder</a>
            <a href="bodymap_01.html" class="nav-button">BodyMap</a>
            <a href="logbog_01.html" class="nav-button">Logbog</a>
        </div>
    </div>

<div class="night-overlay" id="nightOverlay">
    <div class="night-overlay-backdrop"></div>
    <div class="night-overlay-panel">
        <div class="night-overlay-header">
            <h2>
                Dr√∏mme
                <img src="imagefiles/moon.svg" alt="M√•ne ikon">
            </h2>
            <button class="night-overlay-close" id="nightOverlayClose" title="Luk">√ó</button>
        </div>
        <textarea id="nightDreamEntry" placeholder="Skriv dine dr√∏mme ned her. De gemmes til logbog n√•r du lukker dette vindue."></textarea>
    </div>
</div>
    
    <script>
        /**
         * L√¶ser brugerens timezone fra userData (indexuserData i localStorage)
         * Fallback hierarki:
         * 1. userData.timezone
         * 2. Browser's timezone (Intl API)
         * 3. 'Europe/Copenhagen' (default)
         */
        function getUserTimezone() {
            try {
                // 1. Pr√∏v at l√¶se fra userData
                const userDataStr = localStorage.getItem('indexuserData');
                if (userDataStr) {
                    const userData = JSON.parse(userDataStr);
                    if (userData.timezone && isValidTimezone(userData.timezone)) {
                        return userData.timezone;
                    }
                }
            } catch (e) {
                console.warn('Kunne ikke l√¶se timezone fra userData:', e);
            }
            
            // 2. Fallback til browser's timezone
            try {
                const browserTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                if (browserTimezone && isValidTimezone(browserTimezone)) {
                    return browserTimezone;
                }
            } catch (e) {
                console.warn('Kunne ikke l√¶se browser timezone:', e);
            }
            
            // 3. Ultimate fallback
            return 'Europe/Copenhagen';
        }

        /**
         * Validerer om en timezone string er gyldig
         */
        function isValidTimezone(tz) {
            if (!tz || typeof tz !== 'string') return false;
            try {
                Intl.DateTimeFormat(undefined, { timeZone: tz });
                return true;
            } catch (e) {
                return false;
            }
        }

        /**
         * Konverterer Date eller ISO string til lokal dato (YYYY-MM-DD) i brugerens timezone
         * @param {Date|string|null} date - Dato at konvertere (default: nu)
         * @returns {string|null} - Dato i YYYY-MM-DD format eller null ved fejl
         */
        function getLocalDateKey(date = null) {
            const d = date ? new Date(date) : new Date();
            if (isNaN(d.getTime())) return null;
            
            const timezone = getUserTimezone();
            
            // Konverter til lokal tid ved at formatere med da-DK locale og brugerens timezone
            const localDateStr = d.toLocaleDateString('da-DK', {
                timeZone: timezone,
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });
            
            // Format er "DD.MM.YYYY" - konverter til "YYYY-MM-DD"
            const [day, month, year] = localDateStr.split('.');
            return `${year}-${month}-${day}`;
        }

        function getTodayDateKey() {
            return getLocalDateKey();
        }
        
        // Save logbook data to Firestore
        async function saveLogbookDataToFirestore(entries) {
            if (!currentUser || !db) return false;
            
            // üõ°Ô∏è CRITICAL SAFETY CHECK: Prevent data loss from empty saves
            if (!entries || !Array.isArray(entries) || entries.length === 0) {
                console.error('üö® CRITICAL: Attempted to save empty logbookData from checkin.html!');
                console.error('This would DELETE ALL DATA. Save blocked!');
                console.trace(); // Show call stack
                alert('FEJL: Fors√∏gte at gemme tom data fra check-in! Dette er blokeret for at beskytte dine data. Reload siden.');
                return false;
            }
            
            try {
                const userDocRef = db.collection('users').doc(currentUser.uid);
                const doc = await userDocRef.get();
                const raw = doc.exists ? (doc.data() || {}) : {};
                
                // Check if data is in new monthly structure
                const userData = raw.userData || {};
                const registreringer = userData.registreringer || {};
                const hasMonthlyStructure = Object.keys(registreringer).length > 0 || 
                                             Object.keys(raw).some(key => /^\d{4}-\d{2}$/.test(key));
                
                if (hasMonthlyStructure) {
                    // New monthly structure: Group entries by month
                    const entriesByMonth = {};
                    entries.forEach(entry => {
                        if (!entry.date) return;
                        const monthKey = entry.date.substring(0, 7); // YYYY-MM
                        if (!entriesByMonth[monthKey]) {
                            entriesByMonth[monthKey] = [];
                        }
                        entriesByMonth[monthKey].push(entry);
                    });
                    
                    // Save each month to subcollections
                    for (const [monthKey, monthEntries] of Object.entries(entriesByMonth)) {
                        const monthDocRef = userDocRef.collection('months').doc(monthKey);
                        
                        // Load existing month data or create new
                        const monthDoc = await monthDocRef.get();
                        const existingMonthData = monthDoc.exists ? (monthDoc.data() || {}) : {};
                        
                        // Get old count before updating
                        const oldCount = existingMonthData.logbog ? existingMonthData.logbog.length : 0;
                        const newCount = monthEntries.length;
                        
                        // Update logbog array for this month
                        existingMonthData.logbog = monthEntries;
                        
                        // Save to subcollection
                        await monthDocRef.set(existingMonthData, { merge: true });
                        
                        // Only update registreringer if count changed
                        if (oldCount !== newCount) {
                            await updateRegistreringer(monthKey, 'logbog', newCount);
                        }
                    }
                    
                    // Update main document timestamp
                    await userDocRef.set({
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });
                } else {
                    // Old structure (backward compatibility)
                    await userDocRef.set({
                        logbogData: entries,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });
                }
                
                console.log('[SAVE] Success');
                return true;
            } catch (error) {
                console.error('[SAVE] Error:', error);
                return false;
            }
        }

        async function getLogbookEntries() {
            if (!currentUser || !db) {
                console.error('[LOAD] User not logged in - cannot load data');
                return [];
            }
            
            // Use cached data instead of reading from Firestore every time!
            try {
                const data = await loadAllUserData();
                if (data && Array.isArray(data.logbogData)) {
                    return data.logbogData;
                }
            } catch (error) {
                console.error('[LOAD] Error loading logbogData:', error);
            }
            
            return [];
        }

        async function saveLogbookEntries(entries) {
            if (!currentUser || !db) {
                console.error('[SAVE] User not logged in - cannot save data');
                return false;
            }
            
            // Never save empty data if Firestore has data
            if (!Array.isArray(entries) || entries.length === 0) {
                try {
                    const allData = await loadAllUserData();
                    const firestoreEntryCount = allData && Array.isArray(allData.logbogData) ? allData.logbogData.length : 0;
                    if (firestoreEntryCount > 0) {
                        console.error('[SAVE] BLOCKED: Refusing to overwrite', 
                                      firestoreEntryCount, 'entries with empty data');
                        return false;
                    }
                } catch (error) {
                    console.error('[SAVE] Error checking Firestore:', error);
                }
            }
            
            isSavingData = true;
            try {
                await saveLogbookDataToFirestore(entries);
                // Update cache directly without reading from Firestore
                if (window.allUserData) {
                    window.allUserData.logbogData = entries;
                }
                return true;
            } catch (error) {
                console.error('[SAVE] Error saving to Firestore:', error);
                return false;
            } finally {
                isSavingData = false;
            }
        }

        async function upsertLogEntry(dateKey, partial) {
            const entries = await getLogbookEntries();
            let entry = entries.find(item => item.date === dateKey);
            if (!entry) {
                entry = {
                    date: dateKey,
                    dagbog: '',
                    dreams: ''
                };
                entries.push(entry);
            }
            // KUN overskriv hvis partial har en v√¶rdi (ikke tom string, undefined eller null)
            Object.keys(partial).forEach(key => {
                if (partial[key] !== undefined && partial[key] !== null && partial[key] !== '') {
                    entry[key] = partial[key];
                }
            });
            await saveLogbookEntries(entries);
            return entry;
        }

        async function ensureTodayLogEntry() {
            const todayKey = getTodayDateKey();
            const entries = await getLogbookEntries();
            let entry = entries.find(item => item.date === todayKey);
            if (!entry) {
                entry = {
                    date: todayKey,
                    dagbog: '',
                    dreams: ''
                };
                entries.push(entry);
                // Don't save - it's a load operation, entry will be saved when user edits
            }
            return entry;
        }

        const OVERLAY_STATE_KEY = 'forside_overlay_data';
        const OVERLAY_SHOW_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes

        function loadOverlayState() {
            try {
                const raw = localStorage.getItem(OVERLAY_STATE_KEY);
                if (!raw) return {};
                const parsed = JSON.parse(raw);
                return typeof parsed === 'object' && parsed !== null ? parsed : {};
            } catch (error) {
                console.warn('Kunne ikke l√¶se forside_overlay_data:', error);
                return {};
            }
        }

        function saveOverlayState(state) {
            try {
                localStorage.setItem(OVERLAY_STATE_KEY, JSON.stringify(state));
            } catch (error) {
                console.warn('Kunne ikke gemme forside_overlay_data:', error);
            }
        }

        function shouldShowOverlay() {
            const now = new Date();
            const currentHour = now.getHours();
            const isNightTime = (currentHour >= 22 && currentHour <= 23) || (currentHour >= 0 && currentHour < 8);
            
            // Check if overlay was recently closed
            const state = loadOverlayState();
            if (state.closedAt) {
                const closedAt = new Date(state.closedAt);
                const timeSinceClosed = now - closedAt;
                if (timeSinceClosed < OVERLAY_SHOW_INTERVAL_MS) {
                    // Less than 5 minutes since closed, don't show
                    return false;
                }
            }
            
            return isNightTime;
        }

        function recordOverlayClosed() {
            const state = loadOverlayState();
            state.closedAt = new Date().toISOString();
            saveOverlayState(state);
        }

        // Global variabler til at gemme event listener referencer
        let dreamCloseListener = null;

        // Funktion til at gemme dreams data n√•r overlayet lukkes
        // Appender tekst til eksisterende dreams for datoen
        // IMPORTANT: Loads data directly from Firestore to avoid overwriting
        async function saveDreamsDataOnClose() {
            const textarea = document.getElementById('nightDreamEntry');
            if (!textarea) return;
            
            const newText = textarea.value.trim();
            
            // Gem kun hvis der faktisk er tekst
            if (!newText) return;
            
            if (!currentUser || !db) {
                console.error('[DREAMS] User not logged in - cannot save');
                return;
            }
            
            try {
                // Hent datoen n√•r overlayet lukkes (ikke n√•r det √•bnes)
                const dateKey = getTodayDateKey();
                const monthKey = dateKey.substring(0, 7); // YYYY-MM
                
                const userDocRef = db.collection('users').doc(currentUser.uid);
                const monthDocRef = userDocRef.collection('months').doc(monthKey);
                
                // Load existing month data directly from Firestore (NOT from cache!)
                const monthDoc = await monthDocRef.get();
                const existingMonthData = monthDoc.exists ? (monthDoc.data() || {}) : {};
                
                // Get existing logbog entries for this month (or empty array)
                let monthLogbogEntries = Array.isArray(existingMonthData.logbog) ? existingMonthData.logbog : [];
                
                // Find or create entry for today
                let entry = monthLogbogEntries.find(item => item.date === dateKey);
                if (!entry) {
                    entry = {
                        date: dateKey,
                        dagbog: '',
                        dreams: '',
                        checkins: [],
                        timestamp: new Date().toISOString(),
                        color: '#b8735e'
                    };
                    monthLogbogEntries.push(entry);
                }
                
                // Appender ny tekst til eksisterende dreams (hvis der allerede er noget)
                if (entry.dreams && entry.dreams.trim()) {
                    entry.dreams = entry.dreams.trim() + '\n\n' + newText;
                } else {
                    entry.dreams = newText;
                }
                
                // Update timestamp
                entry.timestamp = new Date().toISOString();
                
                // Get old count before updating
                const oldCount = existingMonthData.logbog ? existingMonthData.logbog.length : 0;
                const newCount = monthLogbogEntries.length;
                
                // Update logbog array for this month
                existingMonthData.logbog = monthLogbogEntries;
                
                // Save to subcollection
                await monthDocRef.set(existingMonthData, { merge: true });
                
                // Only update registreringer if count changed
                if (oldCount !== newCount) {
                    await updateRegistreringer(monthKey, 'logbog', newCount);
                }
                
                // Update cache with merged data
                if (window.allUserData) {
                    await loadAllUserData(true);
                }
                
                console.log(`[DREAMS] Saved dreams for ${dateKey}`);
            } catch (error) {
                console.error('[DREAMS] Error saving dreams:', error);
            }
        }

        async function hydrateNightOverlay() {
            const overlay = document.getElementById('nightOverlay');
            const textarea = document.getElementById('nightDreamEntry');
            const closeBtn = document.getElementById('nightOverlayClose');

            if (!overlay || !textarea || !closeBtn) return;

            // Start altid med tom textarea - loader IKKE eksisterende data
            textarea.value = '';

            // Fjern gammel close listener hvis den findes
            if (dreamCloseListener) {
                closeBtn.removeEventListener('click', dreamCloseListener);
                closeBtn.removeEventListener('touchend', dreamCloseListener);
                dreamCloseListener = null;
            }

            // Opret close listener der gemmer data f√∏r overlay lukkes
            dreamCloseListener = async (e) => {
                // Prevent default for touch events
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                // Gem data n√•r overlay lukkes (appender til eksisterende dreams for datoen)
                await saveDreamsDataOnClose();
                overlay.classList.remove('show');
                recordOverlayClosed();
            };
            
            // Add both click and touch events for mobile compatibility
            closeBtn.addEventListener('click', dreamCloseListener);
            closeBtn.addEventListener('touchend', dreamCloseListener);

            if (shouldShowOverlay()) {
                overlay.classList.add('show');
            }
        }

        let overlayActivityTimeoutId = null;

        function setupOverlayActivityListeners() {
            const activityEvents = ['mousemove', 'keydown', 'touchstart', 'click'];

            function handleActivity() {
                const overlay = document.getElementById('nightOverlay');
                if (!overlay || overlay.classList.contains('show')) {
                    resetOverlayActivityTimeout();
                    return;
                }
                if (overlayActivityTimeoutId !== null) {
                    return;
                }
                overlayActivityTimeoutId = window.setTimeout(() => {
                    overlayActivityTimeoutId = null;
                    hydrateNightOverlay();
                }, 500);
            }

            activityEvents.forEach(eventName => {
                window.addEventListener(eventName, handleActivity, { passive: true });
            });
        }

        function resetOverlayActivityTimeout() {
            if (overlayActivityTimeoutId !== null) {
                clearTimeout(overlayActivityTimeoutId);
                overlayActivityTimeoutId = null;
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            // GUARD 1: Extend initial load period - wait for ALL
            
            // 1. Wait for auth state (max 3 seconds)
            try {
                await Promise.race([
                    authStatePromise,
                    new Promise(resolve => setTimeout(resolve, 3000))
                ]);
            } catch (e) {
                console.warn('Auth state wait error:', e);
            }
            
            // Resolve manually if not resolved yet
            if (!authStateReady && authStateResolver) {
                authStateResolver();
                authStateResolver = null;
            }
            
            // 2. Check if user is logged in - require login
            if (!currentUser) {
                alert('Du skal v√¶re logget ind for at bruge denne side. Redirecter til login...');
                window.location.href = 'index.html';
                return;
            }
            
            // 3. Wait for DOM to be fully rendered
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            console.log('[INIT] Initial load complete');
            
            // 4. Preload all user data into cache (including logbogData)
            console.log('[INIT] Preloading user data into cache...');
            await loadAllUserData();
            console.log('[INIT] Cache preloaded ‚úÖ');
            
            // 5. Ensure indexuserData is set (needed for coaching)
            await ensureIndexUserData();
            
            // Now safe to hydrate and setup
            hydrateNightOverlay();
            setupOverlayActivityListeners();

            const checkinButton = document.getElementById('checkinButton');
            const navBox = document.getElementById('navBox');
            
            if (checkinButton) {
                checkinButton.addEventListener('click', async (e) => {
                    e.stopPropagation();

                    // Check if user has already checked in today
                    const alreadyCheckedIn = await hasCheckedInToday();
                    
                    if (alreadyCheckedIn) {
                        // Redirect to logbog
                        window.location.href = 'logbog_01.html';
                        return;
                    }

                    // Otherwise, start coaching
                    const launchCoaching = () => {
                        const openFunc =
                            typeof window.openCoachingOverlay === 'function'
                                ? window.openCoachingOverlay
                                : (typeof openCoachingOverlay === 'function' ? openCoachingOverlay : null);
                        if (openFunc) {
                            openFunc('coaching_templates/forside_coaching.json');
                        } else {
                            console.error('Coaching overlay funktion ikke tilg√¶ngelig');
                        }
                    };

                    if (typeof window.openCoachingOverlay === 'function' || typeof openCoachingOverlay === 'function') {
                        launchCoaching();
                    } else {
                        const retryInterval = setInterval(() => {
                            if (typeof window.openCoachingOverlay === 'function' || typeof openCoachingOverlay === 'function') {
                                clearInterval(retryInterval);
                                launchCoaching();
                            }
                        }, 100);
                        setTimeout(() => clearInterval(retryInterval), 5000);
                    }

                    // Show navigation and hide check-in button after short delay
                    setTimeout(() => {
                        if (navBox) {
                            navBox.classList.add('show');
                            checkinButton.classList.add('hidden');
                            const navLinks = navBox.querySelectorAll('a.nav-button');
                            navLinks.forEach(link => {
                                link.addEventListener('click', (linkEvent) => {
                                    linkEvent.stopPropagation();
                                    navBox.classList.remove('show');
                                    const href = link.getAttribute('href');
                                    if (href) {
                                        window.location.href = href;
                                    }
                                });
                            });
                        }
                    }, 500);
                });
            }
        });

        // Animations library
        let animationsLibrary = {};
        
        // Default kram pose
        const kramPose = {
            name: "kram",
            pose: {
                translate_x_left: -4,
                translate_y_left: 4,
                skulder_rot_left: -28,
                albue_rot_left: 11,
                translate_x: 3,
                translate_y: 3,
                skulder_rot: 27,
                albue_rot: -13,
                translate_x_left_leg: 0,
                translate_y_left_leg: 0,
                hofte_rot_left: 4,
                knae_rot_left: -4,
                translate_x_right_leg: 0,
                translate_y_right_leg: 0,
                hofte_rot_right: -4,
                knae_rot_right: 3,
                left_arm_front: false,
                right_arm_front: false
            }
        };
        
        // Load animations from JSON files
        async function loadAnimations() {
            try {
                const manifestResponse = await fetch('Animations/manifest.json');
                if (manifestResponse.ok) {
                    const manifest = await manifestResponse.json();
                    if (manifest.files && Array.isArray(manifest.files)) {
                        for (const fileName of manifest.files) {
                            try {
                                const fileResponse = await fetch(`Animations/${fileName}`);
                                if (fileResponse.ok) {
                                    const animationData = await fileResponse.json();
                                    const animName = fileName.replace('.json', '');
                                    animationsLibrary[animName] = animationData;
                                }
                            } catch (error) {
                                console.error(`Failed to load animation ${fileName}:`, error);
                            }
                        }
                        return;
                    }
                }
            } catch (error) {
                // Manifest not available, try directory listing
            }
            
            // Fallback: Try directory listing
            try {
                const response = await fetch('Animations/');
                if (response.ok) {
                    const html = await response.text();
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const links = doc.querySelectorAll('a[href$=".json"]');
                    const jsonFiles = Array.from(links)
                        .map(link => link.getAttribute('href'))
                        .filter(file => file !== 'manifest.json');
                    
                    if (jsonFiles.length > 0) {
                        for (const fileName of jsonFiles) {
                            try {
                                const fileResponse = await fetch(`Animations/${fileName}`);
                                if (fileResponse.ok) {
                                    const animationData = await fileResponse.json();
                                    const animName = fileName.replace('.json', '');
                                    animationsLibrary[animName] = animationData;
                                }
                            } catch (error) {
                                console.error(`Failed to load animation ${fileName}:`, error);
                            }
                        }
                        return;
                    }
                }
            } catch (error) {
                // Directory listing not available
            }
        }
        
        // Apply pose to figure
        function applyPoseToFigure(figure) {
            const poseData = kramPose.pose;
            const body = figure.querySelector('.body') || figure;
            const skulderLeft = body.querySelector('.skulder_translate_left');
            const skulderRight = body.querySelector('.skulder_translate_right');
            const hofteLeft = body.querySelector('.hofte_translate_left');
            const hofteRight = body.querySelector('.hofte_translate_right');
            
            if (skulderLeft) {
                skulderLeft.style.transform = `translate(${poseData.translate_x_left || 0}px, ${poseData.translate_y_left || 0}px)`;
                const skulderRotLeft = skulderLeft.querySelector('.skulder_rotate_left');
                if (skulderRotLeft) {
                    skulderRotLeft.style.transform = `rotate(${poseData.skulder_rot_left || 0}deg)`;
                    const albueRotLeft = skulderRotLeft.querySelector('.albue_rotate_left');
                    if (albueRotLeft) {
                        albueRotLeft.style.transform = `rotate(${poseData.albue_rot_left || 0}deg)`;
                    }
                }
            }
            
            if (skulderRight) {
                skulderRight.style.transform = `translate(${poseData.translate_x || 0}px, ${poseData.translate_y || 0}px)`;
                const skulderRotRight = skulderRight.querySelector('.skulder_rotate_right');
                if (skulderRotRight) {
                    skulderRotRight.style.transform = `rotate(${poseData.skulder_rot || 0}deg)`;
                    const albueRotRight = skulderRotRight.querySelector('.albue_rotate_right');
                    if (albueRotRight) {
                        albueRotRight.style.transform = `rotate(${poseData.albue_rot || 0}deg)`;
                    }
                }
            }
            
            if (hofteLeft) {
                hofteLeft.style.transform = `translate(${poseData.translate_x_left_leg || 0}px, ${poseData.translate_y_left_leg || 0}px)`;
                const hofteRotLeft = hofteLeft.querySelector('.hofte_rotate_left');
                if (hofteRotLeft) {
                    hofteRotLeft.style.transform = `rotate(${poseData.hofte_rot_left || 0}deg)`;
                    const knaeRotLeft = hofteRotLeft.querySelector('.knae_rotate_left');
                    if (knaeRotLeft) {
                        knaeRotLeft.style.transform = `rotate(${poseData.knae_rot_left || 0}deg)`;
                    }
                }
            }
            
            if (hofteRight) {
                hofteRight.style.transform = `translate(${poseData.translate_x_right_leg || 0}px, ${poseData.translate_y_right_leg || 0}px)`;
                const hofteRotRight = hofteRight.querySelector('.hofte_rotate_right');
                if (hofteRotRight) {
                    hofteRotRight.style.transform = `rotate(${poseData.hofte_rot_right || 0}deg)`;
                    const knaeRotRight = hofteRotRight.querySelector('.knae_rotate_right');
                    if (knaeRotRight) {
                        knaeRotRight.style.transform = `rotate(${poseData.knae_rot_right || 0}deg)`;
                    }
                }
            }
        }
        
        // Apply slide data directly
        function applyDirectSlideData(slideData, guideFigure) {
            const body = guideFigure.querySelector('.body') || guideFigure;
            const skulderLeft = body.querySelector('.skulder_translate_left');
            const skulderRight = body.querySelector('.skulder_translate_right');
            const hofteLeft = body.querySelector('.hofte_translate_left');
            const hofteRight = body.querySelector('.hofte_translate_right');
            
            if (skulderLeft) {
                skulderLeft.style.transform = `translate(${slideData.translate_x_left || 0}px, ${slideData.translate_y_left || 0}px)`;
                const skulderRotLeft = skulderLeft.querySelector('.skulder_rotate_left');
                if (skulderRotLeft) {
                    skulderRotLeft.style.transform = `rotate(${slideData.skulder_rot_left || 0}deg)`;
                    const albueRotLeft = skulderRotLeft.querySelector('.albue_rotate_left');
                    if (albueRotLeft) {
                        albueRotLeft.style.transform = `rotate(${slideData.albue_rot_left || 0}deg)`;
                    }
                }
            }
            
            if (skulderRight) {
                skulderRight.style.transform = `translate(${slideData.translate_x || 0}px, ${slideData.translate_y || 0}px)`;
                const skulderRotRight = skulderRight.querySelector('.skulder_rotate_right');
                if (skulderRotRight) {
                    skulderRotRight.style.transform = `rotate(${slideData.skulder_rot || 0}deg)`;
                    const albueRotRight = skulderRotRight.querySelector('.albue_rotate_right');
                    if (albueRotRight) {
                        albueRotRight.style.transform = `rotate(${slideData.albue_rot || 0}deg)`;
                    }
                }
            }
            
            if (hofteLeft) {
                hofteLeft.style.transform = `translate(${slideData.translate_x_left_leg || 0}px, ${slideData.translate_y_left_leg || 0}px)`;
                const hofteRotLeft = hofteLeft.querySelector('.hofte_rotate_left');
                if (hofteRotLeft) {
                    hofteRotLeft.style.transform = `rotate(${slideData.hofte_rot_left || 0}deg)`;
                    const knaeRotLeft = hofteRotLeft.querySelector('.knae_rotate_left');
                    if (knaeRotLeft) {
                        knaeRotLeft.style.transform = `rotate(${slideData.knae_rot_left || 0}deg)`;
                    }
                }
            }
            
            if (hofteRight) {
                hofteRight.style.transform = `translate(${slideData.translate_x_right_leg || 0}px, ${slideData.translate_y_right_leg || 0}px)`;
                const hofteRotRight = hofteRight.querySelector('.hofte_rotate_right');
                if (hofteRotRight) {
                    hofteRotRight.style.transform = `rotate(${slideData.hofte_rot_right || 0}deg)`;
                    const knaeRotRight = hofteRotRight.querySelector('.knae_rotate_right');
                    if (knaeRotRight) {
                        knaeRotRight.style.transform = `rotate(${slideData.knae_rot_right || 0}deg)`;
                    }
                }
            }
            
            // Handle arm layering
            if (skulderLeft) {
                if (slideData.left_arm_front) {
                    skulderLeft.classList.add('front-arm');
                } else {
                    skulderLeft.classList.remove('front-arm');
                }
            }
            
            if (skulderRight) {
                if (slideData.right_arm_front) {
                    skulderRight.classList.add('front-arm');
                } else {
                    skulderRight.classList.remove('front-arm');
                }
            }
        }
        
        // Run animation with callback when done
        function runAnimation(animName, onComplete) {
            const animation = animationsLibrary[animName];
            if (!animation || !animation.slides) {
                if (onComplete) onComplete();
                return;
            }
            
            const guideFigure = document.getElementById('guideFigure');
            if (!guideFigure) {
                if (onComplete) onComplete();
                return;
            }
            
            // Apply default pose first
            applyPoseToFigure(guideFigure);
            
            setTimeout(() => {
                const body = guideFigure.querySelector('.body') || guideFigure;
                const animatedElements = body.querySelectorAll(
                    '.skulder_translate_left, .skulder_rotate_left, .albue_rotate_left, ' +
                    '.skulder_translate_right, .skulder_rotate_right, .albue_rotate_right, ' +
                    '.hofte_translate_left, .hofte_rotate_left, .knae_rotate_left, ' +
                    '.hofte_translate_right, .hofte_rotate_right, .knae_rotate_right'
                );
                
                animatedElements.forEach(element => {
                    element.style.display = 'block';
                });
                
                let slideIndex = 0;
                
                function playNextSlide() {
                    if (slideIndex < animation.slides.length) {
                        const slide = animation.slides[slideIndex];
                        
                        animatedElements.forEach((element) => {
                            const transitionStr = `transform ${slide.duration}s cubic-bezier(0.25, 0.1, 0.25, 1)`;
                            element.style.transition = transitionStr;
                        });
                        
                        applyDirectSlideData(slide, guideFigure);
                        guideFigure.offsetHeight;
                        
                        slideIndex++;
                        setTimeout(playNextSlide, slide.duration * 1000);
                    } else {
                        animatedElements.forEach(element => {
                            element.style.transition = '';
                        });
                        
                        setTimeout(() => {
                            animatedElements.forEach(element => {
                                element.style.transition = 'transform 0.5s ease';
                            });
                            applyPoseToFigure(guideFigure);
                            setTimeout(() => {
                                animatedElements.forEach(element => {
                                    element.style.transition = '';
                                });
                                // Call callback when animation is completely done
                                if (onComplete) onComplete();
                            }, 500);
                        }, 50);
                    }
                }
                
                playNextSlide();
            }, 1000);
        }
        
        // LocalStorage for forsideData
        const FORSIDE_DATA_KEY = 'forsideData';
        let affirmations = [];
        
        // Load affirmations from JSON file
        async function loadAffirmations() {
            try {
                const response = await fetch('affirmations.json');
                if (response.ok) {
                    affirmations = await response.json();
                    return affirmations;
                } else {
                    console.error('Kunne ikke indl√¶se affirmations.json');
                    return [];
                }
            } catch (error) {
                console.error('Fejl ved indl√¶sning af affirmations:', error);
                return [];
            }
        }
        
        // Calculate day number and get affirmation text
        function getAffirmationText() {
            if (affirmations.length === 0) {
                return null;
            }
            
            // Reference date (1. januar 2024)
            const referenceDate = new Date('2024-01-01');
            const today = new Date();
            
            // Set both dates to midnight for accurate day calculation
            referenceDate.setHours(0, 0, 0, 0);
            today.setHours(0, 0, 0, 0);
            
            // Calculate days difference
            const daysDiff = Math.floor((today - referenceDate) / (1000 * 60 * 60 * 24));
            
            // Modulo based on number of affirmations and add 1 to get 1-based index
            const dayNumber = (daysDiff % affirmations.length) + 1;
            
            // Get the affirmation text (convert to 0-based index)
            const affirmationText = affirmations[dayNumber - 1];
            
            return affirmationText;
        }
        
        // Save data to localStorage
        async function saveForsideData() {
            try {
                // Make sure affirmations are loaded
                if (affirmations.length === 0) {
                    await loadAffirmations();
                }
                
                const tekst = getAffirmationText();
                
                if (tekst) {
                    // Read existing indexuserData from localStorage
                    const existingData = localStorage.getItem('indexuserData');
                    let indexuserData = {};
                    
                    if (existingData) {
                        try {
                            indexuserData = JSON.parse(existingData);
                        } catch (e) {
                            console.warn('Could not parse existing indexuserData, creating new object');
                            indexuserData = {};
                        }
                    }
                    
                    // Add tekst to indexuserData
                    indexuserData.tekst = tekst;
                    
                    // Save back to localStorage
                    localStorage.setItem('indexuserData', JSON.stringify(indexuserData));
                    console.log('Tekst saved to indexuserData:', tekst);
                }
            } catch (error) {
                console.error('Fejl ved gemning til localStorage:', error);
            }
        }
        
        // Load data from localStorage
        function loadForsideData() {
            try {
                const savedData = localStorage.getItem(FORSIDE_DATA_KEY);
                if (savedData) {
                    const forsideData = JSON.parse(savedData);
                    // Use loaded data here
                    return forsideData;
                }
            } catch (error) {
                console.error('Fejl ved indl√¶sning fra localStorage:', error);
            }
            return null;
        }
        
        // Initialize
        async function init() {
            // Load affirmations first
            await loadAffirmations();
            
            // Calculate and save affirmation text
            await saveForsideData();
            
            // Load saved data
            const savedData = loadForsideData();
            if (savedData) {
                console.log('Forside data indl√¶st:', savedData);
                console.log('Affirmation tekst:', savedData.tekst);
            }
            
            await loadAnimations();
            const guideFigure = document.getElementById('guideFigure');
            if (guideFigure) {
                applyPoseToFigure(guideFigure);
                
                // Function to play vinke animation with 10 second pause
                function playVinkeWithPause() {
                    if (animationsLibrary.vinke) {
                        runAnimation('vinke', () => {
                            // After animation completes, wait 10 seconds then play again
                            setTimeout(playVinkeWithPause, 10000);
                        });
                    }
                }
                
                // Start first animation after 2 seconds
                setTimeout(playVinkeWithPause, 2000);
            }
        }
        
        // Start when page loads
        init();
        
        // Navigation box toggle
        function toggleNavBox() {
            const navBox = document.getElementById('navBox');
            
            if (navBox) {
                navBox.classList.toggle('show');
            }
        }
        
        // Save check-in data when coaching overlay closes
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCl6ZYtkfYx3kFF9329eGpeazsmJAPMKzA",
            authDomain: "relationer-fe5fe.firebaseapp.com",
            projectId: "relationer-fe5fe",
            storageBucket: "relationer-fe5fe.firebasestorage.app",
            messagingSenderId: "156720560629",
            appId: "1:156720560629:web:1a138e4e89f02a131f88bc",
            measurementId: "G-K5W7J8JHZG"
        };
        
        // Initialize Firebase
        let auth = null;
        let db = null;
        let currentUser = null;
        
        // Global cache of all user-related Firestore data (shared via window)
        // {
        //   bodymapData,
        //   dialogData,
        //   opstillingData,
        //   compareData,
        //   logbogData
        // }
        // NOTE: forside_checkin_data is deprecated - now using logbogData.checkins
        window.allUserData = window.allUserData || null;
        window.allDataLoadingPromise = window.allDataLoadingPromise || null;
        
        // Flag for save operation tracking
        let isSavingData = false;
        
        try {
            firebase.initializeApp(firebaseConfig);
            auth = firebase.auth();
            db = firebase.firestore();
            
            console.log('Firebase initialized in checkin.html');
        } catch (error) {
            console.error('Firebase initialization error:', error);
        }
        
        // Check auth state - create a promise that resolves when auth state is determined
        let authStatePromise = Promise.resolve();
        let authStateResolver = null;
        let authStateReady = false;
        
        if (auth) {
            authStatePromise = new Promise((resolve) => {
                authStateResolver = resolve;
            });
            
            auth.onAuthStateChanged(user => {
                currentUser = user;
                
                // Mark auth as ready and resolve promise
                if (!authStateReady) {
                    authStateReady = true;
                    if (authStateResolver) {
                        authStateResolver();
                        authStateResolver = null;
                    }
                } else {
                    // Reload night overlay data when auth state changes after initial load
                    if (document.readyState === 'complete') {
                        hydrateNightOverlay();
                    }
                }
            });
        }
        
        // Helper function to detect user timezone (same as index.html)
        function detectUserTimezone() {
            try {
                return Intl.DateTimeFormat().resolvedOptions().timeZone || 'Europe/Copenhagen';
            } catch (e) {
                console.warn('Kunne ikke auto-detecte timezone:', e);
            }
            return 'Europe/Copenhagen';
        }

        // Ensure indexuserData is set with "You" value from Firestore
        // This is needed for coaching to work properly
        async function ensureIndexUserData() {
            if (!currentUser || !db) return;
            
            // Check if indexuserData already has a "You" value
            try {
                const existingData = localStorage.getItem('indexuserData');
                if (existingData) {
                    const parsed = JSON.parse(existingData);
                    if (parsed.You && parsed.You.trim() !== '') {
                        console.log('[indexuserData] Already has "You" value:', parsed.You);
                        return; // Already has valid "You" value
                    }
                }
            } catch (e) {
                console.warn('[indexuserData] Error parsing existing data:', e);
            }
            
            // Need to fetch userData from Firestore
            try {
                console.log('[indexuserData] Missing "You" value - fetching from Firestore...');
                const userDocRef = db.collection('users').doc(currentUser.uid);
                const doc = await userDocRef.get();
                
                if (doc.exists) {
                    const data = doc.data();
                    const userData = data.userData || null;
                    
                    if (userData) {
                        const dataToSave = {
                            ...userData,
                            You: userData.displayName || '',
                            timezone: userData.timezone || detectUserTimezone()
                        };
                        localStorage.setItem('indexuserData', JSON.stringify(dataToSave));
                        console.log('[indexuserData] Saved to localStorage:', dataToSave);
                    } else {
                        // userData doesn't exist in Firestore
                        const dataToSave = {
                            timezone: detectUserTimezone()
                        };
                        localStorage.setItem('indexuserData', JSON.stringify(dataToSave));
                        console.log('[indexuserData] No userData in Firestore, created with timezone');
                    }
                } else {
                    console.warn('[indexuserData] User document not found in Firestore');
                }
            } catch (error) {
                console.error('[indexuserData] Error fetching from Firestore:', error);
            }
        }

        // Helper: Get month key from date (YYYY-MM format)
        function getMonthKey(date = null) {
            const d = date ? new Date(date) : new Date();
            if (isNaN(d.getTime())) return null;
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            return `${year}-${month}`;
        }
        
        // Helper: Get months to load based on current date
        function getMonthsToLoad() {
            const now = new Date();
            const currentMonthKey = getMonthKey(now);
            const dayOfMonth = now.getDate();
            
            const monthsToLoad = [currentMonthKey];
            
            // If before the 7th, also load previous month
            if (dayOfMonth <= 7) {
                const prevMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                const prevMonthKey = getMonthKey(prevMonth);
                monthsToLoad.push(prevMonthKey);
            }
            
            return monthsToLoad;
        }
        
        // Helper: Load data for specific month from Firestore
        async function loadMonthData(monthKey) {
            if (!currentUser || !db) return null;
            
            try {
                const userDocRef = db.collection('users').doc(currentUser.uid);
                console.log(`üî• FIRESTORE READ - checkin.html - loadMonthData(${monthKey})`);
                const doc = await userDocRef.get();
                if (!doc.exists) return null;
                
                const raw = doc.data() || {};
                const monthData = raw[monthKey];
                
                if (!monthData || typeof monthData !== 'object') {
                    return null;
                }
                
                return monthData;
            } catch (error) {
                console.error(`[LOAD] Error loading month data for ${monthKey}:`, error);
                return null;
            }
        }
        
        // Helper: Merge data from multiple months into flat structure
        function mergeMonthlyData(monthsData) {
            const merged = {
                bodymapData: { dataIndexes: [] },
                dialogData: { dialogs: [] },
                opstillingData: { setups: [] },
                compareData: { comparisons: [] },
                logbogData: []
            };
            
            monthsData.forEach(monthData => {
                if (!monthData) return;
                
                // Merge bodymap
                if (monthData.bodymap && Array.isArray(monthData.bodymap.dataIndexes)) {
                    merged.bodymapData.dataIndexes.push(...monthData.bodymap.dataIndexes);
                }
                
                // Merge dialog
                if (monthData.dialog && Array.isArray(monthData.dialog.dialogs)) {
                    merged.dialogData.dialogs.push(...monthData.dialog.dialogs);
                }
                
                // Merge opstilling
                if (monthData.opstilling && Array.isArray(monthData.opstilling.setups)) {
                    merged.opstillingData.setups.push(...monthData.opstilling.setups);
                }
                
                // Merge compare
                if (monthData.compare && Array.isArray(monthData.compare.comparisons)) {
                    merged.compareData.comparisons.push(...monthData.compare.comparisons);
                }
                
                // Merge logbog
                if (Array.isArray(monthData.logbog)) {
                    merged.logbogData.push(...monthData.logbog);
                }
            });
            
            return merged;
        }
        
        // Load all user data (cached across the page, shared via window)
        // Note: logbogData is NOT loaded here - it's only loaded when needed for night overlay
        async function loadAllUserData(forceRefresh = false) {
            if (!currentUser || !db) return null;
            
            if (!forceRefresh && window.allUserData) {
                return window.allUserData;
            }
            
            if (!forceRefresh && window.allDataLoadingPromise) {
                return window.allDataLoadingPromise;
            }
            
            window.allDataLoadingPromise = (async () => {
                try {
                    const userDocRef = db.collection('users').doc(currentUser.uid);
                    console.log('üî• FIRESTORE READ - checkin.html - loadAllUserData');
                    const doc = await userDocRef.get();
                    const raw = doc.exists ? (doc.data() || {}) : {};
                    
                    // Check if data is in new monthly structure
                    const userData = raw.userData || {};
                    const registreringer = userData.registreringer || {};
                    const hasMonthlyStructure = Object.keys(registreringer).length > 0 || 
                                                 Object.keys(raw).some(key => /^\d{4}-\d{2}$/.test(key));
                    
                    if (hasMonthlyStructure) {
                        // New monthly structure
                        const monthsToLoad = getMonthsToLoad();
                        const monthsData = await Promise.all(
                            monthsToLoad.map(monthKey => loadMonthData(monthKey))
                        );
                        
                        const merged = mergeMonthlyData(monthsData);
                        
                        const data = {
                            bodymapData: merged.bodymapData.dataIndexes.length > 0 ? merged.bodymapData : null,
                            dialogData: merged.dialogData.dialogs.length > 0 ? merged.dialogData : null,
                            opstillingData: merged.opstillingData.setups.length > 0 ? merged.opstillingData : null,
                            compareData: merged.compareData.comparisons.length > 0 ? merged.compareData : null,
                            logbogData: merged.logbogData.length > 0 ? merged.logbogData : [],
                            userData: userData,
                            registreringer: registreringer,
                            loadedMonths: monthsToLoad
                        };
                        
                        window.allUserData = data;
                        return data;
                    } else {
                        // Old structure (backward compatibility)
                        const data = {
                            bodymapData: raw.bodymapData || null,
                            dialogData: raw.dialogData || null,
                            opstillingData: raw.opstillingData || null,
                            compareData: raw.compareData || null,
                            logbogData: Array.isArray(raw.logbogData) ? raw.logbogData : [],
                            // forside_checkin_data is deprecated - now using logbogData.checkins
                            forside_checkin_data: Array.isArray(raw.forside_checkin_data) ? raw.forside_checkin_data : null
                        };
                        window.allUserData = data;
                        return data;
                    }
                } catch (error) {
                    console.error('[LOAD] Error loading all user data in checkin.html:', error);
                    window.allUserData = null;
                    return null;
                } finally {
                    window.allDataLoadingPromise = null;
                }
            })();
            
            return window.allDataLoadingPromise;
        }
        
        // Helper: Get or create month data structure
        function getOrCreateMonthData(monthKey) {
            return {
                bodymap: { dataIndexes: [] },
                compare: { comparisons: [] },
                logbog: [],
                opstilling: { setups: [] }
            };
        }
        
        // Helper: Update registreringer with logbog count for a month
        // Helper: Update registreringer with count for a specific data type and month
        async function updateRegistreringer(monthKey, dataType, count) {
            if (!currentUser || !db) return;
            
            try {
                const userDocRef = db.collection('users').doc(currentUser.uid);
                const doc = await userDocRef.get();
                const raw = doc.exists ? (doc.data() || {}) : {};
                const userData = raw.userData || {};
                const registreringer = userData.registreringer || {};
                
                // Initialize month object if it doesn't exist
                if (!registreringer[monthKey]) {
                    registreringer[monthKey] = {};
                }
                
                // Update count for this data type
                if (count > 0) {
                    registreringer[monthKey][dataType] = String(count);
                } else {
                    // Remove data type from month if count is 0
                    delete registreringer[monthKey][dataType];
                }
                
                // Remove month from registreringer if it has no data types left
                if (Object.keys(registreringer[monthKey]).length === 0) {
                    delete registreringer[monthKey];
                }
                
                await userDocRef.set({
                    userData: {
                        ...userData,
                        registreringer: registreringer
                    },
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
                
                // Update cache
                if (window.allUserData) {
                    window.allUserData.registreringer = registreringer;
                }
            } catch (error) {
                console.error('[SAVE] Error updating registreringer:', error);
            }
        }
        
        // Save check-in data to logbogData using cached data (monthly structure)
        async function saveCheckinDataToFirestore(engine) {
            if (!currentUser || !db) return;
            
            const status = engine.blackboard.status;
            const taknem = engine.blackboard.taknem;
            
            if (status === undefined || taknem === undefined || taknem === null || taknem === '') {
                return;
            }
            
            try {
                // Make sure affirmations are loaded
                if (affirmations.length === 0) {
                    await loadAffirmations();
                }
                
                // Get affirmation text for today
                const affirmText = getAffirmationText();
                
                // Get current time in HH:MM format
                const now = new Date();
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const timeStr = `${hours}:${minutes}`;
                
                // Get today's date key
                const dateKey = getTodayDateKey();
                const monthKey = dateKey.substring(0, 7); // YYYY-MM
                
                // Save to Firestore (monthly structure)
                const userDocRef = db.collection('users').doc(currentUser.uid);
                const doc = await userDocRef.get();
                const raw = doc.exists ? (doc.data() || {}) : {};
                
                // Check if data is in new monthly structure
                const userData = raw.userData || {};
                const registreringer = userData.registreringer || {};
                const hasMonthlyStructure = Object.keys(registreringer).length > 0 || 
                                             Object.keys(raw).some(key => /^\d{4}-\d{2}$/.test(key));
                
                if (hasMonthlyStructure) {
                    // New monthly structure: Load existing month data from Firestore first
                    const monthDocRef = userDocRef.collection('months').doc(monthKey);
                    const monthDoc = await monthDocRef.get();
                    const existingMonthData = monthDoc.exists ? (monthDoc.data() || {}) : {};
                    
                    // Get existing logbog entries for this month (or empty array)
                    let monthLogbogEntries = Array.isArray(existingMonthData.logbog) ? existingMonthData.logbog : [];
                    
                    // Find or create entry for today
                    let entry = monthLogbogEntries.find(item => item.date === dateKey);
                    if (!entry) {
                        entry = {
                            date: dateKey,
                            dagbog: '',
                            dreams: '',
                            checkins: [],
                            timestamp: now.toISOString(),
                            color: '#b8735e'
                        };
                        monthLogbogEntries.push(entry);
                    }
                    
                    // Initialize checkins array if it doesn't exist
                    if (!Array.isArray(entry.checkins)) {
                        entry.checkins = [];
                    }
                    
                    // Add new check-in to the array
                    entry.checkins.push({
                        time: timeStr,
                        status: Number(status)
                    });
                    
                    // Update taknem and affirm (latest values win)
                    entry.taknem = String(taknem);
                    entry.affirm = affirmText || '';
                    
                    // Update timestamp
                    entry.timestamp = now.toISOString();
                    
                    // Get old count before updating
                    const oldCount = existingMonthData.logbog ? existingMonthData.logbog.length : 0;
                    const newCount = monthLogbogEntries.length;
                    
                    // Update logbog array for this month
                    existingMonthData.logbog = monthLogbogEntries;
                    
                    // Save to subcollection
                    await monthDocRef.set(existingMonthData, { merge: true });
                    
                    // Only update registreringer if count changed
                    if (oldCount !== newCount) {
                        await updateRegistreringer(monthKey, 'logbog', newCount);
                    }
                    
                    // Update cache with merged data
                    if (window.allUserData) {
                        // Reload all user data to update cache properly
                        await loadAllUserData(true);
                    }
                    
                    // Update main document timestamp and lastCheckinDate in userData
                    await userDocRef.set({
                        userData: {
                            ...userData,
                            lastCheckinDate: dateKey // Store today's date as last check-in date
                        },
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });
                } else {
                    // Old structure (backward compatibility)
                    await userDocRef.set({
                        logbogData: logbogData,
                        userData: {
                            ...userData,
                            lastCheckinDate: dateKey // Store today's date as last check-in date
                        },
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });
                }
                
                // Update cache directly without reading from Firestore
                if (window.allUserData) {
                    window.allUserData.logbogData = logbogData;
                    if (window.allUserData.userData) {
                        window.allUserData.userData.lastCheckinDate = dateKey;
                    } else {
                        window.allUserData.userData = { lastCheckinDate: dateKey };
                    }
                }
                
                console.log(`[SAVE] Check-in saved to logbogData for ${dateKey} at ${timeStr}`);
            } catch (error) {
                console.error('[SAVE] Error saving check-in data to logbogData:', error);
            }
        }
        
        // Load check-in data from logbogData via Firestore
        async function loadCheckinDataFromFirestore() {
            if (!currentUser || !db) return null;
            
            try {
                const logbogData = await getLogbookEntries();
                console.log('[LOAD] Check-in data loaded from logbogData');
                return logbogData;
            } catch (error) {
                console.error('[LOAD] Error loading check-in data from logbogData:', error);
                return null;
            }
        }

        // Check if user has already checked in today
        async function hasCheckedInToday() {
            try {
                const todayKey = getTodayDateKey();
                
                if (!currentUser || !db) {
                    return false;
                }
                
                const userDocRef = db.collection('users').doc(currentUser.uid);
                const doc = await userDocRef.get();
                
                if (doc.exists) {
                    const raw = doc.data() || {};
                    const userData = raw.userData || {};
                    const lastCheckinDate = userData.lastCheckinDate;
                    
                    // If lastCheckinDate matches today, user has already checked in
                    return lastCheckinDate === todayKey;
                }
                
                return false;
            } catch (error) {
                console.error('[CHECK] Error checking if user has checked in today:', error);
                return false;
            }
        }
        
        // Main save function - always saves to Firestore if user is logged in
        async function saveCheckinData(engine) {
            if (!engine || !engine.blackboard) {
                console.log('[SAVE_CHECKIN] No engine or blackboard');
                return;
            }
            
            if (!currentUser || !db) {
                console.error('[SAVE_CHECKIN] User not logged in - cannot save data');
                return;
            }
            
            const status = engine.blackboard.status;
            const taknem = engine.blackboard.taknem;
            
            console.log('[SAVE_CHECKIN] Blackboard state:', { status, taknem, fullBlackboard: JSON.stringify(engine.blackboard) });
            
            // Only save if both status and taknem exist
            if (status !== undefined && taknem !== undefined && taknem !== null && taknem !== '') {
                isSavingData = true;
                try {
                    await saveCheckinDataToFirestore(engine);
                    console.log('[SAVE_CHECKIN] Successfully saved status:', status, 'taknem:', taknem);
                } catch (error) {
                    console.error('[SAVE_CHECKIN] Error saving:', error);
                } finally {
                    isSavingData = false;
                }
            } else {
                console.warn('[SAVE_CHECKIN] Skipped save - status:', status, 'taknem:', taknem);
            }
        }
        
        // Listen for coaching overlay closing event
        window.addEventListener('coachingOverlayClosing', (event) => {
            if (event.detail && event.detail.engine) {
                saveCheckinData(event.detail.engine);
            }
        });

    </script>
</body>
</html>
