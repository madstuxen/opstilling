<!DOCTYPE html>
<html lang="da">
<head>
	<script src="https://cdn.jsdelivr.net/npm/modern-screenshot@4.4.39/dist/index.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relations Opstilling - Multi-Background System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            padding: 5px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.0em;
            margin-bottom: 10px;
            font-weight: 300;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .toolbar {
            background: #f8fafc;
            padding: 12px 20px;

            border-bottom: 1px solid #e2e8f0;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .toolbar select, .toolbar input, .toolbar button {
			padding: 8px 16px;
			border: 2px solid #e2e8f0;
			border-radius: 10px;
			font-size: 15px;
			transition: all 0.3s ease;
		}
        
        .toolbar select {
            background: white;
            min-width: 180px;
            font-family: inherit;
        }
        
        .toolbar input[type="text"] {
            flex: 1;
            min-width: 200px;
            background: white;
        }

        /* Limit part name input width */
        #partName {
            max-width: 250px;
        }
        
        .toolbar input[type="text"]:focus, .toolbar select:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        .toolbar button {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
            min-width: 120px;
        }
        
        .toolbar button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }
        
        .clear-btn {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important;
        }
        
        .clear-btn:hover {
            box-shadow: 0 5px 15px rgba(239, 68, 68, 0.3) !important;
        }
        
        .save-btn {
			background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%) !important;
		}

		.save-btn:hover {
			box-shadow: 0 5px 15px rgba(139, 92, 246, 0.3) !important;
		}
        
		.export-btn {
			background: linear-gradient(135deg, #f97316 0%, #ea580c 100%) !important;
		}

		.export-btn:hover {
			box-shadow: 0 5px 15px rgba(249, 115, 22, 0.3) !important;
		}
		
		
        .load-btn {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%) !important;
        }
        
        .load-btn:hover {
            box-shadow: 0 5px 15px rgba(6, 182, 212, 0.3) !important;
        }
        
        .nav-btn {
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%) !important;
        }
        
        .nav-btn:hover {
            box-shadow: 0 5px 15px rgba(99, 102, 241, 0.3) !important;
        }
        
        .nav-btn-yellow {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%) !important;
        }
        
        .nav-btn-yellow:hover {
            box-shadow: 0 5px 15px rgba(245, 158, 11, 0.3) !important;
        }
        
        .toolbar-separator {
            width: 1px;
            height: 30px;
            background: #e2e8f0;
            margin: 0 8px;
            flex-shrink: 0;
        }
        
        .workspace {
            height: 600px;
            position: relative;
            background: #fafafa;
            overflow: hidden;
            cursor: crosshair;
            touch-action: auto;
        }
        
        .background-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        
        .background-labels {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: auto;
        }
        
        .label-input {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 14px;
            font-weight: 500;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 80px;
            transform: translate(-50%, -50%);
        }
        
        .label-input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3);
        }
        
        .part {
				position: absolute;
				width: 80px;
				height: 80px;
				cursor: move;
                transition: transform 0.44s ease-in-out, filter 0.44s ease-in-out;
				user-select: none;
                -webkit-user-select: none;
				touch-action: none;
				z-index: 10;
				will-change: transform;
				backface-visibility: hidden;
			}

/* Disable transitions while dragging to avoid lag/hitches */
.part.dragging {
    transition: none !important;
}

.part:hover {
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.25)) brightness(1.0);
    z-index: 100;
}

			.part.dragging {
                transition: filter 0.44s ease-in-out;
				filter: drop-shadow(0 4px 8px rgba(0,0,0,0.25)) brightness(1.0);
				z-index: 1000;
			}

			.part.selected {
				box-shadow: 0 0 0 2px #4f46e5, 0 0 0 4px rgba(79, 70, 229, 0.3);
			}
        
			/* Global body toggle - skjul kun torso, arme og ben */
			.hide-bodies .torso,
			.hide-bodies .skulder_translate_left,
			.hide-bodies .skulder_translate_right,
			.hide-bodies .hofte_translate_left,
			.hide-bodies .hofte_translate_right {
				display: none !important;
			}
		
		.head {
			position: absolute;
			top: -74px; left: 50%; transform: translateX(-50%);
			width:72px;
			height: 72px;
			border-radius: 50%;
			background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
			display: flex;
			align-items: center;
			justify-content: center;
			color: white;
			font-weight: bold;
			font-size: 12px;
			text-align: center;
			box-shadow: 0 8px 25px rgba(0,0,0,0.15);
			
			padding: 10px;
			line-height: 1.2;
			z-index: 5;
		}
		
			.head {
		pointer-events: auto;
		}

		.part-name {
			pointer-events: auto;
			cursor: text;
			font-size: 12px;
		}
		.part-name:hover {
			text-decoration: underline;
		}
				
        /* Krop (underkomponent af part) */
        .body {
            position: absolute;
            top: 77px;
            left: 50%;
            transform: translateX(-50%);
            transform-origin: 40px -77px;
            transition: transform 0.2s ease-out;
            z-index: -1;
            pointer-events: none;
            will-change: transform;
            backface-visibility: hidden;
        }
        
        /* Disable transitions during drag to avoid conflicts */
        .part.dragging .body {
            transition: none;
        }
        
        /* Also disable transitions when settling back to neutral */
        .body {
            transition: none !important;
        }
        
        
        /* Torso */
        .torso {
            width: 60px;
            height: 80px;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            margin: 0 auto;
            border-radius: 30px 30px 20px 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            position: relative;
            z-index: 5;
        }
        
       /* Højre arm hierarki */
		.skulder_translate_right {
			position: absolute;
			top: 2px;
			left: 41px;
			width: 15px;
			height: 15px;
			background: rgba(59, 130, 246, 0.0);
			z-index: 3;
		}

		.skulder_translate_right.front-arm {
			z-index: 15;
		}

		.skulder_rotate_right {
			width: 100%;
			height: 100%;
			background: rgba(239, 68, 68, 0.0);
			transform-origin: center center;
		}

		.arm_geo_right {
			width: 50px;
			height: 18px;
			background: #f59e0b;
			border-radius: 9px;
			position: relative;
			top: -1px;
			left: -1px;
		}

		.albue_rotate_right {
			position: relative;
			top: 1px;
			left: 34px;
			width: 15px;
			height: 15px;
			background: rgba(16, 185, 129, 0.0);
			transform-origin: center center;
		}

		.albue_geo_right {
			position: relative;
			top: -1px;
			left: 1px;
			width: 50px;
			height: 18px;
			background: #f59e0b;
			border-radius: 9px;
			z-index: 4;
		}

		.albue_geo_right.front {
			z-index: 20 !important;
			position: relative;
		}

		/* Venstre arm hierarki */
		.skulder_translate_left {
			position: absolute;
			top: 2px;
			left: 4px;
			width: 15px;
			height: 15px;
			background: rgba(59, 130, 246, 0.0);
			z-index: 3;
		}

		.skulder_translate_left.front-arm {
			z-index: 15;
		}

		.skulder_rotate_left {
			width: 100%;
			height: 100%;
			background: rgba(239, 68, 68, 0.0);
			transform-origin: center center;
		}

		.arm_geo_left {
			width: 50px;
			height: 18px;
			background: #f59e0b;
			border-radius: 9px;
			position: relative;
			top: -1px;
			left: -34px;
		}

		.albue_rotate_left {
			position: relative;
			top: 1px;
			left: 0px;
			width: 15px;
			height: 15px;
			background: rgba(16, 185, 129, 0.0);
			transform-origin: center center;
		}

		.albue_geo_left {
			position: relative;
			top: -1px;
			left: -33px;
			width: 50px;
			height: 18px;
			background: #f59e0b;
			border-radius: 9px;
			z-index: 4;
		}

		.albue_geo_left.front {
			z-index: 20 !important;
			position: relative;
		}

		/* Højre ben hierarki */
		.hofte_translate_right {
			position: absolute;
			top: 68px;
			left: 40px;
			width: 15px;
			height: 15px;
			background: rgba(59, 130, 246, 0.0);
		}

		.hofte_rotate_right {
			width: 100%;
			height: 100%;
			background: rgba(239, 68, 68, 0.0);
			transform-origin: center center;
		}

		.laar_geo_right {
			width: 18px;
			height: 55px;
			background: #f59e0b;
			border-radius: 9px;
			position: relative;
			top: -1px;
			left: -1px;
		}

		.knae_rotate_right {
			position: relative;
			top: 38px;
			left: 1px;
			width: 15px;
			height: 15px;
			background: rgba(16, 185, 129, 0.0);
			transform-origin: center center;
		}

		.skinneben_geo_right {
			position: relative;
			top: -1px;
			left: -1px;
			width: 18px;
			height: 50px;
			background: #f59e0b;
			border-radius: 9px;
		}

		/* Venstre ben hierarki */
		.hofte_translate_left {
			position: absolute;
			top: 68px;
			left: 4px;
			width: 15px;
			height: 15px;
			background: rgba(59, 130, 246, 0.0);
		}

		.hofte_rotate_left {
			width: 100%;
			height: 100%;
			background: rgba(239, 68, 68, 0.0);
			transform-origin: center center;
		}

		.laar_geo_left {
			width: 18px;
			height: 55px;
			background: #f59e0b;
			border-radius: 9px;
			position: relative;
			top: -1px;
			left: -1px;
		}

		.knae_rotate_left {
			position: relative;
			top: 38px;
			left: 1px;
			width: 15px;
			height: 15px;
			background: rgba(16, 185, 129, 0.0);
			transform-origin: center center;
		}

		.skinneben_geo_left {
			position: relative;
			top: -1px;
			left: -1px;
			width: 18px;
			height: 50px;
			background: #f59e0b;
			border-radius: 9px;
		}
		
		
		
		
        .part-keywords {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            color: #374151;
            font-size: 12px;
            text-align: center;
            font-weight: normal;
            line-height: 1.1;
            width: 100px;
            white-space: nowrap;
            z-index: 15;
        }
        
        .keywords-above {
            bottom: calc(50% + 15px);
        }
        
        .keywords-below {
            top: calc(50% + 15px);
        }
        
        .control-btn {
            position: absolute;
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            font-size: 14px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            z-index: 1000;
            color: white;
            padding: 0;
            margin: 0;
            top: 50%;
            left: 50%;
            transform-origin: center center;
            pointer-events: none;
        }

        .part:hover .control-btn {
            display: flex !important;
            pointer-events: auto;
        }

        /* On mobile (tap selection), show controls when selected too */
        .part.selected .control-btn {
            display: flex !important;
            pointer-events: auto;
        }
        
        .delete-btn {
            transform: translate(18px, -52px);
            background: #ef4444;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
        }
        
        .layer-up {
            transform: translate(-52px, -52px);
            background: #4f46e5;
            box-shadow: 0 2px 8px rgba(79, 70, 229, 0.3);
        }
        
        .size-plus {
            transform: translate(-17px, -52px);
            background: #059669;
            box-shadow: 0 2px 8px rgba(5, 150, 105, 0.3);
        }
        
        .edit-btn {
            transform: translate(18px, -17px);
            background: #f59e0b;
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
        }
        
        .layer-down {
            transform: translate(-52px, 18px);
            background: #4f46e5;
            box-shadow: 0 2px 8px rgba(79, 70, 229, 0.3);
        }
        
        .size-minus {
            transform: translate(-17px, 18px);
            background: #059669;
            box-shadow: 0 2px 8px rgba(5, 150, 105, 0.3);
        }

        .color-btn {
            transform: translate(18px, 18px);
            background: #a855f7;
            box-shadow: 0 2px 8px rgba(168, 85, 247, 0.3);
        }
		
		.pose-btn {
			transform: translate(18px, -17px);
			background: #06b6d4;
			box-shadow: 0 2px 8px rgba(6, 182, 212, 0.3);
		}


        
        .delete-btn:hover {
            transform: translate(18px, -52px) scale(1.1);
            background: #dc2626;
        }
        
        .layer-up:hover {
            transform: translate(-52px, -52px) scale(1.1);
            background: #3730a3;
        }
        
        .size-plus:hover {
            transform: translate(-17px, -52px) scale(1.1);
            background: #047857;
        }
        
        .edit-btn:hover {
            transform: translate(18px, -17px) scale(1.1);
            background: #b8650c;
        }
        
        .layer-down:hover {
            transform: translate(-52px, 18px) scale(1.1);
            background: #3730a3;
        }
        
        .size-minus:hover {
            transform: translate(-17px, 18px) scale(1.1);
            background: #047857;
        }

        .color-btn:hover {
            transform: translate(18px, 18px) scale(1.1);
            background: #9333ea;
        }
		
		.pose-btn:hover {
			transform: translate(18px, -17px) scale(1.1);
			background: #0891b2;
		}
				
        /* Color Picker Styles */
        .color-picker-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }
        
        .color-picker-modal.show {
            display: flex;
        }
        
        .picker {
            width: 224px;
            background: #ffffff;
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border: 1px solid #e2e8f0;
        }
        
        .swatch {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            border: 1px solid rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .swatch:hover {
            transform: scale(1.2);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 10;
        }
        
        .color-grid {
            display: grid;
            grid-template-columns: repeat(12, 15px);
            grid-template-rows: repeat(14, 15px);
            gap: 2px;
            background: transparent;
        }
        
        .swatch:focus {
            outline: 2px solid #4f46e5;
            outline-offset: 1px;
        }
		
		
		/* Pose Picker Styles */
		.pose-picker-modal {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: transparent;
			display: none;
			align-items: center;
			justify-content: center;
			z-index: 3000;
		}

		.pose-picker-modal.show {
			display: flex;
		}

		.pose-picker {
			width: 280px;
			background: #ffffff;
			padding: 15px;
			border-radius: 12px;
			box-shadow: 0 10px 30px rgba(0,0,0,0.2);
			border: 1px solid #e2e8f0;
		}

		.pose-mirror-section {
			text-align: center;
			margin-bottom: 15px;
			padding-bottom: 10px;
			border-bottom: 1px solid #e2e8f0;
		}

		.pose-mirror-label {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 8px;
			font-size: 14px;
			font-weight: 500;
			color: #374151;
			cursor: pointer;
		}

		.pose-mirror-label input[type="checkbox"] {
			width: 16px;
			height: 16px;
			transform: scale(1.2);
		}

		.pose-grid {
			display: grid;
			grid-template-columns: repeat(3, 1fr);
			gap: 8px;
		}

		.pose-button {
			padding: 8px 12px;
			border: 2px solid #e2e8f0;
			border-radius: 8px;
			background: white;
			color: #374151;
			font-size: 12px;
			font-weight: 500;
			cursor: pointer;
			transition: all 0.2s ease;
			text-align: center;
		}

		.pose-button:hover {
			border-color: #3b82f6;
			background: #f0f9ff;
			color: #1d4ed8;
		}

		.pose-button.active {
			border-color: #3b82f6;
			background: #3b82f6;
			color: white;
		}
		
		
		
        
        .instructions {
            padding: 20px;
            background: #f1f5f9;
            color: #475569;
            text-align: center;
            border-top: 1px solid #e2e8f0;
        }
        
        .notes-title {
            background: #f8fafc;
            padding: 15px 20px 5px 20px;
            border-top: 1px solid #e2e8f0;
            text-align: center;
        }
        
        .notes-title h3 {
            margin: 0;
            color: #475569;
            font-size: 18px;
            font-weight: 600;
        }
        
        .notes-section {
            background: #f8fafc;
            padding: 15px 20px 20px 20px;
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: 30px;
        }
        
        .notes-content {
            display: flex;
            gap: 30px;
            width: 100%;
        }
        
        .groups-section {
			flex: 0 0 250px;
			min-width: 250px;
		}
        
        .groups-section h4 {
            margin: 0 0 10px 0;
            color: #475569;
            font-size: 16px;
        }
        
        .group-input-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .group-input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            background: white;
        }
        
        .group-color-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: none;
            background: #ef4444;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
            flex-shrink: 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .group-color-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .keywords-section {
            flex: 0 0 300px;
            min-width: 300px;
            max-width: 300px;
        }
        
        .keywords-section h4 {
            margin: 0 0 10px 0;
            color: #475569;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .visibility-checkbox {
            margin-right: 8px;
            transform: scale(1.2);
        }
        
        .keyword-input {
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 8px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            background: white;
        }
        
        .group-dropdown {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            background: white;
            margin-bottom: 10px;
        }
        
        .group-input:focus, .keyword-input:focus, .group-dropdown:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        .notes-container {
            flex: 1;
            min-width: 300px;
        }
        
        .notes-container h4 {
            margin: 0 0 10px 0;
            color: #475569;
            font-size: 16px;
        }
        
        .notes-section textarea {
            width: 100%;
            min-height: 256px;
            padding: 15px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 16px;
            font-family: inherit;
            background: white;
            resize: vertical;
        }
        
        .notes-section textarea:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        .notes-section p {
            margin: 10px 0 0 0;
            font-size: 14px;
            color: #6b7280;
        }
        
        .name-input {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #4f46e5;
            border-radius: 8px;
            padding: 4px 8px;
            font-size: inherit;
            font-weight: bold;
            text-align: center;
            color: #1f2937;
            width: 90%;
            max-width: 100px;
        }
        
        .name-input:focus {
            outline: none;
            border-color: #7c3aed;
            box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.3);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }
        
        .part {
            animation: fadeIn 0.5s ease-out;
        }
		
		/* Keywords Popup Modal */
.keywords-popup-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: transparent;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 3000;
}

.keywords-popup-modal.show {
    display: flex;
}

.keywords-popup {
    width: 400px;
    background: #ffffff;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    border: 1px solid #e2e8f0;
}

.keywords-popup h3 {
    margin: 0 0 15px 0;
    color: #374151;
    font-size: 18px;
}

.keywords-popup-input {
    width: 100%;
    padding: 8px 12px;
    margin-bottom: 10px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 14px;
    font-family: inherit;
    background: white;
}

.keywords-popup-input:focus {
    outline: none;
    border-color: #4f46e5;
    box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
}

.keywords-popup-button {
    width: 100%;
    padding: 12px;
    background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    margin-top: 10px;
}

.keywords-popup-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(79, 70, 229, 0.3);
}




		
		
		
    	/* Mobile adjustments */
	@media (hover: none) and (pointer: coarse) {
		body {
			padding: 5px;
		}
		.container {
			border-radius: 12px;
		}
    		.header {
			padding: 5px;
    		}
		.header h1 {
			font-size: 2.0em;
			margin-bottom: 0;
		}
		.toolbar {
			padding: 8px 12px;
			gap: 10px;
		}
		.toolbar select, .toolbar input, .toolbar button {
			padding: 6px 10px;
			font-size: 13px;
			border-radius: 8px;
			min-width: auto;
		}
		.workspace {
			height: 65vh;
			overflow: auto;
			-webkit-overflow-scrolling: touch;
			touch-action: pan-x pan-y;
		}
		.notes-title h3 { font-size: 16px; }
		.groups-section h4, .keywords-section h4, .notes-container h4 { font-size: 14px; }
		.keyword-input, .group-input, .group-dropdown { font-size: 13px; }
		/* Make notes section horizontally scrollable on touch */
		.notes-section {
			overflow-x: auto;
			-webkit-overflow-scrolling: touch;
		}
		.notes-content {
			min-width: 900px; /* ensure content wider than viewport so it can scroll */
			gap: 20px;
		}
		.groups-section, .keywords-section, .notes-container {
			flex: 0 0 auto; /* prevent shrinking so horizontal scroll works */
		}
		/* Scale pose picker on mobile to half size */
		.pose-picker {
			transform: scale(0.5);
			transform-origin: top left;
		}
    	}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Opstilling</h1>
        </div>
        
        <div class="toolbar">
			
			<select id="themeSelect" onchange="changeTheme()">
				<option value="">Vælg tema...</option>
				<option value="ifs_default">IFS Standard</option>
				<option value="Skygge">Skyggearbejde</option>
			</select>
			
			
            <select id="backgroundSelect" onchange="changeBackground()">
                <option value="none">Ingen baggrund</option>
                <option value="har_onsker">Har/Ønsker</option>
                <option value="xy_axes">X/Y Akser</option>
                <option value="timeline">Tidslinje</option>
                <option value="for_imod">For/Imod</option>
                <option value="drama_trekant">Drama Trekant</option>
				<option value="mandala">Mandala Cirkel</option>
            </select>
            <input type="text" id="partName" placeholder="Navn på del (f.eks. Beskytteren, Den Kritiske, Det Sårede Barn...)" maxlength="30">
            <button onclick="addPart()">Tilføj Del</button>
            <button onclick="saveSetup()" class="save-btn">Gem Opstilling</button>
            <button onclick="loadSetup()" class="load-btn">Indlæs Opstilling</button>
            <button onclick="exportAsImage()" class="export-btn">Gem Billede</button>
            <button onclick="clearAll()" class="clear-btn">Ryd Alt</button>
            <div class="toolbar-separator"></div>
            <button onclick="window.location.href='compare_01.html'" class="nav-btn">Forskelle</button>
            <button onclick="window.location.href='dialog_01.html'" class="nav-btn-yellow">Samtale</button>
            <input type="file" id="fileInput" accept=".csv" style="display: none;">
        </div>
        
        <div class="workspace" id="workspace">
            <div class="background-layer" id="backgroundLayer"></div>
            <div class="background-labels" id="backgroundLabels"></div>
        </div>
        
        <div class="notes-title">
			<div style="display: flex; gap: 20px; align-items: center; justify-content: center; padding: 10px 0;">
				<label style="display: flex; align-items: center; gap: 5px; font-size: 14px; color: #475569;">
					<input type="checkbox" id="keywordsVisible" class="visibility-checkbox">
					Stikord (vises på cirklen)
				</label>
				<label style="display: flex; align-items: center; gap: 5px; font-size: 14px; color: #475569;">
					<input type="checkbox" id="bodiesVisible" class="visibility-checkbox" checked>
					Kroppe synlige
				</label>
			</div>
		</div>
        
        <div class="notes-section">
            <div class="notes-content">
                <div class="groups-section">
                    <h4>Grupper</h4>
                    <div id="groupFields">
                        <div class="group-input-container">
                            <input type="text" class="group-input" id="group1" placeholder="Gruppe 1" value="Manager" maxlength="50">
                            <button class="group-color-btn" id="groupColor1" data-color-index="0" onclick="changeGroupColor(1)">C</button>
                        </div>
                        <div class="group-input-container">
                            <input type="text" class="group-input" id="group2" placeholder="Gruppe 2" value="Brandmand" maxlength="50">
                            <button class="group-color-btn" id="groupColor2" data-color-index="1" onclick="changeGroupColor(2)">C</button>
                        </div>
                        <div class="group-input-container">
                            <input type="text" class="group-input" id="group3" placeholder="Gruppe 3" value="Eksileret" maxlength="50">
                            <button class="group-color-btn" id="groupColor3" data-color-index="2" onclick="changeGroupColor(3)">C</button>
                        </div>
                        <div class="group-input-container">
                            <input type="text" class="group-input" id="group4" placeholder="Gruppe 4" value="Ekstern" maxlength="50">
                            <button class="group-color-btn" id="groupColor4" data-color-index="3" onclick="changeGroupColor(4)">C</button>
                        </div>
                        <div class="group-input-container">
                            <input type="text" class="group-input" id="group5" placeholder="Gruppe 5" maxlength="50">
                            <button class="group-color-btn" id="groupColor5" data-color-index="4" onclick="changeGroupColor(5)">C</button>
                        </div>
                        <div class="group-input-container">
                            <input type="text" class="group-input" id="group6" placeholder="Gruppe 6" maxlength="50">
                            <button class="group-color-btn" id="groupColor6" data-color-index="5" onclick="changeGroupColor(6)">C</button>
                        </div>
                    </div>
                    <div id="groupDropdown" style="display: none;">
                        <select class="group-dropdown" id="partGroupSelect" onchange="handleGroupSelection(this)">
                            <option value="">Vælg gruppe...</option>
                        </select>
                    </div>
					<div id="poseControls" style="display: none;">
						<div style="font-size: 14px; font-weight: 500; color: #374151; margin-top: 10px; margin-bottom: 5px;">Pose:</div>
						<div style="display: flex; align-items: center; gap: 8px;">
							<select class="group-dropdown" id="partPoseSelect" onchange="applyPartPose(this.value)" style="flex: 1;">
								<option value="">Standard pose</option>
							</select>
							<div style="display: flex; align-items: center; gap: 4px;">
								<input type="checkbox" id="partMirrorPose" onchange="togglePartMirror()" style="width: 12px; height: 12px;">
								<label for="partMirrorPose" style="font-size: 10px; color: #6b7280;">Spejl</label>
							</div>
						</div>
					</div>
                </div>
                
                <div class="keywords-section">
                    <h4>Stikord</h4>
                    <input type="text" class="keyword-input" id="keyword1" placeholder="Alder" maxlength="70">
                    <input type="text" class="keyword-input" id="keyword2" placeholder="Relation" maxlength="70">
                    <input type="text" class="keyword-input" id="keyword3" placeholder="køn" maxlength="70">
                    <input type="text" class="keyword-input" id="keyword4" placeholder="Stikord 4" maxlength="70">
                    <input type="text" class="keyword-input" id="keyword5" placeholder="Stikord 5" maxlength="70">
                    <input type="text" class="keyword-input" id="keyword6" placeholder="Stikord 6" maxlength="70">
                </div>
                
                <div class="notes-container">
                    <h4 id="notesContainerTitle">Noter til opstilling</h4>

					
                    <textarea id="partNotes" placeholder="Generelle noter for opstillingen.Klik evt på en cirkel for at vælge den og redigere dens information..."></textarea>
                </div>
            </div>
        </div>
        
        <div class="instructions">
            <p><strong>Sådan bruger du værktøjet:</strong> Vælg baggrund fra dropdown, tilføj dele ved at skrive navn og klikke "Tilføj Del" eller trykke Enter. Træk delene rundt for at se deres forhold til hinanden. Hold musen over en del for at se kontrolknapperne: × for at slette, T for at redigere navn, ↑↓ for lag, +− for størrelse, C for farve. Klik på en del for at vælge den og redigere dens stikord og noter. Definer grupper i venstre kolonne og tildel valgte dele til grupper. Gem din opstilling som CSV-fil og indlæs den senere. <strong>NYT:</strong> Hver baggrund gemmer sine egne positioner og størrelser - skift mellem baggrunde for forskellige visninger af samme dele!</p>
        </div>
    </div>

    <!-- Color Picker Modal -->
    <div class="color-picker-modal" id="colorPickerModal">
        <div class="picker">
            <div class="color-grid" id="colorGrid"></div>
        </div>
    </div>
	
	<!-- Pose Picker Modal -->
	<div class="pose-picker-modal" id="posePickerModal">
		<div class="pose-picker">
			<div class="pose-mirror-section">
				<label class="pose-mirror-label">
					<input type="checkbox" id="posePickerMirror" onchange="togglePosePickerMirror()">
					<span>Spejl</span>
				</label>
			</div>
			<div class="pose-grid" id="poseGrid"></div>
		</div>
	</div>
	<!-- Keywords Popup Modal -->
	<div class="keywords-popup-modal" id="keywordsPopupModal">
		<div class="keywords-popup">
			<h3>Stikord for <span id="keywordsPopupName"></span></h3>
			<input type="text" class="keywords-popup-input" id="popupKeyword1" placeholder="Alder" maxlength="70">
			<input type="text" class="keywords-popup-input" id="popupKeyword2" placeholder="Relation" maxlength="70">
			<input type="text" class="keywords-popup-input" id="popupKeyword3" placeholder="Køn" maxlength="70">
			<input type="text" class="keywords-popup-input" id="popupKeyword4" placeholder="Stikord 4" maxlength="70">
			<input type="text" class="keywords-popup-input" id="popupKeyword5" placeholder="Stikord 5" maxlength="70">
			<input type="text" class="keywords-popup-input" id="popupKeyword6" placeholder="Stikord 6" maxlength="70">
			<button class="keywords-popup-button" onclick="closeKeywordsPopup()">Senere</button>
		</div>
	</div>
	
	
	
	

    <script>
        // Multi-background system variables
        let currentBackground = 'none';
		const allBackgrounds = ['none', 'har_onsker', 'xy_axes', 'timeline', 'for_imod', 'drama_trekant', 'mandala'];        
        // Background functionality variables
        let currentGroupBtn = null;
        let backgroundLabels = {};
		let currentKeywordsPart = null;
        
        // Original functionality variables
        let partCounter = 0;
        let draggedElement = null;
        let offset = { x: 0, y: 0 };
        let selectedPart = null;
        let colorIndex = 0;
		let generalNotes = '';
		
		// Simple drag animation variables
		let dragState = null;
        
        // Color picker variables
        let currentPart = null;

        // Simpel Shared Data System
        const SHARED_DATA_KEY = 'relationsSetupData';
        let isLoadingSetup = false;
        
        function saveCharactersToShared() {
            if (isLoadingSetup) return;
            const parts = document.querySelectorAll('.part');
            const characters = [];
            
            parts.forEach(part => {
                // Resolve pose name from data-pose (index or name)
                const rawPose = part.getAttribute('data-pose') || '';
                let resolvedPoseName = '';
                if (rawPose !== '') {
                    const maybeIndex = Number(rawPose);
                    if (!Number.isNaN(maybeIndex)) {
                        resolvedPoseName = (poseLibrary[maybeIndex]?.name) || '';
                    } else {
                        resolvedPoseName = rawPose;
                    }
                }

                const character = {
                    id: part.id,
                    name: part.querySelector('.part-name').textContent,
                    x: parseInt(part.style.left) || 0,
                    y: parseInt(part.style.top) || 0,
                    size: parseFloat(part.getAttribute(`data-size-${currentBackground}`)) || 1,
                    layer: parseInt(part.getAttribute('data-layer')) || 1,
                    color: part.getAttribute('data-custom-color') || 
                           partColors[parseInt(part.getAttribute('data-color-index')) || 0],
                    keywords: [
                        part.getAttribute('data-keyword1') || '',
                        part.getAttribute('data-keyword2') || '',
                        part.getAttribute('data-keyword3') || '',
                        part.getAttribute('data-keyword4') || '',
                        part.getAttribute('data-keyword5') || '',
                        part.getAttribute('data-keyword6') || ''
                    ],
                    pose: resolvedPoseName,
                    mirror: part.getAttribute('data-mirror') === 'true'
                };
                
                characters.push(character);
            });
            
            const sharedData = {
                characters: characters,
                lastUpdated: new Date().toISOString()
            };
            
            localStorage.setItem(SHARED_DATA_KEY, JSON.stringify(sharedData));
            
            // Also save to current_opstilling
            saveCurrentOpstillingToStorage();
        }
        
        const partColors = [
            '#f59e0b',  // orange/gul
            '#0891b2',  // cyan
            '#db2777',  // pink
            '#7c3aed',  // lilla
            '#059669',  // grøn
            '#ea580c',  // orange
            '#dc2626',  // rød
            '#2563eb',  // blå
            '#65a30d',  // lime grøn
            '#9333ea'   // violet
        ];
        
        const borderColors = ['#fbbf24', '#06b6d4', '#ec4899', '#8b5cf6', '#10b981', '#f97316', '#ef4444', '#3b82f6', '#84cc16', '#a855f7'];
        
        const groupColors = [
            '#ef4444', // rød
            '#f97316', // orange  
            '#eab308', // gul
            '#22c55e', // grøn
            '#06b6d4', // cyan
            '#3b82f6', // blå
            '#8b5cf6', // lilla
            '#ec4899', // pink
            '#64748b', // grå
            '#059669'  // mørk grøn
        ];
		
		
		
		const presets = {
    ifs_default: `
# Gruppenavne
Gruppe1;Manager;#ef4444
Gruppe2;Brandmand;#f97316
Gruppe3;Eksileret;#eab308
Gruppe4;Ekstern;#22c55e
Gruppe5;;#06b6d4
Gruppe6;;#3b82f6

# Alle Baggrund Labels
har_onsker;topLeft;Har/Ønsker
har_onsker;topRight;Har/Ønsker-ikke
har_onsker;bottomLeft;Har ikke/Ønsker
har_onsker;bottomRight;Har ikke/Ønsker ikke
xy_axes;xLabel;X-akse
xy_axes;yLabel;Y-akse
timeline;title;Tidslinje
timeline;start;Start
timeline;end;Slut
for_imod;left;For
for_imod;right;Imod
drama_trekant;offer;Offer
drama_trekant;hjaelper;Hjælper
drama_trekant;boeddel;Bøddel
mandala;kerne;Kerne
mandala;primaer;Primær
mandala;sekundaer;Sekundær
mandala;periferi;Periferi`,

    Skygge: `
# Gruppenavne
Gruppe1;Skygge;#2e2e2e
Gruppe2;Maske;#f90606
Gruppe3;Bevidst;#80f906
Gruppe4;;#22c55e
Gruppe5;;#06b6d4
Gruppe6;;#3b82f6

# Alle Baggrund Labels
har_onsker;topLeft;Bevidst/Positiv
har_onsker;topRight;Bevidst/Negativ
har_onsker;bottomLeft;Skygge/Positiv
har_onsker;bottomRight;Skygge/Negativ
xy_axes;xLabel;X-akse
xy_axes;yLabel;Y-akse
timeline;title;Tidslinje
timeline;start;Start
timeline;end;Slut
for_imod;left;For
for_imod;right;Imod
drama_trekant;offer;Offer
drama_trekant;hjaelper;Hjælper
drama_trekant;boeddel;Bøddel
mandala;kerne;Kerne
mandala;primaer;Primær
mandala;sekundaer;Sekundær
mandala;periferi;Periferi`
};

        
        const defaultLabels = {
            har_onsker: {
                topLeft: 'Har/Ønsker',
                topRight: 'Har/Ønsker-ikke', 
                bottomLeft: 'Har ikke/Ønsker',
                bottomRight: 'Har ikke/Ønsker ikke'
            },
            xy_axes: {
                xLabel: 'X-akse',
                yLabel: 'Y-akse'
            },
            timeline: {
                title: 'Tidslinje',
                start: 'Start',
                end: 'Slut'
            },
            for_imod: {
                left: 'For',
                right: 'Imod'
            },
            drama_trekant: {
                offer: 'Offer',
                hjaelper: 'Hjælper',
                boeddel: 'Bøddel'
            },
			mandala: {
				kerne: 'Kerne',
				primaer: 'Primær',
				sekundaer: 'Sekundær',
				periferi: 'Periferi'
			}
        };
		
		////pose bibliotek
// Pose Library - loaded from external JSON file
let poseLibrary = [];

// Load pose library from external JSON file
async function loadPoseLibrary() {
    try {
        const response = await fetch('Standard_new_poses.json');
        if (response.ok) {
            poseLibrary = await response.json();
        } else {
            console.error('Failed to load pose library');
            // Fallback to basic poses
            poseLibrary = [
                {
                    "name": "standard",
                    "pose": {
                        "translate_x_left": -3,
                        "translate_y_left": 0,
                        "skulder_rot_left": -70,
                        "albue_rot_left": 0,
                        "translate_x": 3,
                        "translate_y": 0,
                        "skulder_rot": 70,
                        "albue_rot": 0,
                        "translate_x_left_leg": 0,
                        "translate_y_left_leg": 0,
                        "hofte_rot_left": 6,
                        "knae_rot_left": 0,
                        "translate_x_right_leg": 0,
                        "translate_y_right_leg": 0,
                        "hofte_rot_right": -6,
                        "knae_rot_right": 0,
                        "left_arm_front": false,
                        "right_arm_front": false,
                        "duration": 0.3
                    }
                }
            ];
        }
    } catch (error) {
        console.error('Error loading pose library:', error);
        // Fallback to basic poses
        poseLibrary = [
            {
                "name": "standard",
                "pose": {
                    "translate_x_left": -3,
                    "translate_y_left": 0,
                    "skulder_rot_left": -70,
                    "albue_rot_left": 0,
                    "translate_x": 3,
                    "translate_y": 0,
                    "skulder_rot": 70,
                    "albue_rot": 0,
                    "translate_x_left_leg": 0,
                    "translate_y_left_leg": 0,
                    "hofte_rot_left": 6,
                    "knae_rot_left": 0,
                    "translate_x_right_leg": 0,
                    "translate_y_right_leg": 0,
                    "hofte_rot_right": -6,
                    "knae_rot_right": 0,
                    "left_arm_front": false,
                    "right_arm_front": false,
                    "duration": 0.3
                }
            }
        ];
    }
}
		
		
//////////	slut	// pose bibliotek
		
		function resetPose(part) {
			// Apply the "standard" pose from poseLibrary if available; fallback to previous relaxed pose
			const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
			if (standardIndex !== -1) {
				// Persist selection so it is saved to storage for new parts
				part.setAttribute('data-pose', standardIndex.toString());
				part.setAttribute('data-mirror', 'false');
				applyPose(part, standardIndex, false);
				return;
			}
			const relaxedPose = {
				translate_x_left: -3,
				translate_y_left: 0,
				skulder_rot_left: -70,
				albue_rot_left: 0,
				translate_x: 3,
				translate_y: 0,
				skulder_rot: 70,
				albue_rot: 0,
				translate_x_left_leg: 0,
				translate_y_left_leg: 0,
				hofte_rot_left: 6,
				knae_rot_left: 0,
				translate_x_right_leg: 0,
				translate_y_right_leg: 0,
				hofte_rot_right: -6,
				knae_rot_right: 0,
				left_arm_front: false,
				right_arm_front: false
			};
			applyPoseData(part, relaxedPose);
		}

		function applyPose(part, poseIndex, mirror = false) {
			if (poseIndex === '' || poseIndex === null) {
				resetPose(part);
				return;
			}
			
			const pose = poseLibrary[poseIndex];
			if (!pose) return;
			
			let poseData = pose.pose;
			
			// If mirror is checked, create mirrored version
			if (mirror) {
				poseData = {
					translate_x_left: -(pose.pose.translate_x || 0),
					translate_x: -(pose.pose.translate_x_left || 0),
					translate_y_left: pose.pose.translate_y || 0,
					translate_y: pose.pose.translate_y_left || 0,
					skulder_rot_left: -(pose.pose.skulder_rot || 0),
					skulder_rot: -(pose.pose.skulder_rot_left || 0),
					albue_rot_left: -(pose.pose.albue_rot || 0),
					albue_rot: -(pose.pose.albue_rot_left || 0),
					translate_x_left_leg: -(pose.pose.translate_x_right_leg || 0),
					translate_x_right_leg: -(pose.pose.translate_x_left_leg || 0),
					translate_y_left_leg: pose.pose.translate_y_right_leg || 0,
					translate_y_right_leg: pose.pose.translate_y_left_leg || 0,
					hofte_rot_left: -(pose.pose.hofte_rot_right || 0),
					hofte_rot_right: -(pose.pose.hofte_rot_left || 0),
					knae_rot_left: -(pose.pose.knae_rot_right || 0),
					knae_rot_right: -(pose.pose.knae_rot_left || 0),
					left_arm_front: pose.pose.right_arm_front || false,
					right_arm_front: pose.pose.left_arm_front || false
				};
			}
			
			applyPoseData(part, poseData);
		}

		function applyPoseData(part, poseData) {
			const skulderLeft = part.querySelector('.skulder_translate_left');
			const skulderRight = part.querySelector('.skulder_translate_right');
			const hofteLeft = part.querySelector('.hofte_translate_left');
			const hofteRight = part.querySelector('.hofte_translate_right');
			
			if (skulderLeft) {
				skulderLeft.style.transform = `translate(${poseData.translate_x_left || 0}px, ${poseData.translate_y_left || 0}px)`;
				const skulderRotLeft = skulderLeft.querySelector('.skulder_rotate_left');
				if (skulderRotLeft) {
					skulderRotLeft.style.transform = `rotate(${poseData.skulder_rot_left || 0}deg)`;
					const albueRotLeft = skulderRotLeft.querySelector('.albue_rotate_left');
					if (albueRotLeft) {
						albueRotLeft.style.transform = `rotate(${poseData.albue_rot_left || 0}deg)`;
					}
				}
			}
			
			if (skulderRight) {
				skulderRight.style.transform = `translate(${poseData.translate_x || 0}px, ${poseData.translate_y || 0}px)`;
				const skulderRotRight = skulderRight.querySelector('.skulder_rotate_right');
				if (skulderRotRight) {
					skulderRotRight.style.transform = `rotate(${poseData.skulder_rot || 0}deg)`;
					const albueRotRight = skulderRotRight.querySelector('.albue_rotate_right');
					if (albueRotRight) {
						albueRotRight.style.transform = `rotate(${poseData.albue_rot || 0}deg)`;
					}
				}
			}
			
			if (hofteLeft) {
				hofteLeft.style.transform = `translate(${poseData.translate_x_left_leg || 0}px, ${poseData.translate_y_left_leg || 0}px)`;
				const hofteRotLeft = hofteLeft.querySelector('.hofte_rotate_left');
				if (hofteRotLeft) {
					hofteRotLeft.style.transform = `rotate(${poseData.hofte_rot_left || 0}deg)`;
					const knaeRotLeft = hofteRotLeft.querySelector('.knae_rotate_left');
					if (knaeRotLeft) {
						knaeRotLeft.style.transform = `rotate(${poseData.knae_rot_left || 0}deg)`;
					}
				}
			}
			
			if (hofteRight) {
				hofteRight.style.transform = `translate(${poseData.translate_x_right_leg || 0}px, ${poseData.translate_y_right_leg || 0}px)`;
				const hofteRotRight = hofteRight.querySelector('.hofte_rotate_right');
				if (hofteRotRight) {
					hofteRotRight.style.transform = `rotate(${poseData.hofte_rot_right || 0}deg)`;
					const knaeRotRight = hofteRotRight.querySelector('.knae_rotate_right');
					if (knaeRotRight) {
						knaeRotRight.style.transform = `rotate(${poseData.knae_rot_right || 0}deg)`;
					}
				}
			}
			
			// Handle arm layering
			if (poseData.left_arm_front) {
				skulderLeft.classList.add('front-arm');
			} else {
				skulderLeft.classList.remove('front-arm');
			}
			
			if (poseData.right_arm_front) {
				skulderRight.classList.add('front-arm');
			} else {
				skulderRight.classList.remove('front-arm');
			}
			
		}		
		
		function updatePoseDropdown() {
			const dropdown = document.getElementById('partPoseSelect');
			const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
			if (standardIndex !== -1) {
				dropdown.innerHTML = '';
			} else {
				dropdown.innerHTML = '<option value="">Standard pose</option>';
			}
			
			poseLibrary.forEach((pose, index) => {
				const option = document.createElement('option');
				option.value = index;
				option.textContent = pose.name;
				dropdown.appendChild(option);
			});
		}

		function applyPartPose(poseIndex) {
			if (!selectedPart) return;
			
			const mirror = document.getElementById('partMirrorPose').checked;
			
			// Save pose data to part (store as string for consistency)
			selectedPart.setAttribute('data-pose', poseIndex.toString());
			selectedPart.setAttribute('data-mirror', mirror.toString());
			
			// Apply the pose (convert to number for applyPose function)
			const numericPoseIndex = poseIndex === '' ? '' : parseInt(poseIndex);
			applyPose(selectedPart, numericPoseIndex, mirror);
			// Auto-save after pose change
			saveCharactersToShared();
		}

		function togglePartMirror() {
			if (!selectedPart) return;
			
			const poseIndex = document.getElementById('partPoseSelect').value;
			const mirror = document.getElementById('partMirrorPose').checked;
			
			// Save mirror state
			selectedPart.setAttribute('data-mirror', mirror.toString());
			
			// Reapply current pose with new mirror setting (convert to number)
			const numericPoseIndex = poseIndex === '' ? '' : parseInt(poseIndex);
			applyPose(selectedPart, numericPoseIndex, mirror);
			// Auto-save after mirror change
			saveCharactersToShared();
		}		
		
		function openPosePicker(btn) {
    currentPosePart = btn.closest('.part');
    
    const modal = document.getElementById('posePickerModal');
    const picker = modal.querySelector('.pose-picker');
    
    // Populate pose grid
    populatePoseGrid();
    
    // Set current mirror state
    const currentMirror = currentPosePart.getAttribute('data-mirror') === 'true';
    document.getElementById('posePickerMirror').checked = currentMirror;
    
    // Show modal
    const btnRect = btn.getBoundingClientRect();
    modal.classList.add('show');
    
    // Position picker
    picker.style.position = 'absolute';
    picker.style.left = (btnRect.right + 10) + 'px';
    picker.style.top = (btnRect.top - 20) + 'px';
    
    // Adjust if goes off screen
    const pickerRect = picker.getBoundingClientRect();
    if (pickerRect.right > window.innerWidth) {
        picker.style.left = (btnRect.left - pickerRect.width - 10) + 'px';
    }
    if (pickerRect.bottom > window.innerHeight) {
        picker.style.top = (btnRect.bottom - pickerRect.height - 10) + 'px';
    }
}

function populatePoseGrid() {
    const grid = document.getElementById('poseGrid');
    grid.innerHTML = '';
    const currentPose = currentPosePart.getAttribute('data-pose') || '';
    const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
    // Add all poses from library (including "standard")
    poseLibrary.forEach((pose, index) => {
        const btn = document.createElement('button');
        btn.className = 'pose-button';
        btn.textContent = pose.name;
        btn.onclick = () => selectPose(index);
        
        // Check if this is the current active pose
        if (currentPose === index.toString() || (currentPose === '' && index === standardIndex)) {
            btn.classList.add('active');
        }
        
        grid.appendChild(btn);
    });
}

function selectPose(poseIndex) {
    if (!currentPosePart) return;
    
    const mirror = document.getElementById('posePickerMirror').checked;
    
    // Map empty selection to standard index if available
    if (poseIndex === '') {
        const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
        if (standardIndex !== -1) {
            poseIndex = standardIndex;
        }
    }

    // Save pose data
    currentPosePart.setAttribute('data-pose', poseIndex);
    currentPosePart.setAttribute('data-mirror', mirror.toString());
    
    // Apply pose
    applyPose(currentPosePart, poseIndex, mirror);
    
    // Update active button
    populatePoseGrid();
    // Auto-save after pose change (picker)
    saveCharactersToShared();
}

function togglePosePickerMirror() {
    if (!currentPosePart) return;
    
    let poseIndex = currentPosePart.getAttribute('data-pose') || '';
    const mirror = document.getElementById('posePickerMirror').checked;
    
    // Save mirror state
    currentPosePart.setAttribute('data-mirror', mirror.toString());
    
    // Reapply pose with new mirror setting
    if (poseIndex === '') {
        const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
        if (standardIndex !== -1) {
            poseIndex = standardIndex;
        }
    }
    applyPose(currentPosePart, poseIndex, mirror);
    // Auto-save after mirror change (picker)
    saveCharactersToShared();
}

function closePosePicker() {
    document.getElementById('posePickerModal').classList.remove('show');
    currentPosePart = null;
}
		
        
        function initializePartForAllBackgrounds(part, startX, startY, startSize = 1) {
			allBackgrounds.forEach(bg => {
				part.setAttribute(`data-x-${bg}`, startX);
				part.setAttribute(`data-y-${bg}`, startY);
				
				if (bg === 'none') {
					part.setAttribute(`data-size-${bg}`, startSize);
				}
				// Lad andre lag have undefined størrelse
				
				part.setAttribute(`data-res1-${bg}`, '');
				part.setAttribute(`data-res2-${bg}`, '');
				part.setAttribute(`data-res3-${bg}`, '');
				});
			}
        
        function savePartPositionForCurrentBackground(part) {
    if (!part) return;
    
    const x = parseInt(part.style.left) || 0;
    const y = parseInt(part.style.top) || 0;
    const currentSize = parseFloat(part.getAttribute(`data-size-${currentBackground}`)) || 1;
    
    part.setAttribute(`data-x-${currentBackground}`, x);
    part.setAttribute(`data-y-${currentBackground}`, y);
    part.setAttribute(`data-size-${currentBackground}`, currentSize);
}

function loadPartPositionForBackground(part, background) {
			const savedX = part.getAttribute(`data-x-${background}`);
			const savedY = part.getAttribute(`data-y-${background}`);
			const savedSize = part.getAttribute(`data-size-${background}`);
			
			// Hvis position eller størrelse mangler, brug "none" som fallback
			if (savedX !== null && savedY !== null && savedSize !== null) {
				// Alt er gemt - brug gemte værdier
				part.style.left = savedX + 'px';
				part.style.top = savedY + 'px';
				part.style.transform = `scale(${parseFloat(savedSize)})`;
			} else {
				// Noget mangler - brug "none" værdier
				const noneX = part.getAttribute(`data-x-none`) || 0;
				const noneY = part.getAttribute(`data-y-none`) || 0;
				const noneSize = parseFloat(part.getAttribute(`data-size-none`)) || 1;
				
				part.style.left = noneX + 'px';
				part.style.top = noneY + 'px';
				part.style.transform = `scale(${noneSize})`;
			}
		}
 // indtast stikord når figuren laves.
 function openKeywordsPopup(part) {
    currentKeywordsPart = part;
    const modal = document.getElementById('keywordsPopupModal');
    const popup = modal.querySelector('.keywords-popup');
    const nameSpan = document.getElementById('keywordsPopupName');
    const partName = part.querySelector('.part-name').textContent;
    
    nameSpan.textContent = partName;
    
    // Clear inputs
    for (let i = 1; i <= 6; i++) {
        document.getElementById(`popupKeyword${i}`).value = '';
    }
    
    modal.classList.add('show');
    
    // Position popup next to the part
    const partRect = part.getBoundingClientRect();
    popup.style.position = 'absolute';
    popup.style.left = (partRect.right + 20) + 'px';
    popup.style.top = (partRect.top) + 'px';
    
    // Adjust if goes off screen
    setTimeout(() => {
        const popupRect = popup.getBoundingClientRect();
        if (popupRect.right > window.innerWidth) {
            popup.style.left = (partRect.left - popupRect.width - 20) + 'px';
        }
        if (popupRect.bottom > window.innerHeight) {
            popup.style.top = (window.innerHeight - popupRect.height - 20) + 'px';
        }
        if (popupRect.top < 0) {
            popup.style.top = '20px';
        }
    }, 10);
    
    // Focus first input
    setTimeout(() => {
        document.getElementById('popupKeyword1').focus();
    }, 100);
}

function closeKeywordsPopup() {
    if (!currentKeywordsPart) return;
    
    // Save keywords to part
    for (let i = 1; i <= 6; i++) {
        const value = document.getElementById(`popupKeyword${i}`).value;
        currentKeywordsPart.setAttribute(`data-keyword${i}`, value);
    }
    
    // Update keywords display
    updatePartKeywords(currentKeywordsPart);
    // Auto-save after keywords popup close
    saveCharactersToShared();
    
    // If this part is selected, update the bottom inputs too
    if (selectedPart === currentKeywordsPart) {
        for (let i = 1; i <= 6; i++) {
            const value = currentKeywordsPart.getAttribute(`data-keyword${i}`) || '';
            document.getElementById(`keyword${i}`).value = value;
        }
    }
    
    // Close modal
    document.getElementById('keywordsPopupModal').classList.remove('show');
    currentKeywordsPart = null;
}
       
        
        // Color picker functions
        function hslToHex(h,s,l){
            s /= 100; l /= 100;
            const k = n => (n + h/30) % 12;
            const a = s * Math.min(l, 1 - l);
            const f = n => {
                const color = l - a * Math.max(Math.min(k(n) - 3, 9 - k(n), 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }
        
        function darkenColor(hex, percent) {
            const num = parseInt(hex.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) - amt;
            const G = (num >> 8 & 0x00FF) - amt;
            const B = (num & 0x0000FF) - amt;
            return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
        }
        
        function openColorPicker(btn) {
            const isGroupBtn = btn.classList.contains('group-color-btn');

            if (isGroupBtn) {
                currentGroupBtn = btn;
                currentPart = null;
            } else {
                currentPart = btn.closest('.part');
                currentGroupBtn = null;
            }
            
            const modal = document.getElementById('colorPickerModal');
            const picker = modal.querySelector('.picker');

            // Beregn position ved siden af knappen
            const btnRect = btn.getBoundingClientRect();

            // Vis modal først så vi kan beregne picker størrelse
            modal.classList.add('show');

            // Positioner picker ved siden af knappen
            picker.style.position = 'absolute';
            picker.style.left = (btnRect.right + 10) + 'px';
            picker.style.top = (btnRect.top - 20) + 'px';

            // Sørg for at picker ikke går uden for skærmen
            const pickerRect = picker.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (pickerRect.right > viewportWidth) {
                picker.style.left = (btnRect.left - pickerRect.width - 10) + 'px';
            }
            if (pickerRect.bottom > viewportHeight) {
                picker.style.top = (btnRect.bottom - pickerRect.height - 10) + 'px';
            }
        }
        
        function closeColorPicker() {
            document.getElementById('colorPickerModal').classList.remove('show');
            currentPart = null;
        }
        
        function selectColor(hex) {
        if (currentPart) {
			// Erklær alle variabler først
			const head = currentPart.querySelector('.head');
			const torso = currentPart.querySelector('.torso');
			const armParts = currentPart.querySelectorAll('.arm_geo_left, .arm_geo_right, .albue_geo_left, .albue_geo_right');
			const legParts = currentPart.querySelectorAll('.laar_geo_left, .laar_geo_right, .skinneben_geo_left, .skinneben_geo_right');
			
			// Funktion til at gøre farver mørkere
			function darkenColor(color, factor) {
				const r = parseInt(color.slice(1, 3), 16);
				const g = parseInt(color.slice(3, 5), 16);
				const b = parseInt(color.slice(5, 7), 16);
				
				if (factor === 20) {
					// For border - gør mørkere med procent
					const amt = Math.round(2.55 * factor);
					const newR = Math.max(0, r - amt);
					const newG = Math.max(0, g - amt);
					const newB = Math.max(0, b - amt);
					return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
				} else {
					// For body parts - multiplicer med factor
					const newR = Math.round(r * factor);
					const newG = Math.round(g * factor);
					const newB = Math.round(b * factor);
					return `rgb(${newR}, ${newG}, ${newB})`;
				}
			}
			
			const borderColor = darkenColor(hex, 20);
			const darkerColor = darkenColor(hex, 0.92);
			
			// Sæt farver på head
						if (head) {
				head.style.backgroundColor = hex;
			}
			
			// Sæt farver på body parts
			if (torso) torso.style.background = hex;
			armParts.forEach(arm => arm.style.background = darkerColor);
			legParts.forEach(leg => leg.style.background = darkerColor);
			
            currentPart.setAttribute('data-custom-color', hex);
            currentPart.setAttribute('data-custom-border', borderColor);

            // Persist new color to shared storage
            try { saveCharactersToShared(); } catch(_) {}
		} else if (currentGroupBtn) {
			currentGroupBtn.style.backgroundColor = hex;
			currentGroupBtn.setAttribute('data-custom-color', hex);
			
			// Find alle cirkler i denne gruppe og opdater deres border
			const groupNumber = currentGroupBtn.id.match(/\d+/)[0];
			const groupName = document.getElementById(`group${groupNumber}`).value.trim();
			
			if (groupName) {
				document.querySelectorAll('.part').forEach(part => {
					if (part.getAttribute('data-group') === groupName) {
						const head = part.querySelector('.head');
						if (head) {
							head.style.border = `4px solid ${hex}`;
						}
					}
				});
			}
		}
		
		
		setTimeout(() => {
			closeColorPicker();
		}, 100);
	}

        function changeColor(btn) {
            try {
                openColorPicker(btn);
            } catch (error) {
                console.error('Fejl i changeColor:', error);
            }
        }
		
		
		// preset parsers isedet for at læse fra fil læses fra defaults
		// Funktion til at parse grupper fra linjer
			function parseGroupsFromLines(lines) {
				for (let line of lines) {
					if (line.trim() === '' || !line.startsWith('Gruppe')) continue;
					
					const parts = line.split(';');
					if (parts.length >= 3) {
						const groupNumber = parts[0].replace('Gruppe', '');
						const groupName = parts[1] || '';
						const groupColor = parts[2] || '';
						
						const groupInput = document.getElementById(`group${groupNumber}`);
						if (groupInput) {
							groupInput.value = groupName;
						}
						
						const colorBtn = document.getElementById(`groupColor${groupNumber}`);
						if (colorBtn && groupColor) {
							colorBtn.style.backgroundColor = groupColor;
							colorBtn.setAttribute('data-custom-color', groupColor);
							colorBtn.removeAttribute('data-color-index');
						}
					}
				}
			}
		
		// Funktion til at parse labels fra linjer
			function parseLabelsFromLines(lines) {
				let inLabelSection = false;
				for (let line of lines) {
					const trimmedLine = line.trim();
					
					if (trimmedLine === '# Alle Baggrund Labels') {
						inLabelSection = true;
						continue;
					}
					
					if (inLabelSection && (trimmedLine === '' || trimmedLine.startsWith('#'))) {
						break;
					}
					
					if (inLabelSection && trimmedLine !== '') {
						const parts = line.split(';');
						if (parts.length >= 3) {
							const bg = parts[0];
							const key = parts[1];
							const value = parts[2] || '';
							
							if (!backgroundLabels[bg]) {
								backgroundLabels[bg] = { ...defaultLabels[bg] };
							}
							
							backgroundLabels[bg][key] = value;
						}
					}
				}
			}

			// Funktion til at indlæse preset
			function loadPreset(presetName) {
				if (!presets[presetName]) {
					alert('Preset ikke fundet!');
					return;
				}
				
				try {
					const lines = presets[presetName].split('\n');
					
					// Parse grupper og labels
					parseGroupsFromLines(lines);
					parseLabelsFromLines(lines);
					
					// Opdater labels for nuværende baggrund
					renderLabels();
					
					alert(`Preset "${presetName}" indlæst!`);
					
				} catch (error) {
					console.error('Fejl ved indlæsning af preset:', error);
					alert('Der opstod en fejl ved indlæsning af preset.');
				}
			}
		
		
			// Funktion til at håndtere tema-ændring
			function changeTheme() {
				const select = document.getElementById('themeSelect');
				const selectedTheme = select.value;
				
				if (selectedTheme && selectedTheme !== '') {
					loadPreset(selectedTheme);
					// Reset dropdown til neutral position
					select.value = '';
				}
			}		
		
        
        // Background functions
        function changeBackground() {
            const select = document.getElementById('backgroundSelect');
            const newBackground = select.value;
            
            // Flyt alle cirkler til deres gemte positioner for den nye baggrund
            const parts = document.querySelectorAll('.part');
            parts.forEach(part => {
                loadPartPositionForBackground(part, newBackground);
            });
            
            // Opdater current background
            currentBackground = newBackground;
            
            if (!backgroundLabels[currentBackground]) {
                backgroundLabels[currentBackground] = { ...defaultLabels[currentBackground] };
            }
            
            renderBackground();
            renderLabels();
            saveCurrentOpstillingToStorage();
        }
        
        function renderBackground() {
            const layer = document.getElementById('backgroundLayer');
            layer.innerHTML = '';
            
            if (currentBackground === 'none') return;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.style.width = '100%';
            svg.style.height = '100%';
            
            if (currentBackground === 'har_onsker') {
                // Stiplede linjer for Har/ønsker
                const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                vLine.setAttribute('x1', '50%');
                vLine.setAttribute('y1', '0%');
                vLine.setAttribute('x2', '50%');
                vLine.setAttribute('y2', '100%');
                vLine.setAttribute('stroke', '#94a3b8');
                vLine.setAttribute('stroke-width', '2');
                vLine.setAttribute('stroke-dasharray', '5,5');
                svg.appendChild(vLine);
                
                const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hLine.setAttribute('x1', '0%');
                hLine.setAttribute('y1', '50%');
                hLine.setAttribute('x2', '100%');
                hLine.setAttribute('y2', '50%');
                hLine.setAttribute('stroke', '#94a3b8');
                hLine.setAttribute('stroke-width', '2');
                hLine.setAttribute('stroke-dasharray', '5,5');
                svg.appendChild(hLine);
            }
            else if (currentBackground === 'xy_axes') {
                // X/Y akser
                const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                xAxis.setAttribute('x1', '10%');
                xAxis.setAttribute('y1', '90%');
                xAxis.setAttribute('x2', '90%');
                xAxis.setAttribute('y2', '90%');
                xAxis.setAttribute('stroke', '#475569');
                xAxis.setAttribute('stroke-width', '3');
                svg.appendChild(xAxis);
                
                const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                yAxis.setAttribute('x1', '10%');
                yAxis.setAttribute('y1', '10%');
                yAxis.setAttribute('x2', '10%');
                yAxis.setAttribute('y2', '90%');
                yAxis.setAttribute('stroke', '#475569');
                yAxis.setAttribute('stroke-width', '3');
                svg.appendChild(yAxis);
            }
            else if (currentBackground === 'timeline') {
                // Tidslinje i bunden
                const timeline = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                timeline.setAttribute('x1', '10%');
                timeline.setAttribute('y1', '90%');
                timeline.setAttribute('x2', '90%');
                timeline.setAttribute('y2', '90%');
                timeline.setAttribute('stroke', '#475569');
                timeline.setAttribute('stroke-width', '4');
                svg.appendChild(timeline);
                
                // 5 markeringer
                for (let i = 20; i <= 80; i += 15) {
                    const mark = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    mark.setAttribute('x1', `${i}%`);
                    mark.setAttribute('y1', '85%');
                    mark.setAttribute('x2', `${i}%`);
                    mark.setAttribute('y2', '95%');
                    mark.setAttribute('stroke', '#475569');
                    mark.setAttribute('stroke-width', '2');
                    svg.appendChild(mark);
                }
            }
            else if (currentBackground === 'for_imod') {
                // Stiplet midterlinje
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', '50%');
                line.setAttribute('y1', '0%');
                line.setAttribute('x2', '50%');
                line.setAttribute('y2', '100%');
                line.setAttribute('stroke', '#94a3b8');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('stroke-dasharray', '5,5');
                svg.appendChild(line);
            } else if (currentBackground === 'drama_trekant') {
                // Trekant med tre linjer
                const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line1.setAttribute('x1', '50%');
                line1.setAttribute('y1', '15%');
                line1.setAttribute('x2', '20%');
                line1.setAttribute('y2', '80%');
                line1.setAttribute('stroke', '#475569');
                line1.setAttribute('stroke-width', '3');
                svg.appendChild(line1);
                
                const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line2.setAttribute('x1', '50%');
                line2.setAttribute('y1', '15%');
                line2.setAttribute('x2', '80%');
                line2.setAttribute('y2', '80%');
                line2.setAttribute('stroke', '#475569');
                line2.setAttribute('stroke-width', '3');
                svg.appendChild(line2);
                
                const line3 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line3.setAttribute('x1', '20%');
                line3.setAttribute('y1', '80%');
                line3.setAttribute('x2', '80%');
                line3.setAttribute('y2', '80%');
                line3.setAttribute('stroke', '#475569');
                line3.setAttribute('stroke-width', '3');
                svg.appendChild(line3);
            }else if (currentBackground === 'mandala') {
			// Mandala med 4 koncentriske cirkler
			const centerX = 50, centerY = 50, maxRadius = 40;
			
			for (let i = 1; i <= 4; i++) {
				const radius = (maxRadius / 4) * i;
				const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
				circle.setAttribute('cx', `${centerX}%`);
				circle.setAttribute('cy', `${centerY}%`);
				circle.setAttribute('r', `${radius}%`);
				circle.setAttribute('fill', 'none');
				circle.setAttribute('stroke', '#94a3b8');
				circle.setAttribute('stroke-width', '1.5');
				circle.setAttribute('opacity', '0.6');
				svg.appendChild(circle);
			}
		}
            
            layer.appendChild(svg);
        }
        
        function renderLabels() {
            const container = document.getElementById('backgroundLabels');
            container.innerHTML = '';
            
            if (currentBackground === 'none') return;
            
            const labels = backgroundLabels[currentBackground];
            if (!labels) return;
            
            if (currentBackground === 'har_onsker') {
                createLabel(container, 'topLeft', labels.topLeft, '25%', '10%');
                createLabel(container, 'topRight', labels.topRight, '75%', '10%');
                createLabel(container, 'bottomLeft', labels.bottomLeft, '25%', '90%');
                createLabel(container, 'bottomRight', labels.bottomRight, '75%', '90%');
            }
            else if (currentBackground === 'xy_axes') {
                createLabel(container, 'xLabel', labels.xLabel, '50%', '95%');
                createLabel(container, 'yLabel', labels.yLabel, '5%', '50%');
            }
            else if (currentBackground === 'timeline') {
                createLabel(container, 'title', labels.title, '50%', '95%');
                createLabel(container, 'start', labels.start, '15%', '95%');
                createLabel(container, 'end', labels.end, '85%', '95%');
            }
            else if (currentBackground === 'for_imod') {
                createLabel(container, 'left', labels.left, '25%', '10%');
                createLabel(container, 'right', labels.right, '75%', '10%');
            } 
            else if (currentBackground === 'drama_trekant') {
                createLabel(container, 'offer', labels.offer, '50%', '10%');
                createLabel(container, 'hjaelper', labels.hjaelper, '15%', '85%');
                createLabel(container, 'boeddel', labels.boeddel, '85%', '85%');
            }else if (currentBackground === 'mandala') 
			{
				createLabel(container, 'kerne', labels.kerne, '61%', '32%');
				createLabel(container, 'primaer', labels.primaer, '69%', '24%');
				createLabel(container, 'sekundaer', labels.sekundaer, '77%', '16%');
				createLabel(container, 'periferi', labels.periferi, '85%', '8%');
}
        }
        
        function createLabel(container, key, text, left, top) {
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'label-input';
            input.value = text;
            input.style.left = left;
            input.style.top = top;
            
            input.addEventListener('change', function() {
                backgroundLabels[currentBackground][key] = this.value;
                saveCurrentOpstillingToStorage();
            });
            
            container.appendChild(input);
        }
        
        // Part management functions (updated for multi-background)
        function selectPart(e) {
            try {
                if (e.target.classList.contains('control-btn')) return;
                const clickedPart = e.currentTarget;
                
                if (selectedPart === clickedPart) {
					selectedPart.classList.remove('selected');
					selectedPart = null;
					updateGroupsDisplay();

					const titleElement = document.getElementById('profileTitle');
					if (titleElement) titleElement.textContent = '';

					document.getElementById('notesContainerTitle').textContent = 'Noter til opstilling';

					const notesEl = document.getElementById('partNotes');
					notesEl.value = generalNotes;
					notesEl.placeholder = 'Generelle noter til hele opstillingen...';
                    for (let i = 1; i <= 6; i++) {
                        document.getElementById(`keyword${i}`).value = '';
                    }
                    return;
                }
                
                if (selectedPart) {
                    selectedPart.classList.remove('selected');
                }
                
                selectedPart = e.currentTarget;
				selectedPart.classList.add('selected');

				const name = selectedPart.querySelector('.part-name').textContent;
				const notes = selectedPart.getAttribute('data-notes') || '';

				document.getElementById('notesContainerTitle').textContent = `Noter til ${name}`;
				document.getElementById('partNotes').value = notes;
				document.getElementById('partNotes').placeholder = `Detaljerede noter til "${name}"`;
                
                for (let i = 1; i <= 6; i++) {
                    const keyword = selectedPart.getAttribute(`data-keyword${i}`) || '';
                    document.getElementById(`keyword${i}`).value = keyword;
                }
                
                updateGroupsDisplay();
            } catch (error) {
                console.error('Fejl i selectPart:', error);
            }
        }
        
        function changeGroupColor(groupNumber) {
            const colorBtn = document.getElementById(`groupColor${groupNumber}`);
            openColorPicker(colorBtn);
        }
        
       function handleGroupSelection(selectElement) {
			if (selectedPart) {
				selectedPart.setAttribute('data-group', selectElement.value);
				
				if (selectElement.value) {
					for (let i = 1; i <= 6; i++) {
						const groupInput = document.getElementById(`group${i}`);
						if (groupInput && groupInput.value.trim() === selectElement.value) {
							const colorBtn = document.getElementById(`groupColor${i}`);
							// Brug den faktiske farve fra knappen i stedet for index
							const groupColor = colorBtn.getAttribute('data-custom-color') || colorBtn.style.backgroundColor;
							const head = selectedPart.querySelector('.head');
							if (head) {
								head.style.border = `4px solid ${groupColor}`;
							}
							break;
						}
					}
				} else {
					const head = selectedPart.querySelector('.head');
					if (head) {
						head.style.border = '';
					}
				}
			}
		}
        
        function updateGroupDropdown() {
            const dropdown = document.getElementById('partGroupSelect');
            dropdown.innerHTML = '<option value="">Vælg gruppe...</option>';
            
            for (let i = 1; i <= 6; i++) {
                const groupInput = document.getElementById(`group${i}`);
                const groupName = groupInput.value.trim();
                if (groupName) {
                    const option = document.createElement('option');
                    option.value = groupName;
                    option.textContent = groupName;
                    dropdown.appendChild(option);
                }
            }
        }
        
        function updateGroupsDisplay() {
			const groupFields = document.getElementById('groupFields');
			const groupDropdown = document.getElementById('groupDropdown');
			const poseControls = document.getElementById('poseControls');
			const keywordsSection = document.querySelector('.keywords-section');
			
			if (selectedPart) {
				groupFields.style.display = 'none';
				groupDropdown.style.display = 'block';
				poseControls.style.display = 'block';
				keywordsSection.style.display = 'block';
				
				updateGroupDropdown();
				updatePoseDropdown();
				
				const currentGroup = selectedPart.getAttribute('data-group') || '';
				document.getElementById('partGroupSelect').value = currentGroup;
				
				// Update pose controls
				const currentPose = selectedPart.getAttribute('data-pose') || '';
				const currentMirror = selectedPart.getAttribute('data-mirror') === 'true';
				document.getElementById('partPoseSelect').value = currentPose;
				document.getElementById('partMirrorPose').checked = currentMirror;
				
				// Ensure the visual state matches the saved state
				// If there's a pose, reapply it to ensure consistency
				if (currentPose !== '') {
					const poseIndex = parseInt(currentPose);
					if (!isNaN(poseIndex) && poseLibrary[poseIndex]) {
						applyPose(selectedPart, poseIndex, currentMirror);
					}
				}
				
			} else {
				groupFields.style.display = 'block';
				groupDropdown.style.display = 'none';
				poseControls.style.display = 'none';
				keywordsSection.style.display = 'none';
			}
		}
        
        function updatePartKeywords(part) {
            const keywordsAbove = part.querySelector('.keywords-above');
            const keywordsBelow = part.querySelector('.keywords-below');
            
            const above = [];
            for (let i = 1; i <= 3; i++) {
                const keyword = part.getAttribute(`data-keyword${i}`);
                if (keyword && keyword.trim()) {
                    above.push(keyword.trim());
                }
            }
            
            const below = [];
            for (let i = 4; i <= 6; i++) {
                const keyword = part.getAttribute(`data-keyword${i}`);
                if (keyword && keyword.trim()) {
                    below.push(keyword.trim());
                }
            }
            
            keywordsAbove.innerHTML = above.join('<br>');
            keywordsBelow.innerHTML = below.join('<br>');
            
            const keywordsVisible = document.getElementById('keywordsVisible').checked;
            if (!keywordsVisible) {
                keywordsAbove.style.display = 'none';
                keywordsBelow.style.display = 'none';
            } else {
                keywordsAbove.style.display = 'block';
                keywordsBelow.style.display = 'block';
            }
        }
        
        function addPart(name = null, x = null, y = null, skipPopup = false) {
            try {
                const partName = name || document.getElementById('partName').value.trim();
                if (!partName) {
                    const commonParts = [
                        "Det Sårede Barn", "Beskytteren", "Den Kritiske", "Den Perfektionistiske", 
                        "Den Bekymrede", "Den Vrede", "Den Glade", "Den Kreative", 
                        "Manager-delen", "Firewall-delen", "Det Elskede Barn", "Den Ansvarlige"
                    ];
                    const suggestion = commonParts[Math.floor(Math.random() * commonParts.length)];
                    document.getElementById('partName').placeholder = `Prøv f.eks: ${suggestion}`;
                    return;
                }
                
                const workspace = document.getElementById('workspace');
                const part = document.createElement('div');
                part.className = 'part';
                partCounter++;
                
                const posX = x !== null ? x : Math.random() * (workspace.offsetWidth - 120);
                const posY = y !== null ? y : Math.random() * (workspace.offsetHeight - 120);
                
                part.style.left = posX + 'px';
                part.style.top = posY + 'px';
                
                const existingParts = document.querySelectorAll('.part');
                // Find max current layer to avoid duplicates if there are gaps or collisions
                let maxLayer = 0;
                existingParts.forEach(p => {
                    const l = parseInt(p.getAttribute('data-layer')) || 0;
                    if (l > maxLayer) maxLayer = l;
                });
                const newLayer = maxLayer + 1;
                part.style.zIndex = newLayer + 10;
                
                const assignedColor = partColors[colorIndex % partColors.length];
				const borderColor = borderColors[colorIndex % borderColors.length];

				
                
                part.setAttribute('data-color-index', colorIndex.toString());
                part.setAttribute('data-notes', '');
                part.setAttribute('data-layer', newLayer.toString());
                part.setAttribute('data-group', '');
				part.setAttribute('data-part-scale', '1');
                part.setAttribute('data-keyword1', '');
                part.setAttribute('data-keyword2', '');
                part.setAttribute('data-keyword3', '');
                part.setAttribute('data-keyword4', '');
                part.setAttribute('data-keyword5', '');
                part.setAttribute('data-keyword6', '');
                part.setAttribute('data-custom-color', assignedColor);
                part.setAttribute('data-custom-border', borderColor);
                
                // Initialize multi-background data
                initializePartForAllBackgrounds(part, posX, posY, 1);
                
                colorIndex++;
                
                part.innerHTML = `
                    <div class="keywords-above part-keywords"></div>
						<div class="keywords-below part-keywords"></div>
						
						<div class="body">
							<div class="head">
								<span class="part-name">${partName}</span>
							</div>
							<div class="torso"></div>
							
							<!-- Venstre arm hierarki -->
							<div class="skulder_translate_left">
								<div class="skulder_rotate_left">
									<div class="arm_geo_left">
										<div class="albue_rotate_left">
											<div class="albue_geo_left"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Højre arm hierarki -->
							<div class="skulder_translate_right">
								<div class="skulder_rotate_right">
									<div class="arm_geo_right">
										<div class="albue_rotate_right">
											<div class="albue_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Venstre ben hierarki -->
							<div class="hofte_translate_left">
								<div class="hofte_rotate_left">
									<div class="laar_geo_left">
										<div class="knae_rotate_left">
											<div class="skinneben_geo_left"></div>
										</div>
									</div>
								</div>
							</div>

							<!-- Højre ben hierarki -->
							<div class="hofte_translate_right">
								<div class="hofte_rotate_right">
									<div class="laar_geo_right">
										<div class="knae_rotate_right">
											<div class="skinneben_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
						</div>
					
					<button class="control-btn delete-btn" title="Slet del">×</button>
                    
                    <button class="control-btn layer-up" title="Bring frem">↑</button>
                    <button class="control-btn layer-down" title="Send bagud">↓</button>
                    <button class="control-btn size-plus" title="Gør større">+</button>
                    <button class="control-btn size-minus" title="Gør mindre">−</button>
                    <button class="control-btn color-btn" title="Skift farve">C</button>
					<button class="control-btn pose-btn" title="Skift pose">P</button>
                `;
				
				// Gør navn direkte redigerbart
				const nameSpan = part.querySelector('.part-name');
				nameSpan.style.cursor = 'pointer';
				nameSpan.addEventListener('click', function(e) {
					e.stopPropagation();
					editName(this);
				});
				
				// Set colors on body parts
				const head = part.querySelector('.head');
				const torso = part.querySelector('.torso');
				const armParts = part.querySelectorAll('.arm_geo_left, .arm_geo_right, .albue_geo_left, .albue_geo_right');
				const legParts = part.querySelectorAll('.laar_geo_left, .laar_geo_right, .skinneben_geo_left, .skinneben_geo_right');

				// Funktion til at gøre farver mørkere
				function darkenColor(hex, factor = 0.92) {
					const r = parseInt(hex.slice(1, 3), 16);
					const g = parseInt(hex.slice(3, 5), 16);
					const b = parseInt(hex.slice(5, 7), 16);
					
					const newR = Math.round(r * factor);
					const newG = Math.round(g * factor);
					const newB = Math.round(b * factor);
					
					return `rgb(${newR}, ${newG}, ${newB})`;
				}

				const darkerColor = darkenColor(assignedColor, 0.92);

				if (head) {
					head.style.background = assignedColor;
					//head.style.border = `4px solid ${borderColor}`; -ingen border
				}
				if (torso) torso.style.background = assignedColor;
				armParts.forEach(arm => arm.style.background = darkerColor);
				legParts.forEach(leg => leg.style.background = darkerColor);
                
                part.addEventListener('pointerdown', startDrag);
                part.addEventListener('click', selectPart);
                part.addEventListener('dragstart', (e) => e.preventDefault());
                
                const deleteBtn = part.querySelector('.delete-btn');
                
                const layerUpBtn = part.querySelector('.layer-up');
                const layerDownBtn = part.querySelector('.layer-down');
                const sizePlusBtn = part.querySelector('.size-plus');
                const sizeMinusBtn = part.querySelector('.size-minus');
                const colorBtn = part.querySelector('.color-btn');
				const poseBtn = part.querySelector('.pose-btn');
                
                deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deletePart(deleteBtn); });
                
                layerUpBtn.addEventListener('click', (e) => { e.stopPropagation(); moveToFront(layerUpBtn); });
                layerDownBtn.addEventListener('click', (e) => { e.stopPropagation(); moveToBack(layerDownBtn); });
                sizePlusBtn.addEventListener('click', (e) => { e.stopPropagation(); increaseSize(sizePlusBtn); });
                sizeMinusBtn.addEventListener('click', (e) => { e.stopPropagation(); decreaseSize(sizeMinusBtn); });
                colorBtn.addEventListener('click', (e) => { e.stopPropagation(); changeColor(colorBtn); });
                poseBtn.addEventListener('click', (e) => { e.stopPropagation(); openPosePicker(poseBtn); });
				
                workspace.appendChild(part);
				resetPose(part);
				
				// Update shared data
				saveCharactersToShared();
				
				// Open keywords popup for new part (unless loading from file)
				if (!skipPopup) {
					openKeywordsPopup(part);
				}


                
                document.getElementById('partName').value = '';
                document.getElementById('partName').placeholder = "Navn på del (f.eks. Beskytteren, Den Kritiske, Det Sårede Barn...)";
                
            } catch (error) {
                console.error('Fejl i addPart:', error);
            }
        }
        
        function deletePart(btn) {
            try {
                const part = btn.closest('.part');
                const deletedLayer = parseInt(part.getAttribute('data-layer')) || 1;
                part.remove();
                
                if (selectedPart === part) {
					selectedPart = null;
					updateGroupsDisplay();
					document.getElementById('notesContainerTitle').textContent = 'Noter til opstilling';
					document.getElementById('partNotes').value = '';
					document.getElementById('partNotes').placeholder = 'Generelle noter til hele opstillingen...';
					for (let i = 1; i <= 6; i++) {
						document.getElementById(`keyword${i}`).value = '';
					}
				}
                
                const allParts = document.querySelectorAll('.part');
                allParts.forEach(p => {
                    const currentLayer = parseInt(p.getAttribute('data-layer')) || 1;
                    if (currentLayer > deletedLayer) {
                        const newLayer = currentLayer - 1;
                        p.setAttribute('data-layer', newLayer.toString());
                        p.style.zIndex = newLayer + 10;
                    }
                });
                // Ensure layers are unique and compact after delete
                normalizeLayers();
                // Auto-save after delete
                saveCharactersToShared();
                
            } catch (error) {
                console.error('Fejl i deletePart:', error);
            }
        }
        
        function moveToFront(btn) {
            try {
                const part = btn.closest('.part');
                const currentLayer = parseInt(part.getAttribute('data-layer')) || 1;
                const allParts = document.querySelectorAll('.part');
                const maxLayer = allParts.length;
                const targetLayer = currentLayer + 1;
                
                if (targetLayer > maxLayer) return;
                
                let targetPart = null;
                allParts.forEach(p => {
                    if (parseInt(p.getAttribute('data-layer')) === targetLayer) {
                        targetPart = p;
                    }
                });
                
                // If there is a gap or duplicate layers, normalize and retry
                if (!targetPart) {
                    normalizeLayers();
                    const refreshedParts = document.querySelectorAll('.part');
                    refreshedParts.forEach(p => {
                        if (parseInt(p.getAttribute('data-layer')) === currentLayer + 1) {
                            targetPart = p;
                        }
                    });
                }

                if (targetPart) {
                    part.setAttribute('data-layer', targetLayer.toString());
                    part.style.zIndex = targetLayer + 10;
                    targetPart.setAttribute('data-layer', currentLayer.toString());
                    targetPart.style.zIndex = currentLayer + 10;
                }
                // Auto-save after layer change (front)
                saveCharactersToShared();
            } catch (error) {
                console.error('Fejl i moveToFront:', error);
            }
        }
        
        function moveToBack(btn) {
            try {
                const part = btn.closest('.part');
                const currentLayer = parseInt(part.getAttribute('data-layer')) || 1;
                const targetLayer = currentLayer - 1;
                
                if (targetLayer < 1) return;
                
                const allParts = document.querySelectorAll('.part');
                let targetPart = null;
                allParts.forEach(p => {
                    if (parseInt(p.getAttribute('data-layer')) === targetLayer) {
                        targetPart = p;
                    }
                });
                
                // If there is a gap or duplicate layers, normalize and retry
                if (!targetPart) {
                    normalizeLayers();
                    const refreshedParts = document.querySelectorAll('.part');
                    refreshedParts.forEach(p => {
                        if (parseInt(p.getAttribute('data-layer')) === targetLayer) {
                            targetPart = p;
                        }
                    });
                }

                if (targetPart) {
                    part.setAttribute('data-layer', targetLayer.toString());
                    part.style.zIndex = targetLayer + 10;
                    targetPart.setAttribute('data-layer', currentLayer.toString());
                    targetPart.style.zIndex = currentLayer + 10;
                }
                // Auto-save after layer change (back)
                saveCharactersToShared();
            } catch (error) {
                console.error('Fejl i moveToBack:', error);
            }
        }

        // Ensure unique, compact layers (1..N) with matching z-index
        function normalizeLayers() {
            try {
                const parts = Array.from(document.querySelectorAll('.part'));
                // Sort by current data-layer asc; fall back to DOM order
                parts.sort((a, b) => {
                    const la = parseInt(a.getAttribute('data-layer')) || 0;
                    const lb = parseInt(b.getAttribute('data-layer')) || 0;
                    return la - lb;
                });
                parts.forEach((p, idx) => {
                    const layer = idx + 1;
                    p.setAttribute('data-layer', layer.toString());
                    p.style.zIndex = layer + 10;
                });
            } catch (error) {
                console.error('Fejl i normalizeLayers:', error);
            }
        }
        
		function increaseSize(btn) {
				try {
					const part = btn.closest('.part');
					let currentScale = parseFloat(part.getAttribute(`data-size-${currentBackground}`)) || 1;
					
					let increment = 0.1;
					const newScale = Math.min(3, Math.round((currentScale + increment) * 10) / 10);
					part.style.transform = `scale(${newScale})`;
					part.setAttribute(`data-size-${currentBackground}`, newScale);
					
					// Ensure background data is saved properly
					savePartPositionForCurrentBackground(part);
                    // Auto-save after size increase
                    saveCharactersToShared();
					
				} catch (error) {
					console.error('Fejl i increaseSize:', error);
				}
			}



			function decreaseSize(btn) {
				try {
					const part = btn.closest('.part');
					let currentScale = parseFloat(part.getAttribute(`data-size-${currentBackground}`)) || 1;
					
					let decrement = 0.1;
					const newScale = Math.max(0.45, Math.round((currentScale - decrement) * 10) / 10);
					part.style.transform = `scale(${newScale})`;
					part.setAttribute(`data-size-${currentBackground}`, newScale);
					
					// Ensure background data is saved properly
					savePartPositionForCurrentBackground(part);
                    // Auto-save after size decrease
                    saveCharactersToShared();
					
					} catch (error) {
						console.error('Fejl i decreaseSize:', error);
					}
				}
				
        
        
        function updatePartSize(part, sizeMultiplier) {
			part.style.transform = `scale(${sizeMultiplier})`;
			part.setAttribute(`data-size-${currentBackground}`, sizeMultiplier);
			}
        
        function startDrag(e) {
				try {
					if (e.target.classList.contains('control-btn') || e.target.classList.contains('label-input')) return;
					
					draggedElement = e.target.closest('.part');
					if (!draggedElement) return;
					
					draggedElement.classList.add('dragging');
					
					const rect = draggedElement.getBoundingClientRect();
					offset.x = e.clientX - rect.left;
					offset.y = e.clientY - rect.top;
					
					// Initialize simple drag state
					dragState = {
						lastX: e.clientX,
						lastY: e.clientY,
						velocityX: 0,
						isDragging: true,
						settleTimeout: null,
						currentRotation: 0,
						targetRotation: 0,
						animationId: null
					};
					
					// Start continuous animation loop
					const animate = () => {
						if (dragState && dragState.isDragging) {
							const lerpFactor = 0.3; // How fast to interpolate
							dragState.currentRotation += (dragState.targetRotation - dragState.currentRotation) * lerpFactor;
							
							const body = draggedElement.querySelector('.body');
							if (body) {
								body.style.transform = `translateX(-50%) rotate(${dragState.currentRotation}deg)`;
							}
							
							dragState.animationId = requestAnimationFrame(animate);
						}
					};
					
					dragState.animationId = requestAnimationFrame(animate);
					
                document.addEventListener('pointermove', drag, { passive: false });
                document.addEventListener('pointerup', stopDrag, { passive: false });
				} catch (error) {
					console.error('Fejl i startDrag:', error);
				}
			}
        
        function drag(e) {
            try {
                if (!draggedElement || !dragState) return;
                if (e && typeof e.preventDefault === 'function') e.preventDefault();
                
                const workspace = document.getElementById('workspace');
                const workspaceRect = workspace.getBoundingClientRect();
                
                // Calculate rotation based on movement direction
                const deltaX = e.clientX - dragState.lastX;
                dragState.velocityX = deltaX;
                dragState.lastX = e.clientX;
                dragState.lastY = e.clientY;
                
                // Clear any existing settle timeout
                if (dragState.settleTimeout) {
                    clearTimeout(dragState.settleTimeout);
                    dragState.settleTimeout = null;
                }
                
                // Calculate target rotation based on movement
                if (Math.abs(deltaX) > 0.5) {
                    dragState.targetRotation = deltaX * 1.5; // Sensitivity multiplier
                    dragState.targetRotation = Math.max(-15, Math.min(15, dragState.targetRotation)); // Clamp to ±15 degrees
                }
                
                // Set timeout to settle back to 0 after 200ms of no movement
                if (Math.abs(deltaX) > 0.5) {
                    dragState.settleTimeout = setTimeout(() => {
                        dragState.targetRotation = 0;
                        // Let the interpolation handle the smooth return
                    }, 200);
                }
                
                let newX = e.clientX - workspaceRect.left - offset.x;
                let newY = e.clientY - workspaceRect.top - offset.y;

                // Fixed-margin clamp based on part's top-left (independent of size)
                const minLeft = 1;   // target approx left edge
                const minTop  = 6;   // target approx top edge
                const rightMargin = 86; // workspace.width - maxLeft (≈1600-1514)
                const bottomMargin = 78; // workspace.height - maxTop (≈600-522)
                const maxLeft = workspace.offsetWidth - rightMargin;
                const maxTop  = workspace.offsetHeight - bottomMargin;

                newX = Math.max(minLeft, Math.min(newX, maxLeft));
                newY = Math.max(minTop,  Math.min(newY, maxTop));
                
                draggedElement.style.left = newX + 'px';
                draggedElement.style.top = newY + 'px';
            } catch (error) {
                console.error('Fejl i drag:', error);
            }
        }
        
        function stopDrag() {
			try {
				if (draggedElement && dragState) {
					draggedElement.classList.remove('dragging');
					
					// Clear any pending settle timeout
					if (dragState.settleTimeout) {
						clearTimeout(dragState.settleTimeout);
					}
					
					// Stop dragging flag but continue animation
					dragState.isDragging = false;
					dragState.targetRotation = 0;
					
					// Continue settle animation until rotation is back to 0
					const settleAnimation = () => {
						if (dragState && Math.abs(dragState.currentRotation) > 0.1) {
							const lerpFactor = 0.2; // Slower settling
							dragState.currentRotation += (dragState.targetRotation - dragState.currentRotation) * lerpFactor;
							
							const body = draggedElement.querySelector('.body');
							if (body) {
								body.style.transform = `translateX(-50%) rotate(${dragState.currentRotation}deg)`;
							}
							
							dragState.animationId = requestAnimationFrame(settleAnimation);
						} else {
							// Final cleanup when settled
							const body = draggedElement.querySelector('.body');
							if (body) {
								body.style.transform = `translateX(-50%) rotate(0deg)`;
							}
							
							// Save position for current background
							savePartPositionForCurrentBackground(draggedElement);
							// Save shared characters (updates x,y)
							saveCharactersToShared();
							
							draggedElement = null;
							dragState = null;
						}
					};
					
					dragState.animationId = requestAnimationFrame(settleAnimation);
				}
                document.removeEventListener('pointermove', drag);
                document.removeEventListener('pointerup', stopDrag);
			} catch (error) {
				console.error('Fejl i stopDrag:', error);
			}
		}
        
        function loadCurrentOpstillingFromStorage() {
            try {
                const savedOpstilling = localStorage.getItem('current_opstilling');
                if (!savedOpstilling) return false;
                
                // Parse CSV data
                const lines = savedOpstilling.split('\n');
                
                // Clear existing parts but preserve groups
                const workspace = document.getElementById('workspace');
                workspace.innerHTML = `
                    <div class="background-layer" id="backgroundLayer"></div>
                    <div class="background-labels" id="backgroundLabels"></div>
                `;
                selectedPart = null;
                generalNotes = '';
                
                // Clean up drag state
                draggedElement = null;
                dragState = null;
                
                updateGroupsDisplay();
                document.getElementById('partNotes').value = '';
                document.getElementById('partNotes').placeholder = 'Generelle noter for opstillingen. Klik evt på en cirkel for at vælge den og redigere dens information...';
                
                for (let i = 1; i <= 6; i++) {
                    document.getElementById(`keyword${i}`).value = '';
                }
                
                // Reset background labels to default
                backgroundLabels = {};
                allBackgrounds.forEach(bg => {
                    if (defaultLabels[bg]) {
                        backgroundLabels[bg] = { ...defaultLabels[bg] };
                    }
                });
                
                renderBackground();
                
                // Reset colorIndex so new parts start fresh with colors
                colorIndex = 0;
                
                renderLabels();
                
                for (let line of lines) {
                    if (line.trim() === '' || line.startsWith('#') || line.includes('Navn;PosX')) continue;
                    
                    const parts = line.split(';');
                    // Check if this line has multi-background data
                    if (parts.length >= 21) {
                        const navn = parts[0];
                        const posX = parseInt(parts[1]) || 0;
                        const posY = parseInt(parts[2]) || 0;
                        const størrelse = parseFloat(parts[3]) || 1;
                        const farveGradient = parts[4];
                        const borderFarve = parts[5];
                        const lag = parseInt(parts[6]) || 1;
                        const noter = parts[7] || '';
                        const gruppe = parts[14] || '';
                        const baggrund = parts[18] || 'none';
						const pose = parts[19] || '';
						const mirror = parts[20] === 'true';
                        
                        let farveIndex = partColors.findIndex(color => 
                            color.toLowerCase() === farveGradient.toLowerCase()
                        );
                        if (farveIndex === -1) farveIndex = 0;
                        
                        // Add part (skip popup when loading from storage)
						addPart(navn, posX, posY, true);
                        
                        const newPart = document.querySelector('.part:last-child');
                        if (newPart) {
                            newPart.setAttribute('data-color-index', farveIndex);
                            newPart.setAttribute('data-layer', lag);
                            newPart.setAttribute('data-notes', noter);
                            newPart.setAttribute('data-group', gruppe);
                            newPart.setAttribute('data-custom-color', farveGradient);
                            newPart.setAttribute('data-custom-border', borderFarve);
							// Set pose data - store index instead of name for consistency
							const poseIndex = poseLibrary.findIndex(p => p.name === pose);
							if (poseIndex !== -1) {
								newPart.setAttribute('data-pose', poseIndex.toString());
							} else {
								newPart.setAttribute('data-pose', '');
							}
							newPart.setAttribute('data-mirror', mirror.toString());

							// Opdater body parts med den korrekte farve
							const head = newPart.querySelector('.head');
							const torso = newPart.querySelector('.torso');
							const armParts = newPart.querySelectorAll('.arm_geo_left, .arm_geo_right, .albue_geo_left, .albue_geo_right');
							const legParts = newPart.querySelectorAll('.laar_geo_left, .laar_geo_right, .skinneben_geo_left, .skinneben_geo_right');

							// Funktion til at gøre farver mørkere
							function darkenColor(hex, factor = 0.92) {
								const r = parseInt(hex.slice(1, 3), 16);
								const g = parseInt(hex.slice(3, 5), 16);
								const b = parseInt(hex.slice(5, 7), 16);
								
								const newR = Math.round(r * factor);
								const newG = Math.round(g * factor);
								const newB = Math.round(b * factor);
								
								return `rgb(${newR}, ${newG}, ${newB})`;
							}

							const darkerColor = darkenColor(farveGradient, 0.92);

							if (head) head.style.background = farveGradient;
							if (torso) torso.style.background = farveGradient;
							armParts.forEach(arm => arm.style.background = darkerColor);
							legParts.forEach(leg => leg.style.background = darkerColor);
                            
                            newPart.style.zIndex = lag + 10;
                            
                            // Set keywords
                            for (let i = 8; i <= 13; i++) {
                                if (parts[i]) {
                                    newPart.setAttribute(`data-keyword${i-7}`, parts[i]);
                                }
                            }
                            
                            // Load multi-background data if available
                            if (parts.length >= 21 + (allBackgrounds.length * 6)) {
                                let bgIndex = 21;
                                allBackgrounds.forEach(bg => {
                                    const bgX = parts[bgIndex] || posX;
                                    const bgY = parts[bgIndex + 1] || posY;
                                    const bgSize = parts[bgIndex + 2] || størrelse;
                                    const bgRes1 = parts[bgIndex + 3] || '';
                                    const bgRes2 = parts[bgIndex + 4] || '';
                                    const bgRes3 = parts[bgIndex + 5] || '';
                                    
                                    newPart.setAttribute(`data-x-${bg}`, bgX);
                                    newPart.setAttribute(`data-y-${bg}`, bgY);
                                    newPart.setAttribute(`data-size-${bg}`, bgSize);
                                    newPart.setAttribute(`data-res1-${bg}`, bgRes1);
                                    newPart.setAttribute(`data-res2-${bg}`, bgRes2);
                                    newPart.setAttribute(`data-res3-${bg}`, bgRes3);
                                    
                                    bgIndex += 6;
                                });
								// Apply current background scale after loading all background data
								const currentScale = parseFloat(newPart.getAttribute(`data-size-${currentBackground}`)) || 1;
								newPart.style.transform = `scale(${currentScale})`;
                            } else {
                                // Initialize with current position for all backgrounds (legacy support)
                                initializePartForAllBackgrounds(newPart, posX, posY, størrelse);
                            }
                            
                            updatePartKeywords(newPart);
							// Apply the pose
							if (pose) {
								// Find pose index by name
								const poseIndex = poseLibrary.findIndex(p => p.name === pose);
								if (poseIndex !== -1) {
									applyPose(newPart, poseIndex, mirror);
								} else {
									resetPose(newPart);
								}
							} else {
								resetPose(newPart);
							}
                        }
                        
                        // Set background if found
                        if (baggrund && baggrund !== 'none') {
                            document.getElementById('backgroundSelect').value = baggrund;
                            currentBackground = baggrund;
                            changeBackground();
                        }
                    }
                }
                
                // Indlæs gruppenavne og farver
				for (let line of lines) {
					if (line.trim() === '' || !line.startsWith('Gruppe')) continue;
					
					const parts = line.split(';');
					if (parts.length >= 3) {
						const groupNumber = parts[0].replace('Gruppe', '');
						const groupName = parts[1] || '';
						const groupColor = parts[2] || '';
						
						const groupInput = document.getElementById(`group${groupNumber}`);
						if (groupInput) {
							groupInput.value = groupName;
						}
						
						const colorBtn = document.getElementById(`groupColor${groupNumber}`);
						if (colorBtn && groupColor) {
							colorBtn.style.backgroundColor = groupColor;
							colorBtn.setAttribute('data-custom-color', groupColor);
							colorBtn.removeAttribute('data-color-index');
						}
					}
				}
				
				// Apply group borders after group colors are loaded
				document.querySelectorAll('.part').forEach(part => {
					const partGroup = part.getAttribute('data-group');
					if (partGroup) {
						for (let i = 1; i <= 6; i++) {
							const groupInput = document.getElementById(`group${i}`);
							if (groupInput && groupInput.value.trim() === partGroup) {
								const colorBtn = document.getElementById(`groupColor${i}`);
								const groupColor = colorBtn.getAttribute('data-custom-color') || colorBtn.style.backgroundColor;
								const head = part.querySelector('.head');
								if (groupColor && head) {
									head.style.border = `4px solid ${groupColor}`;
								}
								break;
							}
						}
					}
				});
				
				// Indlæs alle background labels
				let inLabelSection = false;
				for (let line of lines) {
					const trimmedLine = line.trim();
					
					if (trimmedLine === '# Alle Baggrund Labels') {
						inLabelSection = true;
						continue;
					}
					
					if (inLabelSection && (trimmedLine === '' || trimmedLine.startsWith('#'))) {
						break;
					}
					
					if (inLabelSection && trimmedLine !== '') {
						const parts = line.split(';');
						if (parts.length >= 3) {
							const bg = parts[0];
							const key = parts[1];
							const value = parts[2] || '';
							
							if (!backgroundLabels[bg]) {
								backgroundLabels[bg] = { ...defaultLabels[bg] };
							}
							
							backgroundLabels[bg][key] = value;
						}
					}
				}
				
				// Indlæs generelle noter
				let inNotesSection = false;
				let notesContent = '';
				for (let line of lines) {
					const trimmedLine = line.trim();
					
					if (trimmedLine === '# Generelle Noter') {
						inNotesSection = true;
						continue;
					}
					
					if (inNotesSection) {
						notesContent += line.replace(/\\n/g, '\n') + '\n';
					}
				}
				generalNotes = notesContent.trim();
				document.getElementById('partNotes').value = generalNotes;

				// Opdater labels for nuværende baggrund
				renderLabels();

				document.querySelectorAll('.part').forEach(part => {
					const partGroup = part.getAttribute('data-group');
					if (partGroup) {
						for (let i = 1; i <= 6; i++) {
							const groupInput = document.getElementById(`group${i}`);
							if (groupInput && groupInput.value.trim() === partGroup) {
								const colorBtn = document.getElementById(`groupColor${i}`);
								const groupColor = colorBtn.getAttribute('data-custom-color') || colorBtn.style.backgroundColor;
								if (groupColor) {
								const head = part.querySelector('.head');
								if (head) {
									head.style.border = `4px solid ${groupColor}`;
									}
								}
								break;
							}
						}
					}
				});

                // Ensure layers are consistent after load
                normalizeLayers();
                return true;
            } catch (error) {
                console.error('Fejl ved indlæsning fra localStorage:', error);
                return false;
            }
        }

        function clearAll() {
            try {
                const workspace = document.getElementById('workspace');
                workspace.innerHTML = `
                    <div class="background-layer" id="backgroundLayer"></div>
                    <div class="background-labels" id="backgroundLabels"></div>
                `;
                selectedPart = null;
				generalNotes = '';
				
				// Clean up drag state
				draggedElement = null;
				dragState = null;
				
                updateGroupsDisplay();
                document.getElementById('partNotes').value = '';
                document.getElementById('partNotes').placeholder = 'Generelle noter for opstillingen. Klik evt på en cirkel for at vælge den og redigere dens information...';
                
                for (let i = 1; i <= 6; i++) {
                    document.getElementById(`keyword${i}`).value = '';
                }
				
				// Nulstil alle background labels til default
				backgroundLabels = {};
				allBackgrounds.forEach(bg => {
					if (defaultLabels[bg]) {
						backgroundLabels[bg] = { ...defaultLabels[bg] };
					}
				});
                
                renderBackground();
				
				// Nulstil gruppenavne til default
				const defaultGroupNames = ['Manager', 'Brandmand', 'Eksileret', 'Ekstern', '', ''];
				for (let i = 1; i <= 6; i++) {
					const groupInput = document.getElementById(`group${i}`);
					if (groupInput) {
						groupInput.value = defaultGroupNames[i-1];
					}
					
					// Nulstil gruppe farver til default
					const colorBtn = document.getElementById(`groupColor${i}`);
					if (colorBtn) {
						colorBtn.setAttribute('data-color-index', (i-1).toString());
						colorBtn.style.backgroundColor = groupColors[i-1];
						colorBtn.removeAttribute('data-custom-color');
					}
				}

				// Nulstil colorIndex så nye dele starter forfra med farver
				colorIndex = 0;
				
                renderLabels();
                
                // Clear shared characters in localStorage
                try {
                    localStorage.setItem('relationsSetupData', JSON.stringify({ characters: [], lastUpdated: new Date().toISOString() }));
                    localStorage.removeItem('current_opstilling');
                } catch(_) {}

            } catch (error) {
                console.error('Fejl i clearAll:', error);
            }
        }
        
        function editName(btn) {
            try {
                const part = btn.closest ? btn.closest('.part') : btn.parentElement.closest('.part');
                const nameSpan = part.querySelector('.part-name');
                const currentName = nameSpan.textContent;
                
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentName;
                input.className = 'name-input';
                input.maxLength = 30;
                
                nameSpan.style.display = 'none';
                nameSpan.parentNode.insertBefore(input, nameSpan);
                
                input.focus();
                input.select();
                
                let isFinishing = false;

				function finishEdit() {
					if (isFinishing) return;
					isFinishing = true;
					
					const newName = input.value.trim() || currentName;
					nameSpan.textContent = newName;
					nameSpan.style.display = 'block';
					
					if (input.parentNode) {
						input.remove();
					}
					
					if (selectedPart && selectedPart === part) {
						document.getElementById('partNotes').placeholder = `Detaljerede noter til "${newName}"`;
					}
					// Auto-save after name change
					saveCharactersToShared();
				}
                
                input.addEventListener('blur', finishEdit);
                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        finishEdit();
                    }
                    if (e.key === 'Escape') {
                        nameSpan.style.display = 'block';
                        input.remove();
                    }
                });
            } catch (error) {
                console.error('Fejl i editName:', error);
            }
        }
        
        function saveCurrentOpstillingToStorage() {
            try {
                const parts = document.querySelectorAll('.part');
                
                // Build CSV header with multi-background columns
				let csv = 'Navn;PosX;PosY;Størrelse;Farve_Gradient;Border_Farve;Lag;Noter;Stikord1;Stikord2;Stikord3;Stikord4;Stikord5;Stikord6;Gruppe;Form;Kategori;Forbindelser;Baggrund;Pose;Mirror';                
                // Add multi-background columns
                allBackgrounds.forEach(bg => {
                    csv += `;PosX_${bg};PosY_${bg};Size_${bg};Res1_${bg};Res2_${bg};Res3_${bg}`;
                });
                csv += '\n';
                
                parts.forEach(part => {
                    const navn = part.querySelector('.part-name').textContent.replace(/;/g, ',');
                    const posX = parseInt(part.style.left) || 0;
                    const posY = parseInt(part.style.top) || 0;
                    const størrelse = parseFloat(part.getAttribute(`data-size-${currentBackground}`)) || 1;
                    
                    const farveGradient = part.getAttribute('data-custom-color') || 
                                         partColors[parseInt(part.getAttribute('data-color-index')) || 0];
                    const borderFarve = part.getAttribute('data-custom-border') || 
                                       borderColors[parseInt(part.getAttribute('data-color-index')) || 0];
                    
                    const lag = part.getAttribute('data-layer') || '1';
                    const noter = (part.getAttribute('data-notes') || '').replace(/;/g, ',').replace(/\n/g, ' ');
                    const gruppe = (part.getAttribute('data-group') || '').replace(/;/g, ',');
					const poseIndex = part.getAttribute('data-pose') || '';
					const pose = poseIndex !== '' ? (poseLibrary[poseIndex]?.name || '') : '';
					const mirror = part.getAttribute('data-mirror') || 'false';
                    
                    const stikord1 = (part.getAttribute('data-keyword1') || '').replace(/;/g, ',');
                    const stikord2 = (part.getAttribute('data-keyword2') || '').replace(/;/g, ',');
                    const stikord3 = (part.getAttribute('data-keyword3') || '').replace(/;/g, ',');
                    const stikord4 = (part.getAttribute('data-keyword4') || '').replace(/;/g, ',');
                    const stikord5 = (part.getAttribute('data-keyword5') || '').replace(/;/g, ',');
                    const stikord6 = (part.getAttribute('data-keyword6') || '').replace(/;/g, ',');
                    
                    const form = 'cirkel';
                    const kategori = '';
                    const forbindelser = '';
                    
					csv += `${navn};${posX};${posY};${størrelse};${farveGradient};${borderFarve};${lag};${noter};${stikord1};${stikord2};${stikord3};${stikord4};${stikord5};${stikord6};${gruppe};${form};${kategori};${forbindelser};${currentBackground};${pose};${mirror}`;                    
                    // Add multi-background data
                    allBackgrounds.forEach(bg => {
                        const bgX = part.getAttribute(`data-x-${bg}`) || '';
                        const bgY = part.getAttribute(`data-y-${bg}`) || '';
                        const bgSize = part.getAttribute(`data-size-${bg}`) || '';
                        const bgRes1 = part.getAttribute(`data-res1-${bg}`) || '';
                        const bgRes2 = part.getAttribute(`data-res2-${bg}`) || '';
                        const bgRes3 = part.getAttribute(`data-res3-${bg}`) || '';
                        csv += `;${bgX};${bgY};${bgSize};${bgRes1};${bgRes2};${bgRes3}`;
                    });
                    csv += '\n';
                });
                
                csv += '\n# Gruppenavne\n';
				for (let i = 1; i <= 6; i++) {
					const groupName = document.getElementById(`group${i}`).value.trim();
					const colorBtn = document.getElementById(`groupColor${i}`);
					
					// Hent den aktuelle farveværdi (enten custom eller default)
					const currentColor = colorBtn.getAttribute('data-custom-color') || groupColors[parseInt(colorBtn.getAttribute('data-color-index')) || 0];
					
					csv += `Gruppe${i};${groupName.replace(/;/g, ',')};${currentColor}\n`;
				}
                
                // Efter eksisterende CSV data, tilføj alle baggrunds-labels
				csv += '\n# Alle Baggrund Labels\n';
				allBackgrounds.forEach(bg => {
					if (backgroundLabels[bg]) {
						Object.keys(backgroundLabels[bg]).forEach(key => {
							const value = backgroundLabels[bg][key] || '';
							csv += `${bg};${key};${value.replace(/;/g, ',')}\n`;
						});
					}
				});
				
				// Gem generelle noter
				csv += '\n# Generelle Noter\n';
				csv += generalNotes.replace(/;/g, ',').replace(/\n/g, '\\n') + '\n';
                
                // Gem til localStorage
                localStorage.setItem('current_opstilling', csv);
                
            } catch (error) {
                console.error('Fejl ved gemning til localStorage:', error);
            }
        }

        function saveSetup() {
            try {
                const parts = document.querySelectorAll('.part');
                if (parts.length === 0) {
                    alert('Ingen dele at gemme! Tilføj først nogle dele til opstillingen.');
                    return;
                }
                
                // Build CSV header with multi-background columns
				let csv = 'Navn;PosX;PosY;Størrelse;Farve_Gradient;Border_Farve;Lag;Noter;Stikord1;Stikord2;Stikord3;Stikord4;Stikord5;Stikord6;Gruppe;Form;Kategori;Forbindelser;Baggrund;Pose;Mirror';                
                // Add multi-background columns
                allBackgrounds.forEach(bg => {
                    csv += `;PosX_${bg};PosY_${bg};Size_${bg};Res1_${bg};Res2_${bg};Res3_${bg}`;
                });
                csv += '\n';
                
                parts.forEach(part => {
                    const navn = part.querySelector('.part-name').textContent.replace(/;/g, ',');
                    const posX = parseInt(part.style.left) || 0;
                    const posY = parseInt(part.style.top) || 0;
                    const størrelse = parseFloat(part.getAttribute(`data-size-${currentBackground}`)) || 1;
                    
                    const farveGradient = part.getAttribute('data-custom-color') || 
                                         partColors[parseInt(part.getAttribute('data-color-index')) || 0];
                    const borderFarve = part.getAttribute('data-custom-border') || 
                                       borderColors[parseInt(part.getAttribute('data-color-index')) || 0];
                    
                    const lag = part.getAttribute('data-layer') || '1';
                    const noter = (part.getAttribute('data-notes') || '').replace(/;/g, ',').replace(/\n/g, ' ');
                    const gruppe = (part.getAttribute('data-group') || '').replace(/;/g, ',');
					const poseIndex = part.getAttribute('data-pose') || '';
					const pose = poseIndex !== '' ? (poseLibrary[poseIndex]?.name || '') : '';
					const mirror = part.getAttribute('data-mirror') || 'false';
                    
                    const stikord1 = (part.getAttribute('data-keyword1') || '').replace(/;/g, ',');
                    const stikord2 = (part.getAttribute('data-keyword2') || '').replace(/;/g, ',');
                    const stikord3 = (part.getAttribute('data-keyword3') || '').replace(/;/g, ',');
                    const stikord4 = (part.getAttribute('data-keyword4') || '').replace(/;/g, ',');
                    const stikord5 = (part.getAttribute('data-keyword5') || '').replace(/;/g, ',');
                    const stikord6 = (part.getAttribute('data-keyword6') || '').replace(/;/g, ',');
                    
                    const form = 'cirkel';
                    const kategori = '';
                    const forbindelser = '';
                    
					csv += `${navn};${posX};${posY};${størrelse};${farveGradient};${borderFarve};${lag};${noter};${stikord1};${stikord2};${stikord3};${stikord4};${stikord5};${stikord6};${gruppe};${form};${kategori};${forbindelser};${currentBackground};${pose};${mirror}`;                    
                    // Add multi-background data
                    allBackgrounds.forEach(bg => {
                        const bgX = part.getAttribute(`data-x-${bg}`) || '';
                        const bgY = part.getAttribute(`data-y-${bg}`) || '';
                        const bgSize = part.getAttribute(`data-size-${bg}`) || '';
                        const bgRes1 = part.getAttribute(`data-res1-${bg}`) || '';
                        const bgRes2 = part.getAttribute(`data-res2-${bg}`) || '';
                        const bgRes3 = part.getAttribute(`data-res3-${bg}`) || '';
                        csv += `;${bgX};${bgY};${bgSize};${bgRes1};${bgRes2};${bgRes3}`;
                    });
                    csv += '\n';
                });
                
                csv += '\n# Gruppenavne\n';
				for (let i = 1; i <= 6; i++) {
					const groupName = document.getElementById(`group${i}`).value.trim();
					const colorBtn = document.getElementById(`groupColor${i}`);
					
					// Hent den aktuelle farveværdi (enten custom eller default)
					const currentColor = colorBtn.getAttribute('data-custom-color') || groupColors[parseInt(colorBtn.getAttribute('data-color-index')) || 0];
					
					csv += `Gruppe${i};${groupName.replace(/;/g, ',')};${currentColor}\n`;
				}
                
                // Efter eksisterende CSV data, tilføj alle baggrunds-labels
				csv += '\n# Alle Baggrund Labels\n';
				allBackgrounds.forEach(bg => {
					if (backgroundLabels[bg]) {
						Object.keys(backgroundLabels[bg]).forEach(key => {
							const value = backgroundLabels[bg][key] || '';
							csv += `${bg};${key};${value.replace(/;/g, ',')}\n`;
						});
					}
				});
				
				
				// Gem generelle noter
				csv += '\n# Generelle Noter\n';
				csv += generalNotes.replace(/;/g, ',').replace(/\n/g, '\\n') + '\n';
                
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
                const link = document.createElement('a');
                const dato = new Date().toISOString().slice(0, 10);
                
                const fileName = prompt('Filnavn (uden .csv):', `Opstilling_${dato}`);
                if (fileName === null || fileName.trim() === '') {
                    link.download = `Opstilling_${dato}.csv`;
                } else {
                    const cleanName = fileName.trim().replace(/[<>:"/\\|?*]/g, '_');
                    link.download = cleanName.endsWith('.csv') ? cleanName : cleanName + '.csv';
                }
                
                link.href = URL.createObjectURL(blob);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error('Fejl i saveSetup:', error);
                alert('Der opstod en fejl ved gemning af opstillingen.');
            }
        }
		
		
		
		
		
		
        
        function loadSetup() {
            try {
                const fileInput = document.getElementById('fileInput');
                if (fileInput) {
                    if (window.__fileDialogOpen) return;
                    window.__fileDialogOpen = true;
                    fileInput.click();
                } else {
                    alert('Fejl: Kan ikke finde file input element');
                }
            } catch (error) {
                console.error('Fejl i loadSetup:', error);
                alert('Der opstod en fejl ved indlæsning: ' + error.message);
            }
        }
		
		function exportAsImage() {
    try {
        const workspace = document.getElementById('workspace');
        
        // Skjul control buttons
        const controlBtns = workspace.querySelectorAll('.control-btn');
        controlBtns.forEach(btn => btn.style.display = 'none');
        
        // Skjul selection
        const wasSelected = selectedPart;
        if (selectedPart) {
            selectedPart.classList.remove('selected');
        }
        
        // Modern-screenshot
        modernScreenshot.domToPng(workspace, {
            width: workspace.offsetWidth,
            height: workspace.offsetHeight,
            scale: 2,
			quality: 1 
			
        }).then(dataUrl => {
            // Gendan UI
            controlBtns.forEach(btn => btn.style.display = '');
            if (wasSelected) {
                wasSelected.classList.add('selected');
            }
            
            // Download
            const link = document.createElement('a');
            const dato = new Date().toISOString().slice(0, 10);
            link.download = `Opstilling-${dato}.png`;
            link.href = dataUrl;
            link.click();
            
        }).catch(error => {
            console.error('Fejl:', error);
            
            // Gendan UI ved fejl
            controlBtns.forEach(btn => btn.style.display = '');
            if (wasSelected) {
                wasSelected.classList.add('selected');
            }
            
            alert('Eksport fejlede');
        });
        
    } catch (error) {
        console.error('Fejl:', error);
        alert('Modern-Screenshot ikke tilgængelig');
    }
}
        
        function handleWorkspaceClick(e) {
            try {
                const workspaceEl = document.getElementById('workspace');
                const clickedPart = e.target.closest('.part');

                if (workspaceEl.contains(e.target) && !clickedPart) {
					if (selectedPart) {
						selectedPart.classList.remove('selected');
						selectedPart = null;
						updateGroupsDisplay();

						const titleElement = document.getElementById('profileTitle');
						if (titleElement) titleElement.textContent = '';

						document.getElementById('notesContainerTitle').textContent = 'Noter til opstilling';

						const notesEl = document.getElementById('partNotes');
						notesEl.value = generalNotes;
						notesEl.placeholder = 'Generelle noter til hele opstillingen...';
                        for (let i = 1; i <= 6; i++) {
                            document.getElementById(`keyword${i}`).value = '';
                        }
                    }

                    const rect = workspaceEl.getBoundingClientRect();
                    const x = e.clientX - rect.left - 60;
                    const y = e.clientY - rect.top - 60;
                    const partName = document.getElementById('partName').value.trim();
                    if (partName) addPart(partName, x, y);
                }
            } catch (error) {
                console.error('Fejl i handleWorkspaceClick:', error);
            }
        }
        
        document.addEventListener('DOMContentLoaded', async function() {
            // Load pose library first
            await loadPoseLibrary();
            
            // Try to load current opstilling from localStorage
            const loaded = loadCurrentOpstillingFromStorage();
            if (loaded) {
                console.log('Opstilling indlæst fra localStorage');
            }
            
            try {
				
				
                // Initialize color picker grid
                const grid = document.getElementById('colorGrid');
                
                for(let row = 0; row < 14; row++) {
                    for(let col = 0; col < 12; col++) {
                        let hex;
                        
                        if(row === 0) {
                            const hue = Math.round(col * 360/12);
                            hex = hslToHex(hue, 95, 50);
                        } else if(row === 1) {
                            const light = Math.round(100 - (col * (100/11)));
                            hex = hslToHex(0, 0, light);
                        } else {
                            const gridRow = row - 2;
                            const hue = Math.round(col * 360/12);
                            const light = Math.round(92 - (gridRow * (84/11)));
                            const satBase = 86;
                            const sat = Math.round(satBase - Math.abs((col - 6)/ 6) * 20);
                            hex = hslToHex(hue, sat, light);
                        }
                        
                        const swatch = document.createElement('button');
                        swatch.className = 'swatch';
                        swatch.style.background = hex;
                        swatch.dataset.hex = hex;
                        swatch.title = hex;
                        swatch.setAttribute('aria-label', `Farve ${hex}`);
                        swatch.tabIndex = 0;
                        
                        swatch.addEventListener('click', () => selectColor(hex));
                        
                        grid.appendChild(swatch);
                    }
                }
                
                // Color picker modal event listener
                document.getElementById('colorPickerModal').addEventListener('click', function(e) {
                    if (e.target === this) {
                        closeColorPicker();
                    }
                });
                
                // Initialize group colors (only if not already set)
                for (let i = 1; i <= 6; i++) {
                    const colorBtn = document.getElementById(`groupColor${i}`);
                    if (colorBtn && !colorBtn.getAttribute('data-custom-color')) {
                        const colorIndex = parseInt(colorBtn.getAttribute('data-color-index')) || 0;
                        colorBtn.style.backgroundColor = groupColors[colorIndex];
                    }
                }
				
				
				// Pose picker modal event listener
				document.getElementById('posePickerModal').addEventListener('click', function(e) {
					if (e.target === this) {
						closePosePicker();
					}
				});
				
				// Keywords popup modal event listener
				document.getElementById('keywordsPopupModal').addEventListener('click', function(e) {
					if (e.target === this) {
						closeKeywordsPopup();
					}
				});
				
                
                // Add event listeners
                const partNameInput = document.getElementById('partName');
                partNameInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        addPart();
                    }
                });
                
                const partNotesTextarea = document.getElementById('partNotes');
				partNotesTextarea.addEventListener('input', function() {
					if (selectedPart) {
						selectedPart.setAttribute('data-notes', this.value);
					} else {
						generalNotes = this.value;
					}
					saveCurrentOpstillingToStorage();
				});
                
                for (let i = 1; i <= 6; i++) {
                    const keywordInput = document.getElementById(`keyword${i}`);
                    if (keywordInput) {
                        keywordInput.addEventListener('input', function() {
                            if (selectedPart) {
                                selectedPart.setAttribute(`data-keyword${i}`, this.value);
                                updatePartKeywords(selectedPart);
                                // Auto-save after keyword input
                                saveCharactersToShared();
                            }
                        });
                    }
                }
                
                const workspace = document.getElementById('workspace');
                workspace.addEventListener('click', handleWorkspaceClick);
                
                const fileInput = document.getElementById('fileInput');
                if (fileInput) {
                    fileInput.addEventListener('change', function(event) {
                        const file = event.target.files[0];
                        // reset guard regardless of pick/cancel
                        window.__fileDialogOpen = false;
                        if (!file) return;
                        
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            isLoadingSetup = true;
                            try {
                                const csv = e.target.result;
                                const lines = csv.split('\n');
                                
                                // Clear existing parts
                                clearAll();
                                
                                for (let line of lines) {
                                    if (line.trim() === '' || line.startsWith('#') || line.includes('Navn;PosX')) continue;
                                    
                                    const parts = line.split(';');
                                    // Check if this line has multi-background data
                                    if (parts.length >= 21) {
                                        const navn = parts[0];
                                        const posX = parseInt(parts[1]) || 0;
                                        const posY = parseInt(parts[2]) || 0;
                                        const størrelse = parseFloat(parts[3]) || 1;
                                        const farveGradient = parts[4];
                                        const borderFarve = parts[5];
                                        const lag = parseInt(parts[6]) || 1;
                                        const noter = parts[7] || '';
                                        const gruppe = parts[14] || '';
                                        const baggrund = parts[18] || 'none';
										const pose = parts[19] || '';
										const mirror = parts[20] === 'true';
                                        
                                        let farveIndex = partColors.findIndex(color => 
                                            color.toLowerCase() === farveGradient.toLowerCase()
                                        );
                                        if (farveIndex === -1) farveIndex = 0;
                                        
                                        // Add part (skip popup when loading from file)
											addPart(navn, posX, posY, true);
                                        
                                        const newPart = document.querySelector('.part:last-child');
                                        if (newPart) {
                                            newPart.setAttribute('data-color-index', farveIndex);
                                            newPart.setAttribute('data-layer', lag);
                                            newPart.setAttribute('data-notes', noter);
                                            newPart.setAttribute('data-group', gruppe);
                                            newPart.setAttribute('data-custom-color', farveGradient);
                                            newPart.setAttribute('data-custom-border', borderFarve);
											// Set pose data - store index instead of name for consistency
											const poseIndex = poseLibrary.findIndex(p => p.name === pose);
											if (poseIndex !== -1) {
												newPart.setAttribute('data-pose', poseIndex.toString());
											} else {
												newPart.setAttribute('data-pose', '');
											}
											newPart.setAttribute('data-mirror', mirror.toString());

											
											
											// Opdater body parts med den korrekte farve
											const head = newPart.querySelector('.head');
											const torso = newPart.querySelector('.torso');
											const armParts = newPart.querySelectorAll('.arm_geo_left, .arm_geo_right, .albue_geo_left, .albue_geo_right');
											const legParts = newPart.querySelectorAll('.laar_geo_left, .laar_geo_right, .skinneben_geo_left, .skinneben_geo_right');

											// Funktion til at gøre farver mørkere
											function darkenColor(hex, factor = 0.92) {
												const r = parseInt(hex.slice(1, 3), 16);
												const g = parseInt(hex.slice(3, 5), 16);
												const b = parseInt(hex.slice(5, 7), 16);
												
												const newR = Math.round(r * factor);
												const newG = Math.round(g * factor);
												const newB = Math.round(b * factor);
												
												return `rgb(${newR}, ${newG}, ${newB})`;
											}

											const darkerColor = darkenColor(farveGradient, 0.92);

											if (head) head.style.background = farveGradient;
											if (torso) torso.style.background = farveGradient;
											armParts.forEach(arm => arm.style.background = darkerColor);
											legParts.forEach(leg => leg.style.background = darkerColor);
                                            
											
                                            
                                            newPart.style.zIndex = lag + 10;
                                            
                                            // Set keywords
                                            for (let i = 8; i <= 13; i++) {
                                                if (parts[i]) {
                                                    newPart.setAttribute(`data-keyword${i-7}`, parts[i]);
                                                }
                                            }
                                            
                                            // Load multi-background data if available
                                            if (parts.length >= 21 + (allBackgrounds.length * 6)) {
                                                let bgIndex = 21;
                                                allBackgrounds.forEach(bg => {
                                                    const bgX = parts[bgIndex] || posX;
                                                    const bgY = parts[bgIndex + 1] || posY;
                                                    const bgSize = parts[bgIndex + 2] || størrelse;
                                                    const bgRes1 = parts[bgIndex + 3] || '';
                                                    const bgRes2 = parts[bgIndex + 4] || '';
                                                    const bgRes3 = parts[bgIndex + 5] || '';
                                                    
                                                    newPart.setAttribute(`data-x-${bg}`, bgX);
                                                    newPart.setAttribute(`data-y-${bg}`, bgY);
                                                    newPart.setAttribute(`data-size-${bg}`, bgSize);
                                                    newPart.setAttribute(`data-res1-${bg}`, bgRes1);
                                                    newPart.setAttribute(`data-res2-${bg}`, bgRes2);
                                                    newPart.setAttribute(`data-res3-${bg}`, bgRes3);
                                                    
                                                    bgIndex += 6;
                                                });
												// Apply current background scale after loading all background data
												const currentScale = parseFloat(newPart.getAttribute(`data-size-${currentBackground}`)) || 1;
												newPart.style.transform = `scale(${currentScale})`;
                                            } else {
                                                // Initialize with current position for all backgrounds (legacy support)
                                                initializePartForAllBackgrounds(newPart, posX, posY, størrelse);
                                            }
                                            
                                            updatePartKeywords(newPart);
											// Apply the pose
											if (pose) {
												// Find pose index by name
												const poseIndex = poseLibrary.findIndex(p => p.name === pose);
												if (poseIndex !== -1) {
													applyPose(newPart, poseIndex, mirror);
												} else {
													resetPose(newPart);
												}
											} else {
												resetPose(newPart);
											}
                                        }
                                        
                                        // Set background if found
                                        if (baggrund && baggrund !== 'none') {
                                            document.getElementById('backgroundSelect').value = baggrund;
                                            currentBackground = baggrund;
                                            changeBackground();
                                        }
                                    }
                                }
                                
                                // ... eksisterende indlæsnings kode ...

								// Indlæs gruppenavne og farver
								for (let line of lines) {
									if (line.trim() === '' || !line.startsWith('Gruppe')) continue;
									
									const parts = line.split(';');
									if (parts.length >= 3) {
										const groupNumber = parts[0].replace('Gruppe', '');
										const groupName = parts[1] || '';
										const groupColor = parts[2] || '';
										
										const groupInput = document.getElementById(`group${groupNumber}`);
										if (groupInput) {
											groupInput.value = groupName;
										}
										
										const colorBtn = document.getElementById(`groupColor${groupNumber}`);
										if (colorBtn && groupColor) {
											colorBtn.style.backgroundColor = groupColor;
											colorBtn.setAttribute('data-custom-color', groupColor);
											colorBtn.removeAttribute('data-color-index');
										}
									}
								}
								
								// Apply group borders after group colors are loaded
								document.querySelectorAll('.part').forEach(part => {
									const partGroup = part.getAttribute('data-group');
									if (partGroup) {
										for (let i = 1; i <= 6; i++) {
											const groupInput = document.getElementById(`group${i}`);
											if (groupInput && groupInput.value.trim() === partGroup) {
												const colorBtn = document.getElementById(`groupColor${i}`);
												const groupColor = colorBtn.getAttribute('data-custom-color') || colorBtn.style.backgroundColor;
												const head = part.querySelector('.head');
												if (groupColor && head) {
													head.style.border = `4px solid ${groupColor}`;
												}
												break;
											}
										}
									}
								});
								
								
								// IndlÃ¦s alle background labels
								let inLabelSection = false;
								for (let line of lines) {
									const trimmedLine = line.trim();
									
									if (trimmedLine === '# Alle Baggrund Labels') {
										inLabelSection = true;
										continue;
									}
									
									if (inLabelSection && (trimmedLine === '' || trimmedLine.startsWith('#'))) {
										break;
									}
									
									if (inLabelSection && trimmedLine !== '') {
										const parts = line.split(';');
										if (parts.length >= 3) {
											const bg = parts[0];
											const key = parts[1];
											const value = parts[2] || '';
											
											if (!backgroundLabels[bg]) {
												backgroundLabels[bg] = { ...defaultLabels[bg] };
											}
											
											backgroundLabels[bg][key] = value;
										}
									}
								}
								
								
								// Indlæs generelle noter
								let inNotesSection = false;
								let notesContent = '';
								for (let line of lines) {
									const trimmedLine = line.trim();
									
									if (trimmedLine === '# Generelle Noter') {
										inNotesSection = true;
										continue;
									}
									
									if (inNotesSection) {
										notesContent += line.replace(/\\n/g, '\n') + '\n';
									}
								}
								generalNotes = notesContent.trim();
								document.getElementById('partNotes').value = generalNotes;

								// Opdater labels for nuværende baggrund
							renderLabels();

							document.querySelectorAll('.part').forEach(part => {
								const partGroup = part.getAttribute('data-group');
								if (partGroup) {
									for (let i = 1; i <= 6; i++) {
										const groupInput = document.getElementById(`group${i}`);
										if (groupInput && groupInput.value.trim() === partGroup) {
											const colorBtn = document.getElementById(`groupColor${i}`);
											const groupColor = colorBtn.getAttribute('data-custom-color') || colorBtn.style.backgroundColor;
											if (groupColor) {
											const head = part.querySelector('.head');
											if (head) {
												head.style.border = `4px solid ${groupColor}`;
												}
											}
											break;
										}
									}
								}
							});

                            // Indlæsning fuldført (silent)
                            // Persist sizes/positions after complete load
                            // Ensure layers are consistent after CSV load
                            normalizeLayers();
                            isLoadingSetup = false;
                            try { saveCharactersToShared(); } catch(_){}
                                
                            } catch (error) {
                                console.error('Fejl ved indlæsning:', error);
                                alert('Der opstod en fejl ved indlæsning af filen. Kontroller at det er en gyldig CSV-fil.');
                                isLoadingSetup = false;
                            }
                        };
                        reader.readAsText(file);
                        event.target.value = '';
                        // Skip auto-save during CSV load; final save happens after load completes
                    });
                }
                
                const keywordsVisibleCheckbox = document.getElementById('keywordsVisible');
                if (keywordsVisibleCheckbox) {
                    keywordsVisibleCheckbox.addEventListener('change', function() {
                        const allParts = document.querySelectorAll('.part');
                        allParts.forEach(part => {
                            updatePartKeywords(part);
                        });
                    });
                }
				
				const bodiesVisibleCheckbox = document.getElementById('bodiesVisible');
                if (bodiesVisibleCheckbox) {
                    bodiesVisibleCheckbox.addEventListener('change', toggleAllBodies);
                }
                
                updateGroupsDisplay();
                
                // Add event listeners for group inputs
                for (let i = 1; i <= 6; i++) {
                    const groupInput = document.getElementById(`group${i}`);
                    if (groupInput) {
                        groupInput.addEventListener('input', function() {
                            saveCurrentOpstillingToStorage();
                        });
                    }
                }
                
                // Initialize background
                renderBackground();
                renderLabels();
                
            } catch (error) {
                console.error('Fejl ved initialisering:', error);
            }
        });
        
        document.addEventListener('dragover', (e) => e.preventDefault());
        document.addEventListener('drop', (e) => e.preventDefault());
		
		function toggleAllBodies() {
			try {
				const workspace = document.getElementById('workspace');
				const checkbox = document.getElementById('bodiesVisible');
				
				if (checkbox.checked) {
					workspace.classList.remove('hide-bodies');
				} else {
					workspace.classList.add('hide-bodies');
				}
			} catch (error) {
				console.error('Fejl i toggleAllBodies:', error);
			}
		}
		
		
    </script>
</body>
</html>
                
                