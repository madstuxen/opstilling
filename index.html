<!DOCTYPE html>
<html lang="da">
<head>
	<script src="https://cdn.jsdelivr.net/npm/modern-screenshot@4.4.39/dist/index.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relations Opstilling - Multi-Background System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            padding: 5px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.0em;
            margin-bottom: 10px;
            font-weight: 300;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .toolbar {
            background: #f8fafc;
            padding: 12px 20px;

            border-bottom: 1px solid #e2e8f0;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .toolbar select, .toolbar input, .toolbar button {
			padding: 8px 16px;
			border: 2px solid #e2e8f0;
			border-radius: 10px;
			font-size: 15px;
			transition: all 0.3s ease;
		}
        
        .toolbar select {
            background: white;
            min-width: 180px;
            font-family: inherit;
        }
        
        .toolbar input[type="text"] {
            flex: 1;
            min-width: 200px;
            background: white;
        }

        /* Limit part name input width */
        #partName {
            max-width: 250px;
        }
        
        .toolbar input[type="text"]:focus, .toolbar select:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        .toolbar button {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
            min-width: 120px;
        }
        
        .toolbar button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }
        
        .clear-btn {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important;
        }
        
        .clear-btn:hover {
            box-shadow: 0 5px 15px rgba(239, 68, 68, 0.3) !important;
        }
        
        .save-btn {
			background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%) !important;
		}

		.save-btn:hover {
			box-shadow: 0 5px 15px rgba(139, 92, 246, 0.3) !important;
		}
        
		.export-btn {
			background: linear-gradient(135deg, #f97316 0%, #ea580c 100%) !important;
		}

		.export-btn:hover {
			box-shadow: 0 5px 15px rgba(249, 115, 22, 0.3) !important;
		}
		
		
        .load-btn {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%) !important;
        }
        
        .load-btn:hover {
            box-shadow: 0 5px 15px rgba(6, 182, 212, 0.3) !important;
        }
        
        .nav-btn {
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%) !important;
        }
        
        .nav-btn:hover {
            box-shadow: 0 5px 15px rgba(99, 102, 241, 0.3) !important;
        }
        
        .nav-btn-yellow {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%) !important;
        }
        
        .nav-btn-yellow:hover {
            box-shadow: 0 5px 15px rgba(245, 158, 11, 0.3) !important;
        }
        
        .toolbar-separator {
            width: 1px;
            height: 30px;
            background: #e2e8f0;
            margin: 0 8px;
            flex-shrink: 0;
        }
        
        .workspace {
            height: 600px;
            position: relative;
            background: #fafafa;
            overflow: hidden;
            cursor: crosshair;
            touch-action: auto;
        }
        
        .background-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        
        .background-labels {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: auto;
        }
        
        .label-input {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 14px;
            font-weight: 500;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 80px;
            transform: translate(-50%, -50%);
        }
        
        .label-input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3);
        }
        
        .part {
				position: absolute;
				width: 80px;
				height: 80px;
				cursor: move;
                transition: transform 0.44s ease-in-out, filter 0.44s ease-in-out;
				user-select: none;
                -webkit-user-select: none;
				touch-action: none;
				z-index: 10;
				will-change: transform;
				backface-visibility: hidden;
			}

/* Disable transitions while dragging to avoid lag/hitches */
.part.dragging {
    transition: none !important;
}

.part:hover {
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.25)) brightness(1.0);
    z-index: 100;
}

			.part.dragging {
                transition: filter 0.44s ease-in-out;
				filter: drop-shadow(0 4px 8px rgba(0,0,0,0.25)) brightness(1.0);
				z-index: 1000;
			}

			.part.selected {
				box-shadow: 0 0 0 2px #4f46e5, 0 0 0 4px rgba(79, 70, 229, 0.3);
			}
        
			/* Global body toggle - skjul kun torso, arme og ben */
			.hide-bodies .torso,
			.hide-bodies .skulder_translate_left,
			.hide-bodies .skulder_translate_right,
			.hide-bodies .hofte_translate_left,
			.hide-bodies .hofte_translate_right {
				display: none !important;
			}
		
		.head {
			position: absolute;
			top: -74px; left: 50%; transform: translateX(-50%);
			width:72px;
			height: 72px;
			border-radius: 50%;
			background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
			display: flex;
			align-items: center;
			justify-content: center;
			color: white;
			font-weight: bold;
			font-size: 12px;
			text-align: center;
			box-shadow: 0 8px 25px rgba(0,0,0,0.15);
			
			padding: 10px;
			line-height: 1.2;
			z-index: 5;
		}
		
			.head {
		pointer-events: auto;
		}

		.part-name {
			pointer-events: auto;
			cursor: text;
			font-size: 12px;
		}
		.part-name:hover {
			text-decoration: underline;
		}
				
        /* Krop (underkomponent af part) */
        .body {
            position: absolute;
            top: 77px;
            left: 50%;
            transform: translateX(-50%);
            transform-origin: 40px -77px;
            transition: transform 0.2s ease-out;
            z-index: -1;
            pointer-events: none;
            will-change: transform;
            backface-visibility: hidden;
        }
        
        /* Disable transitions during drag to avoid conflicts */
        .part.dragging .body {
            transition: none;
        }
        
        /* Also disable transitions when settling back to neutral */
        .body {
            transition: none !important;
        }
        
        
        /* Torso */
        .torso {
            width: 60px;
            height: 80px;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            margin: 0 auto;
            border-radius: 30px 30px 20px 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            position: relative;
            z-index: 5;
        }
        
       /* HÃ¸jre arm hierarki */
		.skulder_translate_right {
			position: absolute;
			top: 2px;
			left: 41px;
			width: 15px;
			height: 15px;
			background: rgba(59, 130, 246, 0.0);
			z-index: 3;
		}

		.skulder_translate_right.front-arm {
			z-index: 15;
		}

		.skulder_rotate_right {
			width: 100%;
			height: 100%;
			background: rgba(239, 68, 68, 0.0);
			transform-origin: center center;
		}

		.arm_geo_right {
			width: 50px;
			height: 18px;
			background: #f59e0b;
			border-radius: 9px;
			position: relative;
			top: -1px;
			left: -1px;
		}

		.albue_rotate_right {
			position: relative;
			top: 1px;
			left: 34px;
			width: 15px;
			height: 15px;
			background: rgba(16, 185, 129, 0.0);
			transform-origin: center center;
		}

		.albue_geo_right {
			position: relative;
			top: -1px;
			left: 1px;
			width: 50px;
			height: 18px;
			background: #f59e0b;
			border-radius: 9px;
			z-index: 4;
		}

		.albue_geo_right.front {
			z-index: 20 !important;
			position: relative;
		}

		/* Venstre arm hierarki */
		.skulder_translate_left {
			position: absolute;
			top: 2px;
			left: 4px;
			width: 15px;
			height: 15px;
			background: rgba(59, 130, 246, 0.0);
			z-index: 3;
		}

		.skulder_translate_left.front-arm {
			z-index: 15;
		}

		.skulder_rotate_left {
			width: 100%;
			height: 100%;
			background: rgba(239, 68, 68, 0.0);
			transform-origin: center center;
		}

		.arm_geo_left {
			width: 50px;
			height: 18px;
			background: #f59e0b;
			border-radius: 9px;
			position: relative;
			top: -1px;
			left: -34px;
		}

		.albue_rotate_left {
			position: relative;
			top: 1px;
			left: 0px;
			width: 15px;
			height: 15px;
			background: rgba(16, 185, 129, 0.0);
			transform-origin: center center;
		}

		.albue_geo_left {
			position: relative;
			top: -1px;
			left: -33px;
			width: 50px;
			height: 18px;
			background: #f59e0b;
			border-radius: 9px;
			z-index: 4;
		}

		.albue_geo_left.front {
			z-index: 20 !important;
			position: relative;
		}

		/* HÃ¸jre ben hierarki */
		.hofte_translate_right {
			position: absolute;
			top: 68px;
			left: 40px;
			width: 15px;
			height: 15px;
			background: rgba(59, 130, 246, 0.0);
		}

		.hofte_rotate_right {
			width: 100%;
			height: 100%;
			background: rgba(239, 68, 68, 0.0);
			transform-origin: center center;
		}

		.laar_geo_right {
			width: 18px;
			height: 55px;
			background: #f59e0b;
			border-radius: 9px;
			position: relative;
			top: -1px;
			left: -1px;
		}

		.knae_rotate_right {
			position: relative;
			top: 38px;
			left: 1px;
			width: 15px;
			height: 15px;
			background: rgba(16, 185, 129, 0.0);
			transform-origin: center center;
		}

		.skinneben_geo_right {
			position: relative;
			top: -1px;
			left: -1px;
			width: 18px;
			height: 50px;
			background: #f59e0b;
			border-radius: 9px;
		}

		/* Venstre ben hierarki */
		.hofte_translate_left {
			position: absolute;
			top: 68px;
			left: 4px;
			width: 15px;
			height: 15px;
			background: rgba(59, 130, 246, 0.0);
		}

		.hofte_rotate_left {
			width: 100%;
			height: 100%;
			background: rgba(239, 68, 68, 0.0);
			transform-origin: center center;
		}

		.laar_geo_left {
			width: 18px;
			height: 55px;
			background: #f59e0b;
			border-radius: 9px;
			position: relative;
			top: -1px;
			left: -1px;
		}

		.knae_rotate_left {
			position: relative;
			top: 38px;
			left: 1px;
			width: 15px;
			height: 15px;
			background: rgba(16, 185, 129, 0.0);
			transform-origin: center center;
		}

		.skinneben_geo_left {
			position: relative;
			top: -1px;
			left: -1px;
			width: 18px;
			height: 50px;
			background: #f59e0b;
			border-radius: 9px;
		}
		
		
		
		
        .part-keywords {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            color: #374151;
            font-size: 12px;
            text-align: center;
            font-weight: normal;
            line-height: 1.1;
            width: 100px;
            white-space: nowrap;
            z-index: 15;
        }
        
        .keywords-above {
            bottom: calc(50% + 15px);
        }
        
        .keywords-below {
            top: calc(50% + 15px);
        }
        
        .control-btn {
            position: absolute;
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            font-size: 14px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            z-index: 1000;
            color: white;
            padding: 0;
            margin: 0;
            top: 50%;
            left: 50%;
            transform-origin: center center;
            pointer-events: none;
        }

        .part:hover .control-btn {
            display: flex !important;
            pointer-events: auto;
        }

        /* On mobile (tap selection), show controls when selected too */
        .part.selected .control-btn {
            display: flex !important;
            pointer-events: auto;
        }
        
        .delete-btn {
            transform: translate(18px, -52px);
            background: #ef4444;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
        }
        
        .layer-up {
            transform: translate(-52px, -52px);
            background: #4f46e5;
            box-shadow: 0 2px 8px rgba(79, 70, 229, 0.3);
        }
        
        .size-plus {
            transform: translate(-17px, -52px);
            background: #059669;
            box-shadow: 0 2px 8px rgba(5, 150, 105, 0.3);
        }
        
        .edit-btn {
            transform: translate(18px, -17px);
            background: #f59e0b;
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
        }
        
        .layer-down {
            transform: translate(-52px, 18px);
            background: #4f46e5;
            box-shadow: 0 2px 8px rgba(79, 70, 229, 0.3);
        }
        
        .size-minus {
            transform: translate(-17px, 18px);
            background: #059669;
            box-shadow: 0 2px 8px rgba(5, 150, 105, 0.3);
        }

        .color-btn {
            transform: translate(18px, 18px);
            background: #a855f7;
            box-shadow: 0 2px 8px rgba(168, 85, 247, 0.3);
        }
		
		.pose-btn {
			transform: translate(18px, -17px);
			background: #06b6d4;
			box-shadow: 0 2px 8px rgba(6, 182, 212, 0.3);
		}


        
        .delete-btn:hover {
            transform: translate(18px, -52px) scale(1.1);
            background: #dc2626;
        }
        
        .layer-up:hover {
            transform: translate(-52px, -52px) scale(1.1);
            background: #3730a3;
        }
        
        .size-plus:hover {
            transform: translate(-17px, -52px) scale(1.1);
            background: #047857;
        }
        
        .edit-btn:hover {
            transform: translate(18px, -17px) scale(1.1);
            background: #b8650c;
        }
        
        .layer-down:hover {
            transform: translate(-52px, 18px) scale(1.1);
            background: #3730a3;
        }
        
        .size-minus:hover {
            transform: translate(-17px, 18px) scale(1.1);
            background: #047857;
        }

        .color-btn:hover {
            transform: translate(18px, 18px) scale(1.1);
            background: #9333ea;
        }
		
		.pose-btn:hover {
			transform: translate(18px, -17px) scale(1.1);
			background: #0891b2;
		}
				
        /* Color Picker Styles */
        .color-picker-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }
        
        .color-picker-modal.show {
            display: flex;
        }
        
        .picker {
            width: 224px;
            background: #ffffff;
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border: 1px solid #e2e8f0;
        }
        
        .swatch {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            border: 1px solid rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .swatch:hover {
            transform: scale(1.2);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 10;
        }
        
        .color-grid {
            display: grid;
            grid-template-columns: repeat(12, 15px);
            grid-template-rows: repeat(14, 15px);
            gap: 2px;
            background: transparent;
        }
        
        .swatch:focus {
            outline: 2px solid #4f46e5;
            outline-offset: 1px;
        }
		
		
		/* Pose Picker Styles */
		.pose-picker-modal {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: transparent;
			display: none;
			align-items: center;
			justify-content: center;
			z-index: 3000;
		}

		.pose-picker-modal.show {
			display: flex;
		}

		.pose-picker {
			width: 280px;
			background: #ffffff;
			padding: 15px;
			border-radius: 12px;
			box-shadow: 0 10px 30px rgba(0,0,0,0.2);
			border: 1px solid #e2e8f0;
		}

		.pose-mirror-section {
			text-align: center;
			margin-bottom: 15px;
			padding-bottom: 10px;
			border-bottom: 1px solid #e2e8f0;
		}

		.pose-mirror-label {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 8px;
			font-size: 14px;
			font-weight: 500;
			color: #374151;
			cursor: pointer;
		}

		.pose-mirror-label input[type="checkbox"] {
			width: 16px;
			height: 16px;
			transform: scale(1.2);
		}

		.pose-grid {
			display: grid;
			grid-template-columns: repeat(3, 1fr);
			gap: 8px;
		}

		.pose-button {
			padding: 8px 12px;
			border: 2px solid #e2e8f0;
			border-radius: 8px;
			background: white;
			color: #374151;
			font-size: 12px;
			font-weight: 500;
			cursor: pointer;
			transition: all 0.2s ease;
			text-align: center;
		}

		.pose-button:hover {
			border-color: #3b82f6;
			background: #f0f9ff;
			color: #1d4ed8;
		}

		.pose-button.active {
			border-color: #3b82f6;
			background: #3b82f6;
			color: white;
		}
		
		
		
        
        .instructions {
            padding: 20px;
            background: #f1f5f9;
            color: #475569;
            text-align: center;
            border-top: 1px solid #e2e8f0;
        }
        
        .notes-title {
            background: #f8fafc;
            padding: 15px 20px 5px 20px;
            border-top: 1px solid #e2e8f0;
            text-align: center;
        }
        
        .notes-title h3 {
            margin: 0;
            color: #475569;
            font-size: 18px;
            font-weight: 600;
        }
        
        .notes-section {
            background: #f8fafc;
            padding: 15px 20px 20px 20px;
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: 30px;
        }
        
        .notes-content {
            display: flex;
            gap: 30px;
            width: 100%;
        }
        
        .groups-section {
			flex: 0 0 250px;
			min-width: 250px;
		}
        
        .groups-section h4 {
            margin: 0 0 10px 0;
            color: #475569;
            font-size: 16px;
        }
        
        .group-input-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .group-input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            background: white;
        }
        
        .group-color-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: none;
            background: #ef4444;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
            flex-shrink: 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .group-color-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .keywords-section {
            flex: 0 0 300px;
            min-width: 300px;
            max-width: 300px;
        }
        
        .keywords-section h4 {
            margin: 0 0 10px 0;
            color: #475569;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .visibility-checkbox {
            margin-right: 8px;
            transform: scale(1.2);
        }
        
        .keyword-input {
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 8px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            background: white;
        }
        
        .group-dropdown {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            background: white;
            margin-bottom: 10px;
        }
        
        .group-input:focus, .keyword-input:focus, .group-dropdown:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        .notes-container {
            flex: 1;
            min-width: 300px;
        }
        
        .notes-container h4 {
            margin: 0 0 10px 0;
            color: #475569;
            font-size: 16px;
        }
        
        .notes-section textarea {
            width: 100%;
            min-height: 256px;
            padding: 15px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 16px;
            font-family: inherit;
            background: white;
            resize: vertical;
        }
        
        .notes-section textarea:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        .notes-section p {
            margin: 10px 0 0 0;
            font-size: 14px;
            color: #6b7280;
        }
        
        .name-input {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #4f46e5;
            border-radius: 8px;
            padding: 4px 8px;
            font-size: inherit;
            font-weight: bold;
            text-align: center;
            color: #1f2937;
            width: 90%;
            max-width: 100px;
        }
        
        .name-input:focus {
            outline: none;
            border-color: #7c3aed;
            box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.3);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }
        
        .part {
            animation: fadeIn 0.5s ease-out;
        }
		
		/* Keywords Popup Modal */
.keywords-popup-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: transparent;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 3000;
}

.keywords-popup-modal.show {
    display: flex;
}

.keywords-popup {
    width: 400px;
    background: #ffffff;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    border: 1px solid #e2e8f0;
}

.keywords-popup h3 {
    margin: 0 0 15px 0;
    color: #374151;
    font-size: 18px;
}

.keywords-popup-input {
    width: 100%;
    padding: 8px 12px;
    margin-bottom: 10px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 14px;
    font-family: inherit;
    background: white;
}

.keywords-popup-input:focus {
    outline: none;
    border-color: #4f46e5;
    box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
}

.keywords-popup-button {
    width: 100%;
    padding: 12px;
    background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    margin-top: 10px;
}

.keywords-popup-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(79, 70, 229, 0.3);
}




		
		
		
    	/* Mobile adjustments */
	@media (hover: none) and (pointer: coarse) {
		body {
			padding: 5px;
		}
		.container {
			border-radius: 12px;
		}
    		.header {
			padding: 5px;
    		}
		.header h1 {
			font-size: 2.0em;
			margin-bottom: 0;
		}
		.toolbar {
			padding: 8px 12px;
			gap: 10px;
		}
		.toolbar select, .toolbar input, .toolbar button {
			padding: 6px 10px;
			font-size: 13px;
			border-radius: 8px;
			min-width: auto;
		}
		.workspace {
			height: 65vh;
			overflow: auto;
			-webkit-overflow-scrolling: touch;
			touch-action: pan-x pan-y;
		}
		.notes-title h3 { font-size: 16px; }
		.groups-section h4, .keywords-section h4, .notes-container h4 { font-size: 14px; }
		.keyword-input, .group-input, .group-dropdown { font-size: 13px; }
		/* Make notes section horizontally scrollable on touch */
		.notes-section {
			overflow-x: auto;
			-webkit-overflow-scrolling: touch;
		}
		.notes-content {
			min-width: 900px; /* ensure content wider than viewport so it can scroll */
			gap: 20px;
		}
		.groups-section, .keywords-section, .notes-container {
			flex: 0 0 auto; /* prevent shrinking so horizontal scroll works */
		}
		/* Scale pose picker on mobile to half size */
		.pose-picker {
			transform: scale(0.5);
			transform-origin: top left;
		}
    	}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Opstilling</h1>
        </div>
        
        <div class="toolbar">
			
			<select id="themeSelect" onchange="changeTheme()">
				<option value="">VÃ¦lg tema...</option>
				<option value="ifs_default">IFS Standard</option>
				<option value="Skygge">Skyggearbejde</option>
			</select>
			
			
            <select id="backgroundSelect" onchange="changeBackground()">
                <option value="none">Ingen baggrund</option>
                <option value="har_onsker">Har/Ãnsker</option>
                <option value="xy_axes">X/Y Akser</option>
                <option value="timeline">Tidslinje</option>
                <option value="for_imod">For/Imod</option>
                <option value="drama_trekant">Drama Trekant</option>
				<option value="mandala">Mandala Cirkel</option>
            </select>
            <input type="text" id="partName" placeholder="Navn pÃ¥ del (f.eks. Beskytteren, Den Kritiske, Det SÃ¥rede Barn...)" maxlength="30">
            <button onclick="addPart()">TilfÃ¸j Del</button>
            <button onclick="saveSetup()" class="save-btn">Gem Opstilling</button>
            <button onclick="loadSetup()" class="load-btn">IndlÃ¦s Opstilling</button>
            <button onclick="exportAsImage()" class="export-btn">Gem Billede</button>
            <button onclick="clearAll()" class="clear-btn">Ryd Alt</button>
            <div class="toolbar-separator"></div>
            <button onclick="window.location.href='compare_01.html'" class="nav-btn">Forskelle</button>
            <button onclick="window.location.href='dialog_01.html'" class="nav-btn-yellow">Samtale</button>
            <input type="file" id="fileInput" accept=".csv" style="display: none;">
        </div>
        
        <div class="workspace" id="workspace">
            <div class="background-layer" id="backgroundLayer"></div>
            <div class="background-labels" id="backgroundLabels"></div>
        </div>
        
        <div class="notes-title">
			<div style="display: flex; gap: 20px; align-items: center; justify-content: center; padding: 10px 0;">
				<label style="display: flex; align-items: center; gap: 5px; font-size: 14px; color: #475569;">
					<input type="checkbox" id="keywordsVisible" class="visibility-checkbox">
					Stikord (vises pÃ¥ cirklen)
				</label>
				<label style="display: flex; align-items: center; gap: 5px; font-size: 14px; color: #475569;">
					<input type="checkbox" id="bodiesVisible" class="visibility-checkbox" checked>
					Kroppe synlige
				</label>
			</div>
		</div>
        
        <div class="notes-section">
            <div class="notes-content">
                <div class="groups-section">
                    <h4>Grupper</h4>
                    <div id="groupFields">
                        <div class="group-input-container">
                            <input type="text" class="group-input" id="group1" placeholder="Gruppe 1" value="Manager" maxlength="50">
                            <button class="group-color-btn" id="groupColor1" data-color-index="0" onclick="changeGroupColor(1)">C</button>
                        </div>
                        <div class="group-input-container">
                            <input type="text" class="group-input" id="group2" placeholder="Gruppe 2" value="Brandmand" maxlength="50">
                            <button class="group-color-btn" id="groupColor2" data-color-index="1" onclick="changeGroupColor(2)">C</button>
                        </div>
                        <div class="group-input-container">
                            <input type="text" class="group-input" id="group3" placeholder="Gruppe 3" value="Eksileret" maxlength="50">
                            <button class="group-color-btn" id="groupColor3" data-color-index="2" onclick="changeGroupColor(3)">C</button>
                        </div>
                        <div class="group-input-container">
                            <input type="text" class="group-input" id="group4" placeholder="Gruppe 4" value="Ekstern" maxlength="50">
                            <button class="group-color-btn" id="groupColor4" data-color-index="3" onclick="changeGroupColor(4)">C</button>
                        </div>
                        <div class="group-input-container">
                            <input type="text" class="group-input" id="group5" placeholder="Gruppe 5" maxlength="50">
                            <button class="group-color-btn" id="groupColor5" data-color-index="4" onclick="changeGroupColor(5)">C</button>
                        </div>
                        <div class="group-input-container">
                            <input type="text" class="group-input" id="group6" placeholder="Gruppe 6" maxlength="50">
                            <button class="group-color-btn" id="groupColor6" data-color-index="5" onclick="changeGroupColor(6)">C</button>
                        </div>
                    </div>
                    <div id="groupDropdown" style="display: none;">
                        <select class="group-dropdown" id="partGroupSelect" onchange="handleGroupSelection(this)">
                            <option value="">VÃ¦lg gruppe...</option>
                        </select>
                    </div>
					<div id="poseControls" style="display: none;">
						<div style="font-size: 14px; font-weight: 500; color: #374151; margin-top: 10px; margin-bottom: 5px;">Pose:</div>
						<div style="display: flex; align-items: center; gap: 8px;">
							<select class="group-dropdown" id="partPoseSelect" onchange="applyPartPose(this.value)" style="flex: 1;">
								<option value="">Standard pose</option>
							</select>
							<div style="display: flex; align-items: center; gap: 4px;">
								<input type="checkbox" id="partMirrorPose" onchange="togglePartMirror()" style="width: 12px; height: 12px;">
								<label for="partMirrorPose" style="font-size: 10px; color: #6b7280;">Spejl</label>
							</div>
						</div>
					</div>
                </div>
                
                <div class="keywords-section">
                    <h4>Stikord</h4>
                    <input type="text" class="keyword-input" id="keyword1" placeholder="Alder" maxlength="70">
                    <input type="text" class="keyword-input" id="keyword2" placeholder="Relation" maxlength="70">
                    <input type="text" class="keyword-input" id="keyword3" placeholder="kÃ¸n" maxlength="70">
                    <input type="text" class="keyword-input" id="keyword4" placeholder="Stikord 4" maxlength="70">
                    <input type="text" class="keyword-input" id="keyword5" placeholder="Stikord 5" maxlength="70">
                    <input type="text" class="keyword-input" id="keyword6" placeholder="Stikord 6" maxlength="70">
                </div>
                
                <div class="notes-container">
                    <h4 id="notesContainerTitle">Noter til opstilling</h4>

					
                    <textarea id="partNotes" placeholder="Generelle noter for opstillingen.Klik evt pÃ¥ en cirkel for at vÃ¦lge den og redigere dens information..."></textarea>
                </div>
            </div>
        </div>
        
        <div class="instructions">
            <p><strong>SÃ¥dan bruger du vÃ¦rktÃ¸jet:</strong> VÃ¦lg baggrund fra dropdown, tilfÃ¸j dele ved at skrive navn og klikke "TilfÃ¸j Del" eller trykke Enter. TrÃ¦k delene rundt for at se deres forhold til hinanden. Hold musen over en del for at se kontrolknapperne: Ã for at slette, T for at redigere navn, ââ for lag, +â for stÃ¸rrelse, C for farve. Klik pÃ¥ en del for at vÃ¦lge den og redigere dens stikord og noter. Definer grupper i venstre kolonne og tildel valgte dele til grupper. Gem din opstilling som CSV-fil og indlÃ¦s den senere. <strong>NYT:</strong> Hver baggrund gemmer sine egne positioner og stÃ¸rrelser - skift mellem baggrunde for forskellige visninger af samme dele!</p>
        </div>
    </div>

    <!-- Color Picker Modal -->
    <div class="color-picker-modal" id="colorPickerModal">
        <div class="picker">
            <div class="color-grid" id="colorGrid"></div>
        </div>
    </div>
	
	<!-- Pose Picker Modal -->
	<div class="pose-picker-modal" id="posePickerModal">
		<div class="pose-picker">
			<div class="pose-mirror-section">
				<label class="pose-mirror-label">
					<input type="checkbox" id="posePickerMirror" onchange="togglePosePickerMirror()">
					<span>Spejl</span>
				</label>
			</div>
			<div class="pose-grid" id="poseGrid"></div>
		</div>
	</div>
	<!-- Keywords Popup Modal -->
	<div class="keywords-popup-modal" id="keywordsPopupModal">
		<div class="keywords-popup">
			<h3>Stikord for <span id="keywordsPopupName"></span></h3>
			<input type="text" class="keywords-popup-input" id="popupKeyword1" placeholder="Alder" maxlength="70">
			<input type="text" class="keywords-popup-input" id="popupKeyword2" placeholder="Relation" maxlength="70">
			<input type="text" class="keywords-popup-input" id="popupKeyword3" placeholder="KÃ¸n" maxlength="70">
			<input type="text" class="keywords-popup-input" id="popupKeyword4" placeholder="Stikord 4" maxlength="70">
			<input type="text" class="keywords-popup-input" id="popupKeyword5" placeholder="Stikord 5" maxlength="70">
			<input type="text" class="keywords-popup-input" id="popupKeyword6" placeholder="Stikord 6" maxlength="70">
			<button class="keywords-popup-button" onclick="closeKeywordsPopup()">Senere</button>
		</div>
	</div>
	
	
	
	

    <script>
        // Multi-background system variables
        let currentBackground = 'none';
		const allBackgrounds = ['none', 'har_onsker', 'xy_axes', 'timeline', 'for_imod', 'drama_trekant', 'mandala'];        
        // Background functionality variables
        let currentGroupBtn = null;
        let backgroundLabels = {};
		let currentKeywordsPart = null;
        
        // Original functionality variables
        let partCounter = 0;
        let draggedElement = null;
        let offset = { x: 0, y: 0 };
        let selectedPart = null;
        let colorIndex = 0;
		let generalNotes = '';
		
		// Simple drag animation variables
		let dragState = null;
        
        // Color picker variables
        let currentPart = null;

        // Simpel Shared Data System
        const SHARED_DATA_KEY = 'relationsSetupData';
        let isLoadingSetup = false;
        
        function saveCharactersToShared() {
            if (isLoadingSetup) return;
            const parts = document.querySelectorAll('.part');
            const characters = [];
            
            parts.forEach(part => {
                // Resolve pose name from data-pose (index or name)
                const rawPose = part.getAttribute('data-pose') || '';
                let resolvedPoseName = '';
                if (rawPose !== '') {
                    const maybeIndex = Number(rawPose);
                    if (!Number.isNaN(maybeIndex)) {
                        resolvedPoseName = (poseLibrary[maybeIndex]?.name) || '';
                    } else {
                        resolvedPoseName = rawPose;
                    }
                }

                const character = {
                    id: part.id,
                    name: part.querySelector('.part-name').textContent,
                    x: parseInt(part.style.left) || 0,
                    y: parseInt(part.style.top) || 0,
                    size: parseFloat(part.getAttribute(`data-size-${currentBackground}`)) || 1,
                    layer: parseInt(part.getAttribute('data-layer')) || 1,
                    color: part.getAttribute('data-custom-color') || 
                           partColors[parseInt(part.getAttribute('data-color-index')) || 0],
                    keywords: [
                        part.getAttribute('data-keyword1') || '',
                        part.getAttribute('data-keyword2') || '',
                        part.getAttribute('data-keyword3') || '',
                        part.getAttribute('data-keyword4') || '',
                        part.getAttribute('data-keyword5') || '',
                        part.getAttribute('data-keyword6') || ''
                    ],
                    pose: resolvedPoseName,
                    mirror: part.getAttribute('data-mirror') === 'true'
                };
                
                characters.push(character);
            });
            
            const sharedData = {
                characters: characters,
                lastUpdated: new Date().toISOString()
            };
            
            localStorage.setItem(SHARED_DATA_KEY, JSON.stringify(sharedData));
            
            // Also save to current_opstilling
            saveCurrentOpstillingToStorage();
        }
        
        const partColors = [
            '#f59e0b',  // orange/gul
            '#0891b2',  // cyan
            '#db2777',  // pink
            '#7c3aed',  // lilla
            '#059669',  // grÃ¸n
            '#ea580c',  // orange
            '#dc2626',  // rÃ¸d
            '#2563eb',  // blÃ¥
            '#65a30d',  // lime grÃ¸n
            '#9333ea'   // violet
        ];
        
        const borderColors = ['#fbbf24', '#06b6d4', '#ec4899', '#8b5cf6', '#10b981', '#f97316', '#ef4444', '#3b82f6', '#84cc16', '#a855f7'];
        
        const groupColors = [
            '#ef4444', // rÃ¸d
            '#f97316', // orange  
            '#eab308', // gul
            '#22c55e', // grÃ¸n
            '#06b6d4', // cyan
            '#3b82f6', // blÃ¥
            '#8b5cf6', // lilla
            '#ec4899', // pink
            '#64748b', // grÃ¥
            '#059669'  // mÃ¸rk grÃ¸n
        ];
		
		
		
		const presets = {
    ifs_default: `
# Gruppenavne
Gruppe1;Manager;#ef4444
Gruppe2;Brandmand;#f97316
Gruppe3;Eksileret;#eab308
Gruppe4;Ekstern;#22c55e
Gruppe5;;#06b6d4
Gruppe6;;#3b82f6

# Alle Baggrund Labels
har_onsker;topLeft;Har/Ãnsker
har_onsker;topRight;Har/Ãnsker-ikke
har_onsker;bottomLeft;Har ikke/Ãnsker
har_onsker;bottomRight;Har ikke/Ãnsker ikke
xy_axes;xLabel;X-akse
xy_axes;yLabel;Y-akse
timeline;title;Tidslinje
timeline;start;Start
timeline;end;Slut
for_imod;left;For
for_imod;right;Imod
drama_trekant;offer;Offer
drama_trekant;hjaelper;HjÃ¦lper
drama_trekant;boeddel;BÃ¸ddel
mandala;kerne;Kerne
mandala;primaer;PrimÃ¦r
mandala;sekundaer;SekundÃ¦r
mandala;periferi;Periferi`,

    Skygge: `
# Gruppenavne
Gruppe1;Skygge;#2e2e2e
Gruppe2;Maske;#f90606
Gruppe3;Bevidst;#80f906
Gruppe4;;#22c55e
Gruppe5;;#06b6d4
Gruppe6;;#3b82f6

# Alle Baggrund Labels
har_onsker;topLeft;Bevidst/Positiv
har_onsker;topRight;Bevidst/Negativ
har_onsker;bottomLeft;Skygge/Positiv
har_onsker;bottomRight;Skygge/Negativ
xy_axes;xLabel;X-akse
xy_axes;yLabel;Y-akse
timeline;title;Tidslinje
timeline;start;Start
timeline;end;Slut
for_imod;left;For
for_imod;right;Imod
drama_trekant;offer;Offer
drama_trekant;hjaelper;HjÃ¦lper
drama_trekant;boeddel;BÃ¸ddel
mandala;kerne;Kerne
mandala;primaer;PrimÃ¦r
mandala;sekundaer;SekundÃ¦r
mandala;periferi;Periferi`
};

        
        const defaultLabels = {
            har_onsker: {
                topLeft: 'Har/Ãnsker',
                topRight: 'Har/Ãnsker-ikke', 
                bottomLeft: 'Har ikke/Ãnsker',
                bottomRight: 'Har ikke/Ãnsker ikke'
            },
            xy_axes: {
                xLabel: 'X-akse',
                yLabel: 'Y-akse'
            },
            timeline: {
                title: 'Tidslinje',
                start: 'Start',
                end: 'Slut'
            },
            for_imod: {
                left: 'For',
                right: 'Imod'
            },
            drama_trekant: {
                offer: 'Offer',
                hjaelper: 'HjÃ¦lper',
                boeddel: 'BÃ¸ddel'
            },
			mandala: {
				kerne: 'Kerne',
				primaer: 'PrimÃ¦r',
				sekundaer: 'SekundÃ¦r',
				periferi: 'Periferi'
			}
        };
		
		////pose bibliotek
// Pose Library - loaded from external JSON file
let poseLibrary = [];

// Load pose library from external JSON file
async function loadPoseLibrary() {
    try {
        const response = await fetch('Standard_new_poses.json');
        if (response.ok) {
            poseLibrary = await response.json();
        } else {
            console.error('Failed to load pose library');
            // Fallback to basic poses
            poseLibrary = [
                {
                    "name": "standard",
                    "pose": {
                        "translate_x_left": -3,
                        "translate_y_left": 0,
                        "skulder_rot_left": -70,
                        "albue_rot_left": 0,
                        "translate_x": 3,
                        "translate_y": 0,
                        "skulder_rot": 70,
                        "albue_rot": 0,
                        "translate_x_left_leg": 0,
                        "translate_y_left_leg": 0,
                        "hofte_rot_left": 6,
                        "knae_rot_left": 0,
                        "translate_x_right_leg": 0,
                        "translate_y_right_leg": 0,
                        "hofte_rot_right": -6,
                        "knae_rot_right": 0,
                        "left_arm_front": false,
                        "right_arm_front": false,
                        "duration": 0.3
                    }
                }
            ];
        }
    } catch (error) {
        console.error('Error loading pose library:', error);
        // Fallback to basic poses
        poseLibrary = [
            {
                "name": "standard",
                "pose": {
                    "translate_x_left": -3,
                    "translate_y_left": 0,
                    "skulder_rot_left": -70,
                    "albue_rot_left": 0,
                    "translate_x": 3,
                    "translate_y": 0,
                    "skulder_rot": 70,
                    "albue_rot": 0,
                    "translate_x_left_leg": 0,
                    "translate_y_left_leg": 0,
                    "hofte_rot_left": 6,
                    "knae_rot_left": 0,
                    "translate_x_right_leg": 0,
                    "translate_y_right_leg": 0,
                    "hofte_rot_right": -6,
                    "knae_rot_right": 0,
                    "left_arm_front": false,
                    "right_arm_front": false,
                    "duration": 0.3
                }
            }
        ];
    }
}
		
		
//////////	slut	// pose bibliotek
		
		function resetPose(part) {
			// Apply the "standard" pose from poseLibrary if available; fallback to previous relaxed pose
			const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
			if (standardIndex !== -1) {
				// Persist selection so it is saved to storage for new parts
				part.setAttribute('data-pose', standardIndex.toString());
				part.setAttribute('data-mirror', 'false');
				applyPose(part, standardIndex, false);
				return;
			}
			const relaxedPose = {
				translate_x_left: -3,
				translate_y_left: 0,
				skulder_rot_left: -70,
				albue_rot_left: 0,
				translate_x: 3,
				translate_y: 0,
				skulder_rot: 70,
				albue_rot: 0,
				translate_x_left_leg: 0,
				translate_y_left_leg: 0,
				hofte_rot_left: 6,
				knae_rot_left: 0,
				translate_x_right_leg: 0,
				translate_y_right_leg: 0,
				hofte_rot_right: -6,
				knae_rot_right: 0,
				left_arm_front: false,
				right_arm_front: false
			};
			applyPoseData(part, relaxedPose);
		}

		function applyPose(part, poseIndex, mirror = false) {
			if (poseIndex === '' || poseIndex === null) {
				resetPose(part);
				return;
			}
			
			const pose = poseLibrary[poseIndex];
			if (!pose) return;
			
			let poseData = pose.pose;
			
			// If mirror is checked, create mirrored version
			if (mirror) {
				poseData = {
					translate_x_left: -(pose.pose.translate_x || 0),
					translate_x: -(pose.pose.translate_x_left || 0),
					translate_y_left: pose.pose.translate_y || 0,
					translate_y: pose.pose.translate_y_left || 0,
					skulder_rot_left: -(pose.pose.skulder_rot || 0),
					skulder_rot: -(pose.pose.skulder_rot_left || 0),
					albue_rot_left: -(pose.pose.albue_rot || 0),
					albue_rot: -(pose.pose.albue_rot_left || 0),
					translate_x_left_leg: -(pose.pose.translate_x_right_leg || 0),
					translate_x_right_leg: -(pose.pose.translate_x_left_leg || 0),
					translate_y_left_leg: pose.pose.translate_y_right_leg || 0,
					translate_y_right_leg: pose.pose.translate_y_left_leg || 0,
					hofte_rot_left: -(pose.pose.hofte_rot_right || 0),
					hofte_rot_right: -(pose.pose.hofte_rot_left || 0),
					knae_rot_left: -(pose.pose.knae_rot_right || 0),
					knae_rot_right: -(pose.pose.knae_rot_left || 0),
					left_arm_front: pose.pose.right_arm_front || false,
					right_arm_front: pose.pose.left_arm_front || false
				};
			}
			
			applyPoseData(part, poseData);
		}

		function applyPoseData(part, poseData) {
			const skulderLeft = part.querySelector('.skulder_translate_left');
			const skulderRight = part.querySelector('.skulder_translate_right');
			const hofteLeft = part.querySelector('.hofte_translate_left');
			const hofteRight = part.querySelector('.hofte_translate_right');
			
			if (skulderLeft) {
				skulderLeft.style.transform = `translate(${poseData.translate_x_left || 0}px, ${poseData.translate_y_left || 0}px)`;
				const skulderRotLeft = skulderLeft.querySelector('.skulder_rotate_left');
				if (skulderRotLeft) {
					skulderRotLeft.style.transform = `rotate(${poseData.skulder_rot_left || 0}deg)`;
					const albueRotLeft = skulderRotLeft.querySelector('.albue_rotate_left');
					if (albueRotLeft) {
						albueRotLeft.style.transform = `rotate(${poseData.albue_rot_left || 0}deg)`;
					}
				}
			}
			
			if (skulderRight) {
				skulderRight.style.transform = `translate(${poseData.translate_x || 0}px, ${poseData.translate_y || 0}px)`;
				const skulderRotRight = skulderRight.querySelector('.skulder_rotate_right');
				if (skulderRotRight) {
					skulderRotRight.style.transform = `rotate(${poseData.skulder_rot || 0}deg)`;
					const albueRotRight = skulderRotRight.querySelector('.albue_rotate_right');
					if (albueRotRight) {
						albueRotRight.style.transform = `rotate(${poseData.albue_rot || 0}deg)`;
					}
				}
			}
			
			if (hofteLeft) {
				hofteLeft.style.transform = `translate(${poseData.translate_x_left_leg || 0}px, ${poseData.translate_y_left_leg || 0}px)`;
				const hofteRotLeft = hofteLeft.querySelector('.hofte_rotate_left');
				if (hofteRotLeft) {
					hofteRotLeft.style.transform = `rotate(${poseData.hofte_rot_left || 0}deg)`;
					const knaeRotLeft = hofteRotLeft.querySelector('.knae_rotate_left');
					if (knaeRotLeft) {
						knaeRotLeft.style.transform = `rotate(${poseData.knae_rot_left || 0}deg)`;
					}
				}
			}
			
			if (hofteRight) {
				hofteRight.style.transform = `translate(${poseData.translate_x_right_leg || 0}px, ${poseData.translate_y_right_leg || 0}px)`;
				const hofteRotRight = hofteRight.querySelector('.hofte_rotate_right');
				if (hofteRotRight) {
					hofteRotRight.style.transform = `rotate(${poseData.hofte_rot_right || 0}deg)`;
					const knaeRotRight = hofteRotRight.querySelector('.knae_rotate_right');
					if (knaeRotRight) {
						knaeRotRight.style.transform = `rotate(${poseData.knae_rot_right || 0}deg)`;
					}
				}
			}
			
			// Handle arm layering
			if (poseData.left_arm_front) {
				skulderLeft.classList.add('front-arm');
			} else {
				skulderLeft.classList.remove('front-arm');
			}
			
			if (poseData.right_arm_front) {
				skulderRight.classList.add('front-arm');
			} else {
				skulderRight.classList.remove('front-arm');
			}
			
		}		
		
		function updatePoseDropdown() {
			const dropdown = document.getElementById('partPoseSelect');
			const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
			if (standardIndex !== -1) {
				dropdown.innerHTML = '';
			} else {
				dropdown.innerHTML = '<option value="">Standard pose</option>';
			}
			
			poseLibrary.forEach((pose, index) => {
				const option = document.createElement('option');
				option.value = index;
				option.textContent = pose.name;
				dropdown.appendChild(option);
			});
		}

		function applyPartPose(poseIndex) {
			if (!selectedPart) return;
			
			const mirror = document.getElementById('partMirrorPose').checked;
			
			// Save pose data to part (store as string for consistency)
			selectedPart.setAttribute('data-pose', poseIndex.toString());
			selectedPart.setAttribute('data-mirror', mirror.toString());
			
			// Apply the pose (convert to number for applyPose function)
			const numericPoseIndex = poseIndex === '' ? '' : parseInt(poseIndex);
			applyPose(selectedPart, numericPoseIndex, mirror);
			// Auto-save after pose change
			saveCharactersToShared();
		}

		function togglePartMirror() {
			if (!selectedPart) return;
			
			const poseIndex = document.getElementById('partPoseSelect').value;
			const mirror = document.getElementById('partMirrorPose').checked;
			
			// Save mirror state
			selectedPart.setAttribute('data-mirror', mirror.toString());
			
			// Reapply current pose with new mirror setting (convert to number)
			const numericPoseIndex = poseIndex === '' ? '' : parseInt(poseIndex);
			applyPose(selectedPart, numericPoseIndex, mirror);
			// Auto-save after mirror change
			saveCharactersToShared();
		}		
		
		function openPosePicker(btn) {
    currentPosePart = btn.closest('.part');
    
    const modal = document.getElementById('posePickerModal');
    const picker = modal.querySelector('.pose-picker');
    
    // Populate pose grid
    populatePoseGrid();
    
    // Set current mirror state
    const currentMirror = currentPosePart.getAttribute('data-mirror') === 'true';
    document.getElementById('posePickerMirror').checked = currentMirror;
    
    // Show modal
    const btnRect = btn.getBoundingClientRect();
    modal.classList.add('show');
    
    // Position picker
    picker.style.position = 'absolute';
    picker.style.left = (btnRect.right + 10) + 'px';
    picker.style.top = (btnRect.top - 20) + 'px';
    
    // Adjust if goes off screen
    const pickerRect = picker.getBoundingClientRect();
    if (pickerRect.right > window.innerWidth) {
        picker.style.left = (btnRect.left - pickerRect.width - 10) + 'px';
    }
    if (pickerRect.bottom > window.innerHeight) {
        picker.style.top = (btnRect.bottom - pickerRect.height - 10) + 'px';
    }
}

function populatePoseGrid() {
    const grid = document.getElementById('poseGrid');
    grid.innerHTML = '';
    const currentPose = currentPosePart.getAttribute('data-pose') || '';
    const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
    // Add all poses from library (including "standard")
    poseLibrary.forEach((pose, index) => {
        const btn = document.createElement('button');
        btn.className = 'pose-button';
        btn.textContent = pose.name;
        btn.onclick = () => selectPose(index);
        
        // Check if this is the current active pose
        if (currentPose === index.toString() || (currentPose === '' && index === standardIndex)) {
            btn.classList.add('active');
        }
        
        grid.appendChild(btn);
    });
}

function selectPose(poseIndex) {
    if (!currentPosePart) return;
    
    const mirror = document.getElementById('posePickerMirror').checked;
    
    // Map empty selection to standard index if available
    if (poseIndex === '') {
        const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
        if (standardIndex !== -1) {
            poseIndex = standardIndex;
        }
    }

    // Save pose data
    currentPosePart.setAttribute('data-pose', poseIndex);
    currentPosePart.setAttribute('data-mirror', mirror.toString());
    
    // Apply pose
    applyPose(currentPosePart, poseIndex, mirror);
    
    // Update active button
    populatePoseGrid();
    // Auto-save after pose change (picker)
    saveCharactersToShared();
}

function togglePosePickerMirror() {
    if (!currentPosePart) return;
    
    let poseIndex = currentPosePart.getAttribute('data-pose') || '';
    const mirror = document.getElementById('posePickerMirror').checked;
    
    // Save mirror state
    currentPosePart.setAttribute('data-mirror', mirror.toString());
    
    // Reapply pose with new mirror setting
    if (poseIndex === '') {
        const standardIndex = poseLibrary.findIndex(p => p && p.name === 'standard');
        if (standardIndex !== -1) {
            poseIndex = standardIndex;
        }
    }
    applyPose(currentPosePart, poseIndex, mirror);
    // Auto-save after mirror change (picker)
    saveCharactersToShared();
}

function closePosePicker() {
    document.getElementById('posePickerModal').classList.remove('show');
    currentPosePart = null;
}
		
        
        function initializePartForAllBackgrounds(part, startX, startY, startSize = 1) {
			allBackgrounds.forEach(bg => {
				part.setAttribute(`data-x-${bg}`, startX);
				part.setAttribute(`data-y-${bg}`, startY);
				
				if (bg === 'none') {
					part.setAttribute(`data-size-${bg}`, startSize);
				}
				// Lad andre lag have undefined stÃ¸rrelse
				
				part.setAttribute(`data-res1-${bg}`, '');
				part.setAttribute(`data-res2-${bg}`, '');
				part.setAttribute(`data-res3-${bg}`, '');
				});
			}
        
        function savePartPositionForCurrentBackground(part) {
    if (!part) return;
    
    const x = parseInt(part.style.left) || 0;
    const y = parseInt(part.style.top) || 0;
    const currentSize = parseFloat(part.getAttribute(`data-size-${currentBackground}`)) || 1;
    
    part.setAttribute(`data-x-${currentBackground}`, x);
    part.setAttribute(`data-y-${currentBackground}`, y);
    part.setAttribute(`data-size-${currentBackground}`, currentSize);
}

function loadPartPositionForBackground(part, background) {
			const savedX = part.getAttribute(`data-x-${background}`);
			const savedY = part.getAttribute(`data-y-${background}`);
			const savedSize = part.getAttribute(`data-size-${background}`);
			
			// Hvis position eller stÃ¸rrelse mangler, brug "none" som fallback
			if (savedX !== null && savedY !== null && savedSize !== null) {
				// Alt er gemt - brug gemte vÃ¦rdier
				part.style.left = savedX + 'px';
				part.style.top = savedY + 'px';
				part.style.transform = `scale(${parseFloat(savedSize)})`;
			} else {
				// Noget mangler - brug "none" vÃ¦rdier
				const noneX = part.getAttribute(`data-x-none`) || 0;
				const noneY = part.getAttribute(`data-y-none`) || 0;
				const noneSize = parseFloat(part.getAttribute(`data-size-none`)) || 1;
				
				part.style.left = noneX + 'px';
				part.style.top = noneY + 'px';
				part.style.transform = `scale(${noneSize})`;
			}
		}
 // indtast stikord nÃ¥r figuren laves.
 function openKeywordsPopup(part) {
    currentKeywordsPart = part;
    const modal = document.getElementById('keywordsPopupModal');
    const popup = modal.querySelector('.keywords-popup');
    const nameSpan = document.getElementById('keywordsPopupName');
    const partName = part.querySelector('.part-name').textContent;
    
    nameSpan.textContent = partName;
    
    // Clear inputs
    for (let i = 1; i <= 6; i++) {
        document.getElementById(`popupKeyword${i}`).value = '';
    }
    
    modal.classList.add('show');
    
    // Position popup next to the part
    const partRect = part.getBoundingClientRect();
    popup.style.position = 'absolute';
    popup.style.left = (partRect.right + 20) + 'px';
    popup.style.top = (partRect.top) + 'px';
    
    // Adjust if goes off screen
    setTimeout(() => {
        const popupRect = popup.getBoundingClientRect();
        if (popupRect.right > window.innerWidth) {
            popup.style.left = (partRect.left - popupRect.width - 20) + 'px';
        }
        if (popupRect.bottom > window.innerHeight) {
            popup.style.top = (window.innerHeight - popupRect.height - 20) + 'px';
        }
        if (popupRect.top < 0) {
            popup.style.top = '20px';
        }
    }, 10);
    
    // Focus first input
    setTimeout(() => {
        document.getElementById('popupKeyword1').focus();
    }, 100);
}

function closeKeywordsPopup() {
    if (!currentKeywordsPart) return;
    
    // Save keywords to part
    for (let i = 1; i <= 6; i++) {
        const value = document.getElementById(`popupKeyword${i}`).value;
        currentKeywordsPart.setAttribute(`data-keyword${i}`, value);
    }
    
    // Update keywords display
    updatePartKeywords(currentKeywordsPart);
    // Auto-save after keywords popup close
    saveCharactersToShared();
    
    // If this part is selected, update the bottom inputs too
    if (selectedPart === currentKeywordsPart) {
        for (let i = 1; i <= 6; i++) {
            const value = currentKeywordsPart.getAttribute(`data-keyword${i}`) || '';
            document.getElementById(`keyword${i}`).value = value;
        }
    }
    
    // Close modal
    document.getElementById('keywordsPopupModal').classList.remove('show');
    currentKeywordsPart = null;
}
       
        
        // Color picker functions
        function hslToHex(h,s,l){
            s /= 100; l /= 100;
            const k = n => (n + h/30) % 12;
            const a = s * Math.min(l, 1 - l);
            const f = n => {
                const color = l - a * Math.max(Math.min(k(n) - 3, 9 - k(n), 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }
        
        function darkenColor(hex, percent) {
            const num = parseInt(hex.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) - amt;
            const G = (num >> 8 & 0x00FF) - amt;
            const B = (num & 0x0000FF) - amt;
            return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
        }
        
        function openColorPicker(btn) {
            const isGroupBtn = btn.classList.contains('group-color-btn');

            if (isGroupBtn) {
                currentGroupBtn = btn;
                currentPart = null;
            } else {
                currentPart = btn.closest('.part');
                currentGroupBtn = null;
            }
            
            const modal = document.getElementById('colorPickerModal');
            const picker = modal.querySelector('.picker');

            // Beregn position ved siden af knappen
            const btnRect = btn.getBoundingClientRect();

            // Vis modal fÃ¸rst sÃ¥ vi kan beregne picker stÃ¸rrelse
            modal.classList.add('show');

            // Positioner picker ved siden af knappen
            picker.style.position = 'absolute';
            picker.style.left = (btnRect.right + 10) + 'px';
            picker.style.top = (btnRect.top - 20) + 'px';

            // SÃ¸rg for at picker ikke gÃ¥r uden for skÃ¦rmen
            const pickerRect = picker.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (pickerRect.right > viewportWidth) {
                picker.style.left = (btnRect.left - pickerRect.width - 10) + 'px';
            }
            if (pickerRect.bottom > viewportHeight) {
                picker.style.top = (btnRect.bottom - pickerRect.height - 10) + 'px';
            }
        }
        
        function closeColorPicker() {
            document.getElementById('colorPickerModal').classList.remove('show');
            currentPart = null;
        }
        
        function selectColor(hex) {
        if (currentPart) {
			// ErklÃ¦r alle variabler fÃ¸rst
			const head = currentPart.querySelector('.head');
			const torso = currentPart.querySelector('.torso');
			const armParts = currentPart.querySelectorAll('.arm_geo_left, .arm_geo_right, .albue_geo_left, .albue_geo_right');
			const legParts = currentPart.querySelectorAll('.laar_geo_left, .laar_geo_right, .skinneben_geo_left, .skinneben_geo_right');
			
			// Funktion til at gÃ¸re farver mÃ¸rkere
			function darkenColor(color, factor) {
				const r = parseInt(color.slice(1, 3), 16);
				const g = parseInt(color.slice(3, 5), 16);
				const b = parseInt(color.slice(5, 7), 16);
				
				if (factor === 20) {
					// For border - gÃ¸r mÃ¸rkere med procent
					const amt = Math.round(2.55 * factor);
					const newR = Math.max(0, r - amt);
					const newG = Math.max(0, g - amt);
					const newB = Math.max(0, b - amt);
					return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
				} else {
					// For body parts - multiplicer med factor
					const newR = Math.round(r * factor);
					const newG = Math.round(g * factor);
					const newB = Math.round(b * factor);
					return `rgb(${newR}, ${newG}, ${newB})`;
				}
			}
			
			const borderColor = darkenColor(hex, 20);
			const darkerColor = darkenColor(hex, 0.92);
			
			// SÃ¦t farver pÃ¥ head
						if (head) {
				head.style.backgroundColor = hex;
			}
			
			// SÃ¦t farver pÃ¥ body parts
			if (torso) torso.style.background = hex;
			armParts.forEach(arm => arm.style.background = darkerColor);
			legParts.forEach(leg => leg.style.background = darkerColor);
			
            currentPart.setAttribute('data-custom-color', hex);
            currentPart.setAttribute('data-custom-border', borderColor);

            // Persist new color to shared storage
            try { saveCharactersToShared(); } catch(_) {}
		} else if (currentGroupBtn) {
			currentGroupBtn.style.backgroundColor = hex;
			currentGroupBtn.setAttribute('data-custom-color', hex);
			
			// Find alle cirkler i denne gruppe og opdater deres border
			const groupNumber = currentGroupBtn.id.match(/\d+/)[0];
			const groupName = document.getElementById(`group${groupNumber}`).value.trim();
			
			if (groupName) {
				document.querySelectorAll('.part').forEach(part => {
					if (part.getAttribute('data-group') === groupName) {
						const head = part.querySelector('.head');
						if (head) {
							head.style.border = `4px solid ${hex}`;
						}
					}
				});
			}
		}
		
		
		setTimeout(() => {
			closeColorPicker();
		}, 100);
	}

        function changeColor(btn) {
            try {
                openColorPicker(btn);
            } catch (error) {
                console.error('Fejl i changeColor:', error);
            }
        }
		
		
		// preset parsers isedet for at lÃ¦se fra fil lÃ¦ses fra defaults
		// Funktion til at parse grupper fra linjer
			function parseGroupsFromLines(lines) {
				for (let line of lines) {
					if (line.trim() === '' || !line.startsWith('Gruppe')) continue;
					
					const parts = line.split(';');
					if (parts.length >= 3) {
						const groupNumber = parts[0].replace('Gruppe', '');
						const groupName = parts[1] || '';
						const groupColor = parts[2] || '';
						
						const groupInput = document.getElementById(`group${groupNumber}`);
						if (groupInput) {
							groupInput.value = groupName;
						}
						
						const colorBtn = document.getElementById(`groupColor${groupNumber}`);
						if (colorBtn && groupColor) {
							colorBtn.style.backgroundColor = groupColor;
							colorBtn.setAttribute('data-custom-color', groupColor);
							colorBtn.removeAttribute('data-color-index');
						}
					}
				}
			}
		
		// Funktion til at parse labels fra linjer
			function parseLabelsFromLines(lines) {
				let inLabelSection = false;
				for (let line of lines) {
					const trimmedLine = line.trim();
					
					if (trimmedLine === '# Alle Baggrund Labels') {
						inLabelSection = true;
						continue;
					}
					
					if (inLabelSection && (trimmedLine === '' || trimmedLine.startsWith('#'))) {
						break;
					}
					
					if (inLabelSection && trimmedLine !== '') {
						const parts = line.split(';');
						if (parts.length >= 3) {
							const bg = parts[0];
							const key = parts[1];
							const value = parts[2] || '';
							
							if (!backgroundLabels[bg]) {
								backgroundLabels[bg] = { ...defaultLabels[bg] };
							}
							
							backgroundLabels[bg][key] = value;
						}
					}
				}
			}

			// Funktion til at indlÃ¦se preset
			function loadPreset(presetName) {
				if (!presets[presetName]) {
					alert('Preset ikke fundet!');
					return;
				}
				
				try {
					const lines = presets[presetName].split('\n');
					
					// Parse grupper og labels
					parseGroupsFromLines(lines);
					parseLabelsFromLines(lines);
					
					// Opdater labels for nuvÃ¦rende baggrund
					renderLabels();
					
					alert(`Preset "${presetName}" indlÃ¦st!`);
					
				} catch (error) {
					console.error('Fejl ved indlÃ¦sning af preset:', error);
					alert('Der opstod en fejl ved indlÃ¦sning af preset.');
				}
			}
		
		
			// Funktion til at hÃ¥ndtere tema-Ã¦ndring
			function changeTheme() {
				const select = document.getElementById('themeSelect');
				const selectedTheme = select.value;
				
				if (selectedTheme && selectedTheme !== '') {
					loadPreset(selectedTheme);
					// Reset dropdown til neutral position
					select.value = '';
				}
			}		
		
        
        // Background functions
        function changeBackground() {
            const select = document.getElementById('backgroundSelect');
            const newBackground = select.value;
            
            // Flyt alle cirkler til deres gemte positioner for den nye baggrund
            const parts = document.querySelectorAll('.part');
            parts.forEach(part => {
                loadPartPositionForBackground(part, newBackground);
            });
            
            // Opdater current background
            currentBackground = newBackground;
            
            if (!backgroundLabels[currentBackground]) {
                backgroundLabels[currentBackground] = { ...defaultLabels[currentBackground] };
            }
            
            renderBackground();
            renderLabels();
            saveCurrentOpstillingToStorage();
        }
        
        function renderBackground() {
            const layer = document.getElementById('backgroundLayer');
            layer.innerHTML = '';
            
            if (currentBackground === 'none') return;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.style.width = '100%';
            svg.style.height = '100%';
            
            if (currentBackground === 'har_onsker') {
                // Stiplede linjer for Har/Ã¸nsker
                const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                vLine.setAttribute('x1', '50%');
                vLine.setAttribute('y1', '0%');
                vLine.setAttribute('x2', '50%');
                vLine.setAttribute('y2', '100%');
                vLine.setAttribute('stroke', '#94a3b8');
                vLine.setAttribute('stroke-width', '2');
                vLine.setAttribute('stroke-dasharray', '5,5');
                svg.appendChild(vLine);
                
                const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hLine.setAttribute('x1', '0%');
                hLine.setAttribute('y1', '50%');
                hLine.setAttribute('x2', '100%');
                hLine.setAttribute('y2', '50%');
                hLine.setAttribute('stroke', '#94a3b8');
                hLine.setAttribute('stroke-width', '2');
                hLine.setAttribute('stroke-dasharray', '5,5');
                svg.appendChild(hLine);
            }
            else if (currentBackground === 'xy_axes') {
                // X/Y akser
                const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                xAxis.setAttribute('x1', '10%');
                xAxis.setAttribute('y1', '90%');
                xAxis.setAttribute('x2', '90%');
                xAxis.setAttribute('y2', '90%');
                xAxis.setAttribute('stroke', '#475569');
                xAxis.setAttribute('stroke-width', '3');
                svg.appendChild(xAxis);
                
                const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                yAxis.setAttribute('x1', '10%');
                yAxis.setAttribute('y1', '10%');
                yAxis.setAttribute('x2', '10%');
                yAxis.setAttribute('y2', '90%');
                yAxis.setAttribute('stroke', '#475569');
                yAxis.setAttribute('stroke-width', '3');
                svg.appendChild(yAxis);
            }
            else if (currentBackground === 'timeline') {
                // Tidslinje i bunden
                const timeline = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                timeline.setAttribute('x1', '10%');
                timeline.setAttribute('y1', '90%');
                timeline.setAttribute('x2', '90%');
                timeline.setAttribute('y2', '90%');
                timeline.setAttribute('stroke', '#475569');
                timeline.setAttribute('stroke-width', '4');
                svg.appendChild(timeline);
                
                // 5 markeringer
                for (let i = 20; i <= 80; i += 15) {
                    const mark = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    mark.setAttribute('x1', `${i}%`);
                    mark.setAttribute('y1', '85%');
                    mark.setAttribute('x2', `${i}%`);
                    mark.setAttribute('y2', '95%');
                    mark.setAttribute('stroke', '#475569');
                    mark.setAttribute('stroke-width', '2');
                    svg.appendChild(mark);
                }
            }
            else if (currentBackground === 'for_imod') {
                // Stiplet midterlinje
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', '50%');
                line.setAttribute('y1', '0%');
                line.setAttribute('x2', '50%');
                line.setAttribute('y2', '100%');
                line.setAttribute('stroke', '#94a3b8');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('stroke-dasharray', '5,5');
                svg.appendChild(line);
            } else if (currentBackground === 'drama_trekant') {
                // Trekant med tre linjer
                const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line1.setAttribute('x1', '50%');
                line1.setAttribute('y1', '15%');
                line1.setAttribute('x2', '20%');
                line1.setAttribute('y2', '80%');
                line1.setAttribute('stroke', '#475569');
                line1.setAttribute('stroke-width', '3');
                svg.appendChild(line1);
                
                const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line2.setAttribute('x1', '50%');
                line2.setAttribute('y1', '15%');
                line2.setAttribute('x2', '80%');
                line2.setAttribute('y2', '80%');
                line2.setAttribute('stroke', '#475569');
                line2.setAttribute('stroke-width', '3');
                svg.appendChild(line2);
                
                const line3 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line3.setAttribute('x1', '20%');
                line3.setAttribute('y1', '80%');
                line3.setAttribute('x2', '80%');
                line3.setAttribute('y2', '80%');
                line3.setAttribute('stroke', '#475569');
                line3.setAttribute('stroke-width', '3');
                svg.appendChild(line3);
            }else if (currentBackground === 'mandala') {
			// Mandala med 4 koncentriske cirkler
			const centerX = 50, centerY = 50, maxRadius = 40;
			
			for (let i = 1; i <= 4; i++) {
				const radius = (maxRadius / 4) * i;
				const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
				circle.setAttribute('cx', `${centerX}%`);
				circle.setAttribute('cy', `${centerY}%`);
				circle.setAttribute('r', `${radius}%`);
				circle.setAttribute('fill', 'none');
				circle.setAttribute('stroke', '#94a3b8');
				circle.setAttribute('stroke-width', '1.5');
				circle.setAttribute('opacity', '0.6');
				svg.appendChild(circle);
			}
		}
            
            layer.appendChild(svg);
        }
        
        function renderLabels() {
            const container = document.getElementById('backgroundLabels');
            container.innerHTML = '';
            
            if (currentBackground === 'none') return;
            
            const labels = backgroundLabels[currentBackground];
            if (!labels) return;
            
            if (currentBackground === 'har_onsker') {
                createLabel(container, 'topLeft', labels.topLeft, '25%', '10%');
                createLabel(container, 'topRight', labels.topRight, '75%', '10%');
                createLabel(container, 'bottomLeft', labels.bottomLeft, '25%', '90%');
                createLabel(container, 'bottomRight', labels.bottomRight, '75%', '90%');
            }
            else if (currentBackground === 'xy_axes') {
                createLabel(container, 'xLabel', labels.xLabel, '50%', '95%');
                createLabel(container, 'yLabel', labels.yLabel, '5%', '50%');
            }
            else if (currentBackground === 'timeline') {
                createLabel(container, 'title', labels.title, '50%', '95%');
                createLabel(container, 'start', labels.start, '15%', '95%');
                createLabel(container, 'end', labels.end, '85%', '95%');
            }
            else if (currentBackground === 'for_imod') {
                createLabel(container, 'left', labels.left, '25%', '10%');
                createLabel(container, 'right', labels.right, '75%', '10%');
            } 
            else if (currentBackground === 'drama_trekant') {
                createLabel(container, 'offer', labels.offer, '50%', '10%');
                createLabel(container, 'hjaelper', labels.hjaelper, '15%', '85%');
                createLabel(container, 'boeddel', labels.boeddel, '85%', '85%');
            }else if (currentBackground === 'mandala') 
			{
				createLabel(container, 'kerne', labels.kerne, '61%', '32%');
				createLabel(container, 'primaer', labels.primaer, '69%', '24%');
				createLabel(container, 'sekundaer', labels.sekundaer, '77%', '16%');
				createLabel(container, 'periferi', labels.periferi, '85%', '8%');
}
        }
        
        function createLabel(container, key, text, left, top) {
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'label-input';
            input.value = text;
            input.style.left = left;
            input.style.top = top;
            
            input.addEventListener('change', function() {
                backgroundLabels[currentBackground][key] = this.value;
                saveCurrentOpstillingToStorage();
            });
            
            container.appendChild(input);
        }
        
        // Part management functions (updated for multi-background)
        function selectPart(e) {
            try {
                if (e.target.classList.contains('control-btn')) return;
                const clickedPart = e.currentTarget;
                
                if (selectedPart === clickedPart) {
					selectedPart.classList.remove('selected');
					selectedPart = null;
					updateGroupsDisplay();

					const titleElement = document.getElementById('profileTitle');
					if (titleElement) titleElement.textContent = '';

					document.getElementById('notesContainerTitle').textContent = 'Noter til opstilling';

					const notesEl = document.getElementById('partNotes');
					notesEl.value = generalNotes;
					notesEl.placeholder = 'Generelle noter til hele opstillingen...';
                    for (let i = 1; i <= 6; i++) {
                        document.getElementById(`keyword${i}`).value = '';
                    }
                    return;
                }
                
                if (selectedPart) {
                    selectedPart.classList.remove('selected');
                }
                
                selectedPart = e.currentTarget;
				selectedPart.classList.add('selected');

				const name = selectedPart.querySelector('.part-name').textContent;
				const notes = selectedPart.getAttribute('data-notes') || '';

				document.getElementById('notesContainerTitle').textContent = `Noter til ${name}`;
				document.getElementById('partNotes').value = notes;
				document.getElementById('partNotes').placeholder = `Detaljerede noter til "${name}"`;
                
                for (let i = 1; i <= 6; i++) {
                    const keyword = selectedPart.getAttribute(`data-keyword${i}`) || '';
                    document.getElementById(`keyword${i}`).value = keyword;
                }
                
                updateGroupsDisplay();
            } catch (error) {
                console.error('Fejl i selectPart:', error);
            }
        }
        
        function changeGroupColor(groupNumber) {
            const colorBtn = document.getElementById(`groupColor${groupNumber}`);
            openColorPicker(colorBtn);
        }
        
       function handleGroupSelection(selectElement) {
			if (selectedPart) {
				selectedPart.setAttribute('data-group', selectElement.value);
				
				if (selectElement.value) {
					for (let i = 1; i <= 6; i++) {
						const groupInput = document.getElementById(`group${i}`);
						if (groupInput && groupInput.value.trim() === selectElement.value) {
							const colorBtn = document.getElementById(`groupColor${i}`);
							// Brug den faktiske farve fra knappen i stedet for index
							const groupColor = colorBtn.getAttribute('data-custom-color') || colorBtn.style.backgroundColor;
							const head = selectedPart.querySelector('.head');
							if (head) {
								head.style.border = `4px solid ${groupColor}`;
							}
							break;
						}
					}
				} else {
					const head = selectedPart.querySelector('.head');
					if (head) {
						head.style.border = '';
					}
				}
			}
		}
        
        function updateGroupDropdown() {
            const dropdown = document.getElementById('partGroupSelect');
            dropdown.innerHTML = '<option value="">VÃ¦lg gruppe...</option>';
            
            for (let i = 1; i <= 6; i++) {
                const groupInput = document.getElementById(`group${i}`);
                const groupName = groupInput.value.trim();
                if (groupName) {
                    const option = document.createElement('option');
                    option.value = groupName;
                    option.textContent = groupName;
                    dropdown.appendChild(option);
                }
            }
        }
        
        function updateGroupsDisplay() {
			const groupFields = document.getElementById('groupFields');
			const groupDropdown = document.getElementById('groupDropdown');
			const poseControls = document.getElementById('poseControls');
			const keywordsSection = document.querySelector('.keywords-section');
			
			if (selectedPart) {
				groupFields.style.display = 'none';
				groupDropdown.style.display = 'block';
				poseControls.style.display = 'block';
				keywordsSection.style.display = 'block';
				
				updateGroupDropdown();
				updatePoseDropdown();
				
				const currentGroup = selectedPart.getAttribute('data-group') || '';
				document.getElementById('partGroupSelect').value = currentGroup;
				
				// Update pose controls
				const currentPose = selectedPart.getAttribute('data-pose') || '';
				const currentMirror = selectedPart.getAttribute('data-mirror') === 'true';
				document.getElementById('partPoseSelect').value = currentPose;
				document.getElementById('partMirrorPose').checked = currentMirror;
				
				// Ensure the visual state matches the saved state
				// If there's a pose, reapply it to ensure consistency
				if (currentPose !== '') {
					const poseIndex = parseInt(currentPose);
					if (!isNaN(poseIndex) && poseLibrary[poseIndex]) {
						applyPose(selectedPart, poseIndex, currentMirror);
					}
				}
				
			} else {
				groupFields.style.display = 'block';
				groupDropdown.style.display = 'none';
				poseControls.style.display = 'none';
				keywordsSection.style.display = 'none';
			}
		}
        
        function updatePartKeywords(part) {
            const keywordsAbove = part.querySelector('.keywords-above');
            const keywordsBelow = part.querySelector('.keywords-below');
            
            const above = [];
            for (let i = 1; i <= 3; i++) {
                const keyword = part.getAttribute(`data-keyword${i}`);
                if (keyword && keyword.trim()) {
                    above.push(keyword.trim());
                }
            }
            
            const below = [];
            for (let i = 4; i <= 6; i++) {
                const keyword = part.getAttribute(`data-keyword${i}`);
                if (keyword && keyword.trim()) {
                    below.push(keyword.trim());
                }
            }
            
            keywordsAbove.innerHTML = above.join('<br>');
            keywordsBelow.innerHTML = below.join('<br>');
            
            const keywordsVisible = document.getElementById('keywordsVisible').checked;
            if (!keywordsVisible) {
                keywordsAbove.style.display = 'none';
                keywordsBelow.style.display = 'none';
            } else {
                keywordsAbove.style.display = 'block';
                keywordsBelow.style.display = 'block';
            }
        }
        
        function addPart(name = null, x = null, y = null, skipPopup = false) {
            try {
                const partName = name || document.getElementById('partName').value.trim();
                if (!partName) {
                    const commonParts = [
                        "Det SÃ¥rede Barn", "Beskytteren", "Den Kritiske", "Den Perfektionistiske", 
                        "Den Bekymrede", "Den Vrede", "Den Glade", "Den Kreative", 
                        "Manager-delen", "Firewall-delen", "Det Elskede Barn", "Den Ansvarlige"
                    ];
                    const suggestion = commonParts[Math.floor(Math.random() * commonParts.length)];
                    document.getElementById('partName').placeholder = `PrÃ¸v f.eks: ${suggestion}`;
                    return;
                }
                
                const workspace = document.getElementById('workspace');
                const part = document.createElement('div');
                part.className = 'part';
                partCounter++;
                
                const posX = x !== null ? x : Math.random() * (workspace.offsetWidth - 120);
                const posY = y !== null ? y : Math.random() * (workspace.offsetHeight - 120);
                
                part.style.left = posX + 'px';
                part.style.top = posY + 'px';
                
                const existingParts = document.querySelectorAll('.part');
                // Find max current layer to avoid duplicates if there are gaps or collisions
                let maxLayer = 0;
                existingParts.forEach(p => {
                    const l = parseInt(p.getAttribute('data-layer')) || 0;
                    if (l > maxLayer) maxLayer = l;
                });
                const newLayer = maxLayer + 1;
                part.style.zIndex = newLayer + 10;
                
                const assignedColor = partColors[colorIndex % partColors.length];
				const borderColor = borderColors[colorIndex % borderColors.length];

				
                
                part.setAttribute('data-color-index', colorIndex.toString());
                part.setAttribute('data-notes', '');
                part.setAttribute('data-layer', newLayer.toString());
                part.setAttribute('data-group', '');
				part.setAttribute('data-part-scale', '1');
                part.setAttribute('data-keyword1', '');
                part.setAttribute('data-keyword2', '');
                part.setAttribute('data-keyword3', '');
                part.setAttribute('data-keyword4', '');
                part.setAttribute('data-keyword5', '');
                part.setAttribute('data-keyword6', '');
                part.setAttribute('data-custom-color', assignedColor);
                part.setAttribute('data-custom-border', borderColor);
                
                // Initialize multi-background data
                initializePartForAllBackgrounds(part, posX, posY, 1);
                
                colorIndex++;
                
                part.innerHTML = `
                    <div class="keywords-above part-keywords"></div>
						<div class="keywords-below part-keywords"></div>
						
						<div class="body">
							<div class="head">
								<span class="part-name">${partName}</span>
							</div>
							<div class="torso"></div>
							
							<!-- Venstre arm hierarki -->
							<div class="skulder_translate_left">
								<div class="skulder_rotate_left">
									<div class="arm_geo_left">
										<div class="albue_rotate_left">
											<div class="albue_geo_left"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- HÃ¸jre arm hierarki -->
							<div class="skulder_translate_right">
								<div class="skulder_rotate_right">
									<div class="arm_geo_right">
										<div class="albue_rotate_right">
											<div class="albue_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Venstre ben hierarki -->
							<div class="hofte_translate_left">
								<div class="hofte_rotate_left">
									<div class="laar_geo_left">
										<div class="knae_rotate_left">
											<div class="skinneben_geo_left"></div>
										</div>
									</div>
								</div>
							</div>

							<!-- HÃ¸jre ben hierarki -->
							<div class="hofte_translate_right">
								<div class="hofte_rotate_right">
									<div class="laar_geo_right">
										<div class="knae_rotate_right">
											<div class="skinneben_geo_right"></div>
										</div>
									</div>
								</div>
							</div>
						</div>
					
					<button class="control-btn delete-btn" title="Slet del">Ã</button>
                    
                    <button class="control-btn layer-up" title="Bring frem">â</button>
                    <button class="control-btn layer-down" title="Send bagud">â</button>
                    <button class="control-btn size-plus" title="GÃ¸r stÃ¸rre">+</button>
                    <button class="control-btn size-minus" title="GÃ¸r mindre">â</button>
                    <button class="control-btn color-btn" title="Skift farve">C</button>
					<button class="control-btn pose-btn" title="Skift pose">P</button>
                `;
				
				// GÃ¸r navn direkte redigerbart
				const nameSpan = part.querySelector('.part-name');
				nameSpan.style.cursor = 'pointer';
				nameSpan.addEventListener('click', function(e) {
					e.stopPropagation();
					editName(this);
				});
				
				// Set colors on body parts
				const head = part.querySelector('.head');
				const torso = part.querySelector('.torso');
				const armParts = part.querySelectorAll('.arm_geo_left, .arm_geo_right, .albue_geo_left, .albue_geo_right');
				const legParts = part.querySelectorAll('.laar_geo_left, .laar_geo_right, .skinneben_geo_left, .skinneben_geo_right');

				// Funktion til at gÃ¸re farver mÃ¸rkere
				function darkenColor(hex, factor = 0.92) {
					const r = parseInt(hex.slice(1, 3), 16);
					const g = parseInt(hex.slice(3, 5), 16);
					const b = parseInt(hex.slice(5, 7), 16);
					
					const newR = Math.round(r * factor);
					const newG = Math.round(g * factor);
					const newB = Math.round(b * factor);
					
					return `rgb(${newR}, ${newG}, ${newB})`;
				}

				const darkerColor = darkenColor(assignedColor, 0.92);

				if (head) {
					head.style.background = assignedColor;
					//head.style.border = `4px solid ${borderColor}`; -ingen border
				}
				if (torso) torso.style.background = assignedColor;
				armParts.forEach(arm => arm.style.background = darkerColor);
				legParts.forEach(leg => leg.style.background = darkerColor);
                
                part.addEventListener('pointerdown', startDrag);
                part.addEventListener('click', selectPart);
                part.addEventListener('dragstart', (e) => e.preventDefault());
                
                const deleteBtn = part.querySelector('.delete-btn');
                
                const layerUpBtn = part.querySelector('.layer-up');
                const layerDownBtn = part.querySelector('.layer-down');
                const sizePlusBtn = part.querySelector('.size-plus');
                const sizeMinusBtn = part.querySelector('.size-minus');
                const colorBtn = part.querySelector('.color-btn');
				const poseBtn = part.querySelector('.pose-btn');
                
                deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deletePart(deleteBtn); });
                
                layerUpBtn.addEventListener('click', (e) => { e.stopPropagation(); moveToFront(layerUpBtn); });
                layerDownBtn.addEventListener('click', (e) => { e.stopPropagation(); moveToBack(layerDownBtn); });
                sizePlusBtn.addEventListener('click', (e) => { e.stopPropagation(); increaseSize(sizePlusBtn); });
                sizeMinusBtn.addEventListener('click', (e) => { e.stopPropagation(); decreaseSize(sizeMinusBtn); });
                colorBtn.addEventListener('click', (e) => { e.stopPropagation(); changeColor(colorBtn); });
                poseBtn.addEventListener('click', (e) => { e.stopPropagation(); openPosePicker(poseBtn); });
				
                workspace.appendChild(part);
				resetPose(part);
				
				// Update shared data
				saveCharactersToShared();
				
				// Open keywords popup for new part (unless loading from file)
				if (!skipPopup) {
					openKeywordsPopup(part);
				}


                
                document.getElementById('partName').value = '';
                document.getElementById('partName').placeholder = "Navn pÃ¥ del (f.eks. Beskytteren, Den Kritiske, Det SÃ¥rede Barn...)";
                
            } catch (error) {
                console.error('Fejl i addPart:', error);
            }
        }
        
        function deletePart(btn) {
            try {
                const part = btn.closest('.part');
                const deletedLayer = parseInt(part.getAttribute('data-layer')) || 1;
                part.remove();
                
                if (selectedPart === part) {
					selectedPart = null;
					updateGroupsDisplay();
					document.getElementById('notesContainerTitle').textContent = 'Noter til opstilling';
					document.getElementById('partNotes').value = '';
					document.getElementById('partNotes').placeholder = 'Generelle noter til hele opstillingen...';
					for (let i = 1; i <= 6; i++) {
						document.getElementById(`keyword${i}`).value = '';
					}
				}
                
                const allParts = document.querySelectorAll('.part');
                allParts.forEach(p => {
                    const currentLayer = parseInt(p.getAttribute('data-layer')) || 1;
                    if (currentLayer > deletedLayer) {
                        const newLayer = currentLayer - 1;
                        p.setAttribute('data-layer', newLayer.toString());
                        p.style.zIndex = newLayer + 10;
                    }
                });
                // Ensure layers are unique and compact after delete
                normalizeLayers();
                // Auto-save after delete
                saveCharactersToShared();
                
            } catch (error) {
                console.error('Fejl i deletePart:', error);
            }
        }
        
        function moveToFront(btn) {
            try {
                const part = btn.closest('.part');
                const currentLayer = parseInt(part.getAttribute('data-layer')) || 1;
                const allParts = document.querySelectorAll('.part');
                const maxLayer = allParts.length;
                const targetLayer = currentLayer + 1;
                
                if (targetLayer > maxLayer) return;
                
                let targetPart = null;
                allParts.forEach(p => {
                    if (parseInt(p.getAttribute('data-layer')) === targetLayer) {
                        targetPart = p;
                    }
                });
                
                // If there is a gap or duplicate layers, normalize and retry
                if (!targetPart) {
                    normalizeLayers();
                    const refreshedParts = document.querySelectorAll('.part');
                    refreshedParts.forEach(p => {
                        if (parseInt(p.getAttribute('data-layer')) === currentLayer + 1) {
                            targetPart = p;
                        }
                    });
                }

                if (targetPart) {
                    part.setAttribute('data-layer', targetLayer.toString());
                    part.style.zIndex = targetLayer + 10;
                    targetPart.setAttribute('data-layer', currentLayer.toString());
                    targetPart.style.zIndex = currentLayer + 10;
                }
                // Auto-save after layer change (front)
                saveCharactersToShared();
            } catch (error) {
                console.error('Fejl i moveToFront:', error);
            }
        }
        
        function moveToBack(btn) {
            try {
                const part = btn.closest('.part');
                const currentLayer = parseInt(part.getAttribute('data-layer')) || 1;
                const targetLayer = currentLayer - 1;
                
                if (targetLayer < 1) return;
                
                const allParts = document.querySelectorAll('.part');
                let targetPart = null;
                allParts.forEach(p => {
                    if (parseInt(p.getAttribute('data-layer')) === targetLayer) {
                        targetPart = p;
                    }
                });
                
                // If there is a gap or duplicate layers, normalize and retry
                if (!targetPart) {
                    normalizeLayers();
                    const refreshedParts = document.querySelectorAll('.part');
                    refreshedParts.forEach(p => {
                        if (parseInt(p.getAttribute('data-layer')) === targetLayer) {
                            targetPart = p;
                        }
                    });
                }

                if (targetPart) {
                    part.setAttribute('data-layer', targetLayer.toString());
                    part.style.zIndex = targetLayer + 10;
                    targetPart.setAttribute('data-layer', currentLayer.toString());
                    targetPart.style.zIndex = currentLayer + 10;
                }
                // Auto-save after layer change (back)
                saveCharactersToShared();
            } catch (error) {
                console.error('Fejl i moveToBack:', error);
            }
        }

        // Ensure unique, compact layers (1..N) with matching z-index
        function normalizeLayers() {
            try {
                const parts = Array.from(document.querySelectorAll('.part'));
                // Sort by current data-layer asc; fall back to DOM order
                parts.sort((a, b) => {
                    const la = parseInt(a.getAttribute('data-layer')) || 0;
                    const lb = parseInt(b.getAttribute('data-layer')) || 0;
                    return la - lb;
                });
                parts.forEach((p, idx) => {
                    const layer = idx + 1;
                    p.setAttribute('data-layer', layer.toString());
                    p.style.zIndex = layer + 10;
                });
            } catch (error) {
                console.error('Fejl i normalizeLayers:', error);
            }
        }
        
		function increaseSize(btn) {
				try {
					const part = btn.closest('.part');
					let currentScale = parseFloat(part.getAttribute(`data-size-${currentBackground}`)) || 1;
					
					let increment = 0.1;
					const newScale = Math.min(3, Math.round((currentScale + increment) * 10) / 10);
					part.style.transform = `scale(${newScale})`;
					part.setAttribute(`data-size-${currentBackground}`, newScale);
					
					// Ensure background data is saved properly
					savePartPositionForCurrentBackground(part);
                    // Auto-save after size increase
                    saveCharactersToShared();
					
				} catch (error) {
					console.error('Fejl i increaseSize:', error);
				}
			}



			function decreaseSize(btn) {
				try {
					const part = btn.closest('.part');
					let currentScale = parseFloat(part.getAttribute(`data-size-${currentBackground}`)) || 1;
					
					let decrement = 0.1;
					const newScale = Math.max(0.45, Math.round((currentScale - decrement) * 10) / 10);
					part.style.transform = `scale(${newScale})`;
					part.setAttribute(`data-size-${currentBackground}`, newScale);
					
					// Ensure background data is saved properly
					savePartPositionForCurrentBackground(part);
                    // Auto-save after size decrease
                    saveCharactersToShared();
					
					} catch (error) {
						console.error('Fejl i decreaseSize:', error);
					}
				}
				
        
        
        function updatePartSize(part, sizeMultiplier) {
			part.style.transform = `scale(${sizeMultiplier})`;
			part.setAttribute(`data-size-${currentBackground}`, sizeMultiplier);
			}
        
        function startDrag(e) {
				try {
					if (e.target.classList.contains('control-btn') || e.target.classList.contains('label-input')) return;
					
					draggedElement = e.target.closest('.part');
					if (!draggedElement) return;
					
					draggedElement.classList.add('dragging');
					
					const rect = draggedElement.getBoundingClientRect();
					offset.x = e.clientX - rect.left;
					offset.y = e.clientY - rect.top;
					
					// Initialize simple drag state
					dragState = {
						lastX: e.clientX,
						lastY: e.clientY,
						velocityX: 0,
						isDragging: true,
						settleTimeout: null,
						currentRotation: 0,
						targetRotation: 0,
						animationId: null
					};
					
					// Start continuous animation loop
					const animate = () => {
						if (dragState && dragState.isDragging) {
							const lerpFactor = 0.3; // How fast to interpolate
							dragState.currentRotation += (dragState.targetRotation - dragState.currentRotation) * lerpFactor;
							
							const body = draggedElement.querySelector('.body');
							if (body) {
								body.style.transform = `translateX(-50%) rotate(${dragState.currentRotation}deg)`;
							}
							
							dragState.animationId = requestAnimationFrame(animate);
						}
					};
					
					dragState.animationId = requestAnimationFrame(animate);
					
                document.addEventListener('pointermove', drag, { passive: false });
                document.addEventListener('pointerup', stopDrag, { passive: false });
				} catch (error) {
					console.error('Fejl i startDrag:', error);
				}
			}
        
        function drag(e) {
            try {
                if (!draggedElement || !dragState) return;
                if (e && typeof e.preventDefault === 'function') e.preventDefault();
                
                const workspace = document.getElementById('workspace');
                const workspaceRect = workspace.getBoundingClientRect();
                
                // Calculate rotation based on movement direction
                const deltaX = e.clientX - dragState.lastX;
                dragState.velocityX = deltaX;
                dragState.lastX = e.clientX;
                dragState.lastY = e.clientY;
                
                // Clear any existing settle timeout
                if (dragState.settleTimeout) {
                    clearTimeout(dragState.settleTimeout);
                    dragState.settleTimeout = null;
                }
                
                // Calculate target rotation based on movement
                if (Math.abs(deltaX) > 0.5) {
                    dragState.targetRotation = deltaX * 1.5; // Sensitivity multiplier
                    dragState.targetRotation = Math.max(-15, Math.min(15, dragState.targetRotation)); // Clamp to Â±15 degrees
                }
                
                // Set timeout to settle back to 0 after 200ms of no movement
                if (Math.abs(deltaX) > 0.5) {
                    dragState.settleTimeout = setTimeout(() => {
                        dragState.targetRotation = 0;
                        // Let the interpolation handle the smooth return
                    }, 200);
                }
                
                let newX = e.clientX - workspaceRect.left - offset.x;
                let newY = e.clientY - workspaceRect.top - offset.y;

                // Fixed-margin clamp based on part's top-left (independent of size)
                const minLeft = 1;   // target approx left edge
                const minTop  = 6;   // target approx top edge
                const rightMargin = 86; // workspace.width - maxLeft (â1600-1514)
                const bottomMargin = 78; // workspace.height - maxTop (â600-522)
                const maxLeft = workspace.offsetWidth - rightMargin;
                const maxTop  = workspace.offsetHeight - bottomMargin;

                newX = Math.max(minLeft, Math.min(newX, maxLeft));
                newY = Math.max(minTop,  Math.min(newY, maxTop));
                
                draggedElement.style.left = newX + 'px';
                draggedElement.style.top = newY + 'px';
            } catch (error) {
                console.error('Fejl i drag:', error);
            }
        }
        
        function stopDrag() {
			try {
				if (draggedElement && dragState) {
					draggedElement.classList.remove('dragging');
					
					// Clear any pending settle timeout
					if (dragState.settleTimeout) {
						clearTimeout(dragState.settleTimeout);
					}
					
					// Stop dragging flag but continue animation
					dragState.isDragging = false;
					dragState.targetRotation = 0;
					
					// Continue settle animation until rotation is back to 0
					const settleAnimation = () => {
						if (dragState && Math.abs(dragState.currentRotation) > 0.1) {
							const lerpFactor = 0.2; // Slower settling
							dragState.currentRotation += (dragState.targetRotation - dragState.currentRotation) * lerpFactor;
							
							const body = draggedElement.querySelector('.body');
							if (body) {
								body.style.transform = `translateX(-50%) rotate(${dragState.currentRotation}deg)`;
							}
							
							dragState.animationId = requestAnimationFrame(settleAnimation);
						} else {
							// Final cleanup when settled
							const body = draggedElement.querySelector('.body');
							if (body) {
								body.style.transform = `translateX(-50%) rotate(0deg)`;
							}
							
							// Save position for current background
							savePartPositionForCurrentBackground(draggedElement);
							// Save shared characters (updates x,y)
							saveCharactersToShared();
							
							draggedElement = null;
							dragState = null;
						}
					};
					
					dragState.animationId = requestAnimationFrame(settleAnimation);
				}
                document.removeEventListener('pointermove', drag);
                document.removeEventListener('pointerup', stopDrag);
			} catch (error) {
				console.error('Fejl i stopDrag:', error);
			}
		}
        
        function loadCurrentOpstillingFromStorage() {
            try {
                const savedOpstilling = localStorage.getItem('current_opstilling');
                if (!savedOpstilling) return false;
                
                // Parse CSV data
                const lines = savedOpstilling.split('\n');
                
                // Clear existing parts but preserve groups
                const workspace = document.getElementById('workspace');
                workspace.innerHTML = `
                    <div class="background-layer" id="backgroundLayer"></div>
                    <div class="background-labels" id="backgroundLabels"></div>
                `;
                selectedPart = null;
                generalNotes = '';
                
                // Clean up drag state
                draggedElement = null;
                dragState = null;
                
                updateGroupsDisplay();
                document.getElementById('partNotes').value = '';
                document.getElementById('partNotes').placeholder = 'Generelle noter for opstillingen. Klik evt pÃ¥ en cirkel for at vÃ¦lge den og redigere dens information...';
                
                for (let i = 1; i <= 6; i++) {
                    document.getElementById(`keyword${i}`).value = '';
                }
                
                // Reset background labels to default
                backgroundLabels = {};
                allBackgrounds.forEach(bg => {
                    if (defaultLabels[bg]) {
                        backgroundLabels[bg] = { ...defaultLabels[bg] };
                    }
                });
                
                renderBackground();
                
                // Reset colorIndex so new parts start fresh with colors
                colorIndex = 0;
                
                renderLabels();
                
                for (let line of lines) {
                    if (line.trim() === '' || line.startsWith('#') || line.includes('Navn;PosX')) continue;
                    
                    const parts = line.split(';');
                    // Check if this line has multi-background data
                    if (parts.length >= 21) {
                        const navn = parts[0];
                        const posX = parseInt(parts[1]) || 0;
                        const posY = parseInt(parts[2]) || 0;
                        const stÃ¸rrelse = parseFloat(parts[3]) || 1;
                        const farveGradient = parts[4];
                        const borderFarve = parts[5];
                        const lag = parseInt(parts[6]) || 1;
                        const noter = parts[7] || '';
                        const gruppe = parts[14] || '';
                        const baggrund = parts[18] || 'none';
						const pose = parts[19] || '';
						const mirror = parts[20] === 'true';
                        
                        let farveIndex = partColors.findIndex(color => 
                            color.toLowerCase() === farveGradient.toLowerCase()
                        );
                        if (farveIndex === -1) farveIndex = 0;
                        
                        // Add part (skip popup when loading from storage)
						addPart(navn, posX, posY, true);
                        
                        const newPart = document.querySelector('.part:last-child');
                        if (newPart) {
                            newPart.setAttribute('data-color-index', farveIndex);
                            newPart.setAttribute('data-layer', lag);
                            newPart.setAttribute('data-notes', noter);
                            newPart.setAttribute('data-group', gruppe);
                            newPart.setAttribute('data-custom-color', farveGradient);
                            newPart.setAttribute('data-custom-border', borderFarve);
							// Set pose data - store index instead of name for consistency
							const poseIndex = poseLibrary.findIndex(p => p.name === pose);
							if (poseIndex !== -1) {
								newPart.setAttribute('data-pose', poseIndex.toString());
							} else {
								newPart.setAttribute('data-pose', '');
							}
							newPart.setAttribute('data-mirror', mirror.toString());

							// Opdater body parts med den korrekte farve
							const head = newPart.querySelector('.head');
							const torso = newPart.querySelector('.torso');
							const armParts = newPart.querySelectorAll('.arm_geo_left, .arm_geo_right, .albue_geo_left, .albue_geo_right');
							const legParts = newPart.querySelectorAll('.laar_geo_left, .laar_geo_right, .skinneben_geo_left, .skinneben_geo_right');

							// Funktion til at gÃ¸re farver mÃ¸rkere
							function darkenColor(hex, factor = 0.92) {
								const r = parseInt(hex.slice(1, 3), 16);
								const g = parseInt(hex.slice(3, 5), 16);
								const b = parseInt(hex.slice(5, 7), 16);
								
								const newR = Math.round(r * factor);
								const newG = Math.round(g * factor);
								const newB = Math.round(b * factor);
								
								return `rgb(${newR}, ${newG}, ${newB})`;
							}

							const darkerColor = darkenColor(farveGradient, 0.92);

							if (head) head.style.background = farveGradient;
							if (torso) torso.style.background = farveGradient;
							armParts.forEach(arm => arm.style.background = darkerColor);
							legParts.forEach(leg => leg.style.background = darkerColor);
                            
                            newPart.style.zIndex = lag + 10;
                            
                            // Set keywords
                            for (let i = 8; i <= 13; i++) {
                                if (parts[i]) {
                                    newPart.setAttribute(`data-keyword${i-7}`, parts[i]);
                                }
                            }
                            
                            // Load multi-background data if available
                            if (parts.length >= 21 + (allBackgrounds.length * 6)) {
                                let bgIndex = 21;
                                allBackgrounds.forEach(bg => {
                                    const bgX = parts[bgIndex] || posX;
                                    const bgY = parts[bgIndex + 1] || posY;
                                    const bgSize = parts[bgIndex + 2] || stÃ¸rrelse;
                                    const bgRes1 = parts[bgIndex + 3] || '';
                                    const bgRes2 = parts[bgIndex + 4] || '';
                                    const bgRes3 = parts[bgIndex + 5] || '';
                                    
                                    newPart.setAttribute(`data-x-${bg}`, bgX);
                                    newPart.setAttribute(`data-y-${bg}`, bgY);
                                    newPart.setAttribute(`data-size-${bg}`, bgSize);
                                    newPart.setAttribute(`data-res1-${bg}`, bgRes1);
                                    newPart.setAttribute(`data-res2-${bg}`, bgRes2);
                                    newPart.setAttribute(`data-res3-${bg}`, bgRes3);
                                    
                                    bgIndex += 6;
                                });
								// Apply current background scale after loading all background data
								const currentScale = parseFloat(newPart.getAttribute(`data-size-${currentBackground}`)) || 1;
								newPart.style.transform = `scale(${currentScale})`;
                            } else {
                                // Initialize with current position for all backgrounds (legacy support)
                                initializePartForAllBackgrounds(newPart, posX, posY, stÃ¸rrelse);
                            }
                            
                            updatePartKeywords(newPart);
							// Apply the pose
							if (pose) {
								// Find pose index by name
								const poseIndex = poseLibrary.findIndex(p => p.name === pose);
								if (poseIndex !== -1) {
									applyPose(newPart, poseIndex, mirror);
								} else {
									resetPose(newPart);
								}
							} else {
								resetPose(newPart);
							}
                        }
                        
                        // Set background if found
                        if (baggrund && baggrund !== 'none') {
                            document.getElementById('backgroundSelect').value = baggrund;
                            currentBackground = baggrund;
                            changeBackground();
                        }
                    }
                }
                
                // IndlÃ¦s gruppenavne og farver
				for (let line of lines) {
					if (line.trim() === '' || !line.startsWith('Gruppe')) continue;
					
					const parts = line.split(';');
					if (parts.length >= 3) {
						const groupNumber = parts[0].replace('Gruppe', '');
						const groupName = parts[1] || '';
						const groupColor = parts[2] || '';
						
						const groupInput = document.getElementById(`group${groupNumber}`);
						if (groupInput) {
							groupInput.value = groupName;
						}
						
						const colorBtn = document.getElementById(`groupColor${groupNumber}`);
						if (colorBtn && groupColor) {
							colorBtn.style.backgroundColor = groupColor;
							colorBtn.setAttribute('data-custom-color', groupColor);
							colorBtn.removeAttribute('data-color-index');
						}
					}
				}
				
				// Apply group borders after group colors are loaded
				document.querySelectorAll('.part').forEach(part => {
					const partGroup = part.getAttribute('data-group');
					if (partGroup) {
						for (let i = 1; i <= 6; i++) {
							const groupInput = document.getElementById(`group${i}`);
							if (groupInput && groupInput.value.trim() === partGroup) {
								const colorBtn = document.getElementById(`groupColor${i}`);
								const groupColor = colorBtn.getAttribute('data-custom-color') || colorBtn.style.backgroundColor;
								const head = part.querySelector('.head');
								if (groupColor && head) {
									head.style.border = `4px solid ${groupColor}`;
								}
								break;
							}
						}
					}
				});
				
				// IndlÃ¦s alle background labels
				let inLabelSection = false;
				for (let line of lines) {
					const trimmedLine = line.trim();
					
					if (trimmedLine === '# Alle Baggrund Labels') {
						inLabelSection = true;
						continue;
					}
					
					if (inLabelSection && (trimmedLine === '' || trimmedLine.startsWith('#'))) {
						break;
					}
					
					if (inLabelSection && trimmedLine !== '') {
						const parts = line.split(';');
						if (parts.length >= 3) {
							const bg = parts[0];
							const key = parts[1];
							const value = parts[2] || '';
							
							if (!backgroundLabels[bg]) {
								backgroundLabels[bg] = { ...defaultLabels[bg] };
							}
							
							backgroundLabels[bg][key] = value;
						}
					}
				}
				
				// IndlÃ¦s generelle noter
				let inNotesSection = false;
				let notesContent = '';
				for (let line of lines) {
					const trimmedLine = line.trim();
					
					if (trimmedLine === '# Generelle Noter') {
						inNotesSection = true;
						continue;
					}
					
					if (inNotesSection) {
						notesContent += line.replace(/\\n/g, '\n') + '\n';
					}
				}
				generalNotes = notesContent.trim();
				document.getElementById('partNotes').value = generalNotes;

				// Opdater labels for nuvÃ¦rende baggrund
				renderLabels();

				document.querySelectorAll('.part').forEach(part => {
					const partGroup = part.getAttribute('data-group');
					if (partGroup) {
						for (let i = 1; i <= 6; i++) {
							const groupInput = document.getElementById(`group${i}`);
							if (groupInput && groupInput.value.trim() === partGroup) {
								const colorBtn = document.getElementById(`groupColor${i}`);
								const groupColor = colorBtn.getAttribute('data-custom-color') || colorBtn.style.backgroundColor;
								if (groupColor) {
								const head = part.querySelector('.head');
								if (head) {
									head.style.border = `4px solid ${groupColor}`;
									}
								}
								break;
							}
						}
					}
				});

                // Ensure layers are consistent after load
                normalizeLayers();
                return true;
            } catch (error) {
                console.error('Fejl ved indlÃ¦sning fra localStorage:', error);
                return false;
            }
        }

        function clearAll() {
            try {
                const workspace = document.getElementById('workspace');
                workspace.innerHTML = `
                    <div class="background-layer" id="backgroundLayer"></div>
                    <div class="background-labels" id="backgroundLabels"></div>
                `;
                selectedPart = null;
				generalNotes = '';
				
				// Clean up drag state
				draggedElement = null;
				dragState = null;
				
                updateGroupsDisplay();
                document.getElementById('partNotes').value = '';
                document.getElementById('partNotes').placeholder = 'Generelle noter for opstillingen. Klik evt pÃ¥ en cirkel for at vÃ¦lge den og redigere dens information...';
                
                for (let i = 1; i <= 6; i++) {
                    document.getElementById(`keyword${i}`).value = '';
                }
				
				// Nulstil alle background labels til default
				backgroundLabels = {};
				allBackgrounds.forEach(bg => {
					if (defaultLabels[bg]) {
						backgroundLabels[bg] = { ...defaultLabels[bg] };
					}
				});
                
                renderBackground();
				
				// Nulstil gruppenavne til default
				const defaultGroupNames = ['Manager', 'Brandmand', 'Eksileret', 'Ekstern', '', ''];
				for (let i = 1; i <= 6; i++) {
					const groupInput = document.getElementById(`group${i}`);
					if (groupInput) {
						groupInput.value = defaultGroupNames[i-1];
					}
					
					// Nulstil gruppe farver til default
					const colorBtn = document.getElementById(`groupColor${i}`);
					if (colorBtn) {
						colorBtn.setAttribute('data-color-index', (i-1).toString());
						colorBtn.style.backgroundColor = groupColors[i-1];
						colorBtn.removeAttribute('data-custom-color');
					}
				}

				// Nulstil colorIndex sÃ¥ nye dele starter forfra med farver
				colorIndex = 0;
				
                renderLabels();
                
                // Clear shared characters in localStorage
                try {
                    localStorage.setItem('relationsSetupData', JSON.stringify({ characters: [], lastUpdated: new Date().toISOString() }));
                    localStorage.removeItem('current_opstilling');
                } catch(_) {}

            } catch (error) {
                console.error('Fejl i clearAll:', error);
            }
        }
        
        function editName(btn) {
            try {
                const part = btn.closest ? btn.closest('.part') : btn.parentElement.closest('.part');
                const nameSpan = part.querySelector('.part-name');
                const currentName = nameSpan.textContent;
                
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentName;
                input.className = 'name-input';
                input.maxLength = 30;
                
                nameSpan.style.display = 'none';
                nameSpan.parentNode.insertBefore(input, nameSpan);
                
                input.focus();
                input.select();
                
                let isFinishing = false;

				function finishEdit() {
					if (isFinishing) return;
					isFinishing = true;
					
					const newName = input.value.trim() || currentName;
					nameSpan.textContent = newName;
					nameSpan.style.display = 'block';
					
					if (input.parentNode) {
						input.remove();
					}
					
					if (selectedPart && selectedPart === part) {
						document.getElementById('partNotes').placeholder = `Detaljerede noter til "${newName}"`;
					}
					// Auto-save after name change
					saveCharactersToShared();
				}
                
                input.addEventListener('blur', finishEdit);
                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        finishEdit();
                    }
                    if (e.key === 'Escape') {
                        nameSpan.style.display = 'block';
                        input.remove();
                    }
                });
            } catch (error) {
                console.error('Fejl i editName:', error);
            }
        }
        
        function saveCurrentOpstillingToStorage() {
            try {
                const parts = document.querySelectorAll('.part');
                
                // Build CSV header with multi-background columns
				let csv = 'Navn;PosX;PosY;StÃ¸rrelse;Farve_Gradient;Border_Farve;Lag;Noter;Stikord1;Stikord2;Stikord3;Stikord4;Stikord5;Stikord6;Gruppe;Form;Kategori;Forbindelser;Baggrund;Pose;Mirror';                
                // Add multi-background columns
                allBackgrounds.forEach(bg => {
                    csv += `;PosX_${bg};PosY_${bg};Size_${bg};Res1_${bg};Res2_${bg};Res3_${bg}`;
                });
                csv += '\n';
                
                parts.forEach(part => {
                    const navn = part.querySelector('.part-name').textContent.replace(/;/g, ',');
                    const posX = parseInt(part.style.left) || 0;
                    const posY = parseInt(part.style.top) || 0;
                    const stÃ¸rrelse = parseFloat(part.getAttribute(`data-size-${currentBackground}`)) || 1;
                    
                    const farveGradient = part.getAttribute('data-custom-color') || 
                                         partColors[parseInt(part.getAttribute('data-color-index')) || 0];
                    const borderFarve = part.getAttribute('data-custom-border') || 
                                       borderColors[parseInt(part.getAttribute('data-color-index')) || 0];
                    
                    const lag = part.getAttribute('data-layer') || '1';
                    const noter = (part.getAttribute('data-notes') || '').replace(/;/g, ',').replace(/\n/g, ' ');
                    const gruppe = (part.getAttribute('data-group') || '').replace(/;/g, ',');
					const poseIndex = part.getAttribute('data-pose') || '';
					const pose = poseIndex !== '' ? (poseLibrary[poseIndex]?.name || '') : '';
					const mirror = part.getAttribute('data-mirror') || 'false';
                    
                    const stikord1 = (part.getAttribute('data-keyword1') || '').replace(/;/g, ',');
                    const stikord2 = (part.getAttribute('data-keyword2') || '').replace(/;/g, ',');
                    const stikord3 = (part.getAttribute('data-keyword3') || '').replace(/;/g, ',');
                    const stikord4 = (part.getAttribute('data-keyword4') || '').replace(/;/g, ',');
                    const stikord5 = (part.getAttribute('data-keyword5') || '').replace(/;/g, ',');
                    const stikord6 = (part.getAttribute('data-keyword6') || '').replace(/;/g, ',');
                    
                    const form = 'cirkel';
                    const kategori = '';
                    const forbindelser = '';
                    
					csv += `${navn};${posX};${posY};${stÃ¸rrelse};${farveGradient};${borderFarve};${lag};${noter};${stikord1};${stikord2};${stikord3};${stikord4};${stikord5};${stikord6};${gruppe};${form};${kategori};${forbindelser};${currentBackground};${pose};${mirror}`;                    
                    // Add multi-background data
                    allBackgrounds.forEach(bg => {
                        const bgX = part.getAttribute(`data-x-${bg}`) || '';
                        const bgY = part.getAttribute(`data-y-${bg}`) || '';
                        const bgSize = part.getAttribute(`data-size-${bg}`) || '';
                        const bgRes1 = part.getAttribute(`data-res1-${bg}`) || '';
                        const bgRes2 = part.getAttribute(`data-res2-${bg}`) || '';
                        const bgRes3 = part.getAttribute(`data-res3-${bg}`) || '';
                        csv += `;${bgX};${bgY};${bgSize};${bgRes1};${bgRes2};${bgRes3}`;
                    });
                    csv += '\n';
                });
                
                csv += '\n# Gruppenavne\n';
				for (let i = 1; i <= 6; i++) {
					const groupName = document.getElementById(`group${i}`).value.trim();
					const colorBtn = document.getElementById(`groupColor${i}`);
					
					// Hent den aktuelle farvevÃ¦rdi (enten custom eller default)
					const currentColor = colorBtn.getAttribute('data-custom-color') || groupColors[parseInt(colorBtn.getAttribute('data-color-index')) || 0];
					
					csv += `Gruppe${i};${groupName.replace(/;/g, ',')};${currentColor}\n`;
				}
                
                // Efter eksisterende CSV data, tilfÃ¸j alle baggrunds-labels
				csv += '\n# Alle Baggrund Labels\n';
				allBackgrounds.forEach(bg => {
					if (backgroundLabels[bg]) {
						Object.keys(backgroundLabels[bg]).forEach(key => {
							const value = backgroundLabels[bg][key] || '';
							csv += `${bg};${key};${value.replace(/;/g, ',')}\n`;
						});
					}
				});
				
				// Gem generelle noter
				csv += '\n# Generelle Noter\n';
				csv += generalNotes.replace(/;/g, ',').replace(/\n/g, '\\n') + '\n';
                
                // Gem til localStorage
                localStorage.setItem('current_opstilling', csv);
                
            } catch (error) {
                console.error('Fejl ved gemning til localStorage:', error);
            }
        }

        function saveSetup() {
            try {
                const parts = document.querySelectorAll('.part');
                if (parts.length === 0) {
                    alert('Ingen dele at gemme! TilfÃ¸j fÃ¸rst nogle dele til opstillingen.');
                    return;
                }
                
                // Build CSV header with multi-background columns
				let csv = 'Navn;PosX;PosY;StÃ¸rrelse;Farve_Gradient;Border_Farve;Lag;Noter;Stikord1;Stikord2;Stikord3;Stikord4;Stikord5;Stikord6;Gruppe;Form;Kategori;Forbindelser;Baggrund;Pose;Mirror';                
                // Add multi-background columns
                allBackgrounds.forEach(bg => {
                    csv += `;PosX_${bg};PosY_${bg};Size_${bg};Res1_${bg};Res2_${bg};Res3_${bg}`;
                });
                csv += '\n';
                
                parts.forEach(part => {
                    const navn = part.querySelector('.part-name').textContent.replace(/;/g, ',');
                    const posX = parseInt(part.style.left) || 0;
                    const posY = parseInt(part.style.top) || 0;
                    const stÃ¸rrelse = parseFloat(part.getAttribute(`data-size-${currentBackground}`)) || 1;
                    
                    const farveGradient = part.getAttribute('data-custom-color') || 
                                         partColors[parseInt(part.getAttribute('data-color-index')) || 0];
                    const borderFarve = part.getAttribute('data-custom-border') || 
                                       borderColors[parseInt(part.getAttribute('data-color-index')) || 0];
                    
                    const lag = part.getAttribute('data-layer') || '1';
                    const noter = (part.getAttribute('data-notes') || '').replace(/;/g, ',').replace(/\n/g, ' ');
                    const gruppe = (part.getAttribute('data-group') || '').replace(/;/g, ',');
					const poseIndex = part.getAttribute('data-pose') || '';
					const pose = poseIndex !== '' ? (poseLibrary[poseIndex]?.name || '') : '';
					const mirror = part.getAttribute('data-mirror') || 'false';
                    
                    const stikord1 = (part.getAttribute('data-keyword1') || '').replace(/;/g, ',');
                    const stikord2 = (part.getAttribute('data-keyword2') || '').replace(/;/g, ',');
                    const stikord3 = (part.getAttribute('data-keyword3') || '').replace(/;/g, ',');
                    const stikord4 = (part.getAttribute('data-keyword4') || '').replace(/;/g, ',');
                    const stikord5 = (part.getAttribute('data-keyword5') || '').replace(/;/g, ',');
                    const stikord6 = (part.getAttribute('data-keyword6') || '').replace(/;/g, ',');
                    
                    const form = 'cirkel';
                    const kategori = '';
                    const forbindelser = '';
                    
					csv += `${navn};${posX};${posY};${stÃ¸rrelse};${farveGradient};${borderFarve};${lag};${noter};${stikord1};${stikord2};${stikord3};${stikord4};${stikord5};${stikord6};${gruppe};${form};${kategori};${forbindelser};${currentBackground};${pose};${mirror}`;                    
                    // Add multi-background data
                    allBackgrounds.forEach(bg => {
                        const bgX = part.getAttribute(`data-x-${bg}`) || '';
                        const bgY = part.getAttribute(`data-y-${bg}`) || '';
                        const bgSize = part.getAttribute(`data-size-${bg}`) || '';
                        const bgRes1 = part.getAttribute(`data-res1-${bg}`) || '';
                        const bgRes2 = part.getAttribute(`data-res2-${bg}`) || '';
                        const bgRes3 = part.getAttribute(`data-res3-${bg}`) || '';
                        csv += `;${bgX};${bgY};${bgSize};${bgRes1};${bgRes2};${bgRes3}`;
                    });
                    csv += '\n';
                });
                
                csv += '\n# Gruppenavne\n';
				for (let i = 1; i <= 6; i++) {
					const groupName = document.getElementById(`group${i}`).value.trim();
					const colorBtn = document.getElementById(`groupColor${i}`);
					
					// Hent den aktuelle farvevÃ¦rdi (enten custom eller default)
					const currentColor = colorBtn.getAttribute('data-custom-color') || groupColors[parseInt(colorBtn.getAttribute('data-color-index')) || 0];
					
					csv += `Gruppe${i};${groupName.replace(/;/g, ',')};${currentColor}\n`;
				}
                
                // Efter eksisterende CSV data, tilfÃ¸j alle baggrunds-labels
				csv += '\n# Alle Baggrund Labels\n';
				allBackgrounds.forEach(bg => {
					if (backgroundLabels[bg]) {
						Object.keys(backgroundLabels[bg]).forEach(key => {
							const value = backgroundLabels[bg][key] || '';
							csv += `${bg};${key};${value.replace(/;/g, ',')}\n`;
						});
					}
				});
				
				
				// Gem generelle noter
				csv += '\n# Generelle Noter\n';
				csv += generalNotes.replace(/;/g, ',').replace(/\n/g, '\\n') + '\n';
                
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
                const link = document.createElement('a');
                const dato = new Date().toISOString().slice(0, 10);
                
                const fileName = prompt('Filnavn (uden .csv):', `Opstilling_${dato}`);
                if (fileName === null || fileName.trim() === '') {
                    link.download = `Opstilling_${dato}.csv`;
                } else {
                    const cleanName = fileName.trim().replace(/[<>:"/\\|?*]/g, '_');
                    link.download = cleanName.endsWith('.csv') ? cleanName : cleanName + '.csv';
                }
                
                link.href = URL.createObjectURL(blob);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error('Fejl i saveSetup:', error);
                alert('Der opstod en fejl ved gemning af opstillingen.');
            }
        }
		
		
		
		
		
		
        
        function loadSetup() {
            try {
                const fileInput = document.getElementById('fileInput');
                if (fileInput) {
                    if (window.__fileDialogOpen) return;
                    window.__fileDialogOpen = true;
                    fileInput.click();
                } else {
                    alert('Fejl: Kan ikke finde file input element');
                }
            } catch (error) {
                console.error('Fejl i loadSetup:', error);
                alert('Der opstod en fejl ved indlÃ¦sning: ' + error.message);
            }
        }
		
		function exportAsImage() {
    try {
        const workspace = document.getElementById('workspace');
        
        // Skjul control buttons
        const controlBtns = workspace.querySelectorAll('.control-btn');
        controlBtns.forEach(btn => btn.style.display = 'none');
        
        // Skjul selection
        const wasSelected = selectedPart;
        if (selectedPart) {
            selectedPart.classList.remove('selected');
        }
        
        // Modern-screenshot
        modernScreenshot.domToPng(workspace, {
            width: workspace.offsetWidth,
            height: workspace.offsetHeight,
            scale: 2,
			quality: 1 
			
        }).then(dataUrl => {
            // Gendan UI
            controlBtns.forEach(btn => btn.style.display = '');
            if (wasSelected) {
                wasSelected.classList.add('selected');
            }
            
            // Download
            const link = document.createElement('a');
            const dato = new Date().toISOString().slice(0, 10);
            link.download = `Opstilling-${dato}.png`;
            link.href = dataUrl;
            link.click();
            
        }).catch(error => {
            console.error('Fejl:', error);
            
            // Gendan UI ved fejl
            controlBtns.forEach(btn => btn.style.display = '');
            if (wasSelected) {
                wasSelected.classList.add('selected');
            }
            
            alert('Eksport fejlede');
        });
        
    } catch (error) {
        console.error('Fejl:', error);
        alert('Modern-Screenshot ikke tilgÃ¦ngelig');
    }
}
        
        function handleWorkspaceClick(e) {
            try {
                const workspaceEl = document.getElementById('workspace');
                const clickedPart = e.target.closest('.part');

                if (workspaceEl.contains(e.target) && !clickedPart) {
					if (selectedPart) {
						selectedPart.classList.remove('selected');
						selectedPart = null;
						updateGroupsDisplay();

						const titleElement = document.getElementById('profileTitle');
						if (titleElement) titleElement.textContent = '';

						document.getElementById('notesContainerTitle').textContent = 'Noter til opstilling';

						const notesEl = document.getElementById('partNotes');
						notesEl.value = generalNotes;
						notesEl.placeholder = 'Generelle noter til hele opstillingen...';
                        for (let i = 1; i <= 6; i++) {
                            document.getElementById(`keyword${i}`).value = '';
                        }
                    }

                    const rect = workspaceEl.getBoundingClientRect();
                    const x = e.clientX - rect.left - 60;
                    const y = e.clientY - rect.top - 60;
                    const partName = document.getElementById('partName').value.trim();
                    if (partName) addPart(partName, x, y);
                }
            } catch (error) {
                console.error('Fejl i handleWorkspaceClick:', error);
            }
        }
        
        document.addEventListener('DOMContentLoaded', async function() {
            // Load pose library first
            await loadPoseLibrary();
            
            // Try to load current opstilling from localStorage
            const loaded = loadCurrentOpstillingFromStorage();
            if (loaded) {
                console.log('Opstilling indlÃ¦st fra localStorage');
            }
            
            try {
				
				
                // Initialize color picker grid
                const grid = document.getElementById('colorGrid');
                
                for(let row = 0; row < 14; row++) {
                    for(let col = 0; col < 12; col++) {
                        let hex;
                        
                        if(row === 0) {
                            const hue = Math.round(col * 360/12);
                            hex = hslToHex(hue, 95, 50);
                        } else if(row === 1) {
                            const light = Math.round(100 - (col * (100/11)));
                            hex = hslToHex(0, 0, light);
                        } else {
                            const gridRow = row - 2;
                            const hue = Math.round(col * 360/12);
                            const light = Math.round(92 - (gridRow * (84/11)));
                            const satBase = 86;
                            const sat = Math.round(satBase - Math.abs((col - 6)/ 6) * 20);
                            hex = hslToHex(hue, sat, light);
                        }
                        
                        const swatch = document.createElement('button');
                        swatch.className = 'swatch';
                        swatch.style.background = hex;
                        swatch.dataset.hex = hex;
                        swatch.title = hex;
                        swatch.setAttribute('aria-label', `Farve ${hex}`);
                        swatch.tabIndex = 0;
                        
                        swatch.addEventListener('click', () => selectColor(hex));
                        
                        grid.appendChild(swatch);
                    }
                }
                
                // Color picker modal event listener
                document.getElementById('colorPickerModal').addEventListener('click', function(e) {
                    if (e.target === this) {
                        closeColorPicker();
                    }
                });
                
                // Initialize group colors (only if not already set)
                for (let i = 1; i <= 6; i++) {
                    const colorBtn = document.getElementById(`groupColor${i}`);
                    if (colorBtn && !colorBtn.getAttribute('data-custom-color')) {
                        const colorIndex = parseInt(colorBtn.getAttribute('data-color-index')) || 0;
                        colorBtn.style.backgroundColor = groupColors[colorIndex];
                    }
                }
				
				
				// Pose picker modal event listener
				document.getElementById('posePickerModal').addEventListener('click', function(e) {
					if (e.target === this) {
						closePosePicker();
					}
				});
				
				// Keywords popup modal event listener
				document.getElementById('keywordsPopupModal').addEventListener('click', function(e) {
					if (e.target === this) {
						closeKeywordsPopup();
					}
				});
				
                
                // Add event listeners
                const partNameInput = document.getElementById('partName');
                partNameInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        addPart();
                    }
                });
                
                const partNotesTextarea = document.getElementById('partNotes');
				partNotesTextarea.addEventListener('input', function() {
					if (selectedPart) {
						selectedPart.setAttribute('data-notes', this.value);
					} else {
						generalNotes = this.value;
					}
					saveCurrentOpstillingToStorage();
				});
                
                for (let i = 1; i <= 6; i++) {
                    const keywordInput = document.getElementById(`keyword${i}`);
                    if (keywordInput) {
                        keywordInput.addEventListener('input', function() {
                            if (selectedPart) {
                                selectedPart.setAttribute(`data-keyword${i}`, this.value);
                                updatePartKeywords(selectedPart);
                                // Auto-save after keyword input
                                saveCharactersToShared();
                            }
                        });
                    }
                }
                
                const workspace = document.getElementById('workspace');
                workspace.addEventListener('click', handleWorkspaceClick);
                
                const fileInput = document.getElementById('fileInput');
                if (fileInput) {
                    fileInput.addEventListener('change', function(event) {
                        const file = event.target.files[0];
                        // reset guard regardless of pick/cancel
                        window.__fileDialogOpen = false;
                        if (!file) return;
                        
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            isLoadingSetup = true;
                            try {
                                const csv = e.target.result;
                                const lines = csv.split('\n');
                                
                                // Clear existing parts
                                clearAll();
                                
                                for (let line of lines) {
                                    if (line.trim() === '' || line.startsWith('#') || line.includes('Navn;PosX')) continue;
                                    
                                    const parts = line.split(';');
                                    // Check if this line has multi-background data
                                    if (parts.length >= 21) {
                                        const navn = parts[0];
                                        const posX = parseInt(parts[1]) || 0;
                                        const posY = parseInt(parts[2]) || 0;
                                        const stÃ¸rrelse = parseFloat(parts[3]) || 1;
                                        const farveGradient = parts[4];
                                        const borderFarve = parts[5];
                                        const lag = parseInt(parts[6]) || 1;
                                        const noter = parts[7] || '';
                                        const gruppe = parts[14] || '';
                                        const baggrund = parts[18] || 'none';
										const pose = parts[19] || '';
										const mirror = parts[20] === 'true';
                                        
                                        let farveIndex = partColors.findIndex(color => 
                                            color.toLowerCase() === farveGradient.toLowerCase()
                                        );
                                        if (farveIndex === -1) farveIndex = 0;
                                        
                                        // Add part (skip popup when loading from file)
											addPart(navn, posX, posY, true);
                                        
                                        const newPart = document.querySelector('.part:last-child');
                                        if (newPart) {
                                            newPart.setAttribute('data-color-index', farveIndex);
                                            newPart.setAttribute('data-layer', lag);
                                            newPart.setAttribute('data-notes', noter);
                                            newPart.setAttribute('data-group', gruppe);
                                            newPart.setAttribute('data-custom-color', farveGradient);
                                            newPart.setAttribute('data-custom-border', borderFarve);
											// Set pose data - store index instead of name for consistency
											const poseIndex = poseLibrary.findIndex(p => p.name === pose);
											if (poseIndex !== -1) {
												newPart.setAttribute('data-pose', poseIndex.toString());
											} else {
												newPart.setAttribute('data-pose', '');
											}
											newPart.setAttribute('data-mirror', mirror.toString());

											
											
											// Opdater body parts med den korrekte farve
											const head = newPart.querySelector('.head');
											const torso = newPart.querySelector('.torso');
											const armParts = newPart.querySelectorAll('.arm_geo_left, .arm_geo_right, .albue_geo_left, .albue_geo_right');
											const legParts = newPart.querySelectorAll('.laar_geo_left, .laar_geo_right, .skinneben_geo_left, .skinneben_geo_right');

											// Funktion til at gÃ¸re farver mÃ¸rkere
											function darkenColor(hex, factor = 0.92) {
												const r = parseInt(hex.slice(1, 3), 16);
												const g = parseInt(hex.slice(3, 5), 16);
												const b = parseInt(hex.slice(5, 7), 16);
												
												const newR = Math.round(r * factor);
												const newG = Math.round(g * factor);
												const newB = Math.round(b * factor);
												
												return `rgb(${newR}, ${newG}, ${newB})`;
											}

											const darkerColor = darkenColor(farveGradient, 0.92);

											if (head) head.style.background = farveGradient;
											if (torso) torso.style.background = farveGradient;
											armParts.forEach(arm => arm.style.background = darkerColor);
											legParts.forEach(leg => leg.style.background = darkerColor);
                                            
											
                                            
                                            newPart.style.zIndex = lag + 10;
                                            
                                            // Set keywords
                                            for (let i = 8; i <= 13; i++) {
                                                if (parts[i]) {
                                                    newPart.setAttribute(`data-keyword${i-7}`, parts[i]);
                                                }
                                            }
                                            
                                            // Load multi-background data if available
                                            if (parts.length >= 21 + (allBackgrounds.length * 6)) {
                                                let bgIndex = 21;
                                                allBackgrounds.forEach(bg => {
                                                    const bgX = parts[bgIndex] || posX;
                                                    const bgY = parts[bgIndex + 1] || posY;
                                                    const bgSize = parts[bgIndex + 2] || stÃ¸rrelse;
                                                    const bgRes1 = parts[bgIndex + 3] || '';
                                                    const bgRes2 = parts[bgIndex + 4] || '';
                                                    const bgRes3 = parts[bgIndex + 5] || '';
                                                    
                                                    newPart.setAttribute(`data-x-${bg}`, bgX);
                                                    newPart.setAttribute(`data-y-${bg}`, bgY);
                                                    newPart.setAttribute(`data-size-${bg}`, bgSize);
                                                    newPart.setAttribute(`data-res1-${bg}`, bgRes1);
                                                    newPart.setAttribute(`data-res2-${bg}`, bgRes2);
                                                    newPart.setAttribute(`data-res3-${bg}`, bgRes3);
                                                    
                                                    bgIndex += 6;
                                                });
												// Apply current background scale after loading all background data
												const currentScale = parseFloat(newPart.getAttribute(`data-size-${currentBackground}`)) || 1;
												newPart.style.transform = `scale(${currentScale})`;
                                            } else {
                                                // Initialize with current position for all backgrounds (legacy support)
                                                initializePartForAllBackgrounds(newPart, posX, posY, stÃ¸rrelse);
                                            }
                                            
                                            updatePartKeywords(newPart);
											// Apply the pose
											if (pose) {
												// Find pose index by name
												const poseIndex = poseLibrary.findIndex(p => p.name === pose);
												if (poseIndex !== -1) {
													applyPose(newPart, poseIndex, mirror);
												} else {
													resetPose(newPart);
												}
											} else {
												resetPose(newPart);
											}
                                        }
                                        
                                        // Set background if found
                                        if (baggrund && baggrund !== 'none') {
                                            document.getElementById('backgroundSelect').value = baggrund;
                                            currentBackground = baggrund;
                                            changeBackground();
                                        }
                                    }
                                }
                                
                                // ... eksisterende indlÃ¦snings kode ...

								// IndlÃ¦s gruppenavne og farver
								for (let line of lines) {
									if (line.trim() === '' || !line.startsWith('Gruppe')) continue;
									
									const parts = line.split(';');
									if (parts.length >= 3) {
										const groupNumber = parts[0].replace('Gruppe', '');
										const groupName = parts[1] || '';
										const groupColor = parts[2] || '';
										
										const groupInput = document.getElementById(`group${groupNumber}`);
										if (groupInput) {
											groupInput.value = groupName;
										}
										
										const colorBtn = document.getElementById(`groupColor${groupNumber}`);
										if (colorBtn && groupColor) {
											colorBtn.style.backgroundColor = groupColor;
											colorBtn.setAttribute('data-custom-color', groupColor);
											colorBtn.removeAttribute('data-color-index');
										}
									}
								}
								
								// Apply group borders after group colors are loaded
								document.querySelectorAll('.part').forEach(part => {
									const partGroup = part.getAttribute('data-group');
									if (partGroup) {
										for (let i = 1; i <= 6; i++) {
											const groupInput = document.getElementById(`group${i}`);
											if (groupInput && groupInput.value.trim() === partGroup) {
												const colorBtn = document.getElementById(`groupColor${i}`);
												const groupColor = colorBtn.getAttribute('data-custom-color') || colorBtn.style.backgroundColor;
												const head = part.querySelector('.head');
												if (groupColor && head) {
													head.style.border = `4px solid ${groupColor}`;
												}
												break;
											}
										}
									}
								});
								
								
								// IndlÃÂ¦s alle background labels
								let inLabelSection = false;
								for (let line of lines) {
									const trimmedLine = line.trim();
									
									if (trimmedLine === '# Alle Baggrund Labels') {
										inLabelSection = true;
										continue;
									}
									
									if (inLabelSection && (trimmedLine === '' || trimmedLine.startsWith('#'))) {
										break;
									}
									
									if (inLabelSection && trimmedLine !== '') {
										const parts = line.split(';');
										if (parts.length >= 3) {
											const bg = parts[0];
											const key = parts[1];
											const value = parts[2] || '';
											
											if (!backgroundLabels[bg]) {
												backgroundLabels[bg] = { ...defaultLabels[bg] };
											}
											
											backgroundLabels[bg][key] = value;
										}
									}
								}
								
								
								// IndlÃ¦s generelle noter
								let inNotesSection = false;
								let notesContent = '';
								for (let line of lines) {
									const trimmedLine = line.trim();
									
									if (trimmedLine === '# Generelle Noter') {
										inNotesSection = true;
										continue;
									}
									
									if (inNotesSection) {
										notesContent += line.replace(/\\n/g, '\n') + '\n';
									}
								}
								generalNotes = notesContent.trim();
								document.getElementById('partNotes').value = generalNotes;

								// Opdater labels for nuvÃ¦rende baggrund
							renderLabels();

							document.querySelectorAll('.part').forEach(part => {
								const partGroup = part.getAttribute('data-group');
								if (partGroup) {
									for (let i = 1; i <= 6; i++) {
										const groupInput = document.getElementById(`group${i}`);
										if (groupInput && groupInput.value.trim() === partGroup) {
											const colorBtn = document.getElementById(`groupColor${i}`);
											const groupColor = colorBtn.getAttribute('data-custom-color') || colorBtn.style.backgroundColor;
											if (groupColor) {
											const head = part.querySelector('.head');
											if (head) {
												head.style.border = `4px solid ${groupColor}`;
												}
											}
											break;
										}
									}
								}
							});

                            // IndlÃ¦sning fuldfÃ¸rt (silent)
                            // Persist sizes/positions after complete load
                            // Ensure layers are consistent after CSV load
                            normalizeLayers();
                            isLoadingSetup = false;
                            try { saveCharactersToShared(); } catch(_){}
                                
                            } catch (error) {
                                console.error('Fejl ved indlÃ¦sning:', error);
                                alert('Der opstod en fejl ved indlÃ¦sning af filen. Kontroller at det er en gyldig CSV-fil.');
                                isLoadingSetup = false;
                            }
                        };
                        reader.readAsText(file);
                        event.target.value = '';
                        // Skip auto-save during CSV load; final save happens after load completes
                    });
                }
                
                const keywordsVisibleCheckbox = document.getElementById('keywordsVisible');
                if (keywordsVisibleCheckbox) {
                    keywordsVisibleCheckbox.addEventListener('change', function() {
                        const allParts = document.querySelectorAll('.part');
                        allParts.forEach(part => {
                            updatePartKeywords(part);
                        });
                    });
                }
				
				const bodiesVisibleCheckbox = document.getElementById('bodiesVisible');
                if (bodiesVisibleCheckbox) {
                    bodiesVisibleCheckbox.addEventListener('change', toggleAllBodies);
                }
                
                updateGroupsDisplay();
                
                // Add event listeners for group inputs
                for (let i = 1; i <= 6; i++) {
                    const groupInput = document.getElementById(`group${i}`);
                    if (groupInput) {
                        groupInput.addEventListener('input', function() {
                            saveCurrentOpstillingToStorage();
                        });
                    }
                }
                
                // Initialize background
                renderBackground();
                renderLabels();
                
            } catch (error) {
                console.error('Fejl ved initialisering:', error);
            }
        });
        
        document.addEventListener('dragover', (e) => e.preventDefault());
        document.addEventListener('drop', (e) => e.preventDefault());
		
		function toggleAllBodies() {
			try {
				const workspace = document.getElementById('workspace');
				const checkbox = document.getElementById('bodiesVisible');
				
				if (checkbox.checked) {
					workspace.classList.remove('hide-bodies');
				} else {
					workspace.classList.add('hide-bodies');
				}
			} catch (error) {
				console.error('Fejl i toggleAllBodies:', error);
			}
		}
		
		
    </script>
</body>
</html>
                
                